---
phase: 03-your-intern-configuration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/app/api/workspaces/[id]/ari-config/route.ts
  - convex/schema.ts
autonomous: true

must_haves:
  truths:
    - "When AI toggle is OFF, incoming WhatsApp messages skip ARI processing"
    - "When AI toggle is ON, incoming WhatsApp messages go through ARI (Mouth + Brain)"
    - "Webhook handler checks ariConfig.enabled before scheduling processARI"
    - "Dev mode mock data includes enabled field for testing"
  artifacts:
    - path: "convex/kapso.ts"
      provides: "Webhook handler gate checking ariConfig.enabled"
      contains: "if (ariConfig.enabled === false)"
    - path: "src/app/api/workspaces/[id]/ari-config/route.ts"
      provides: "DEFAULT_CONFIG with enabled field"
      contains: "enabled: true"
  key_links:
    - from: "convex/kapso.ts (handleKapsoWebhook)"
      to: "ariConfig.enabled"
      via: "Gate check before scheduling processARI"
      pattern: "if.*enabled.*===.*false"
---

<objective>
Wire Global AI Toggle to skip processARI execution when disabled. AI toggle OFF means no automatic responses, messages wait for human.

Purpose: Complete the toggle integration by connecting UI state to backend processing logic.
Output: Webhook handler respects ariConfig.enabled flag and skips processARI scheduling when false.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-your-intern-configuration/03-01-SUMMARY.md
@.planning/phases/03-your-intern-configuration/03-CONTEXT.md
@.planning/phases/03-your-intern-configuration/03-RESEARCH.md

# Backend processing files
@convex/kapso.ts
@convex/ari.ts
@src/app/api/workspaces/[id]/ari-config/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify ariConfig.enabled gate exists in webhook handler</name>
  <files>convex/kapso.ts</files>
  <action>
Verify that webhook handler in convex/kapso.ts checks ariConfig.enabled before scheduling processARI:

**Location:** Find handleKapsoWebhook function (lines ~360-410 based on research)

**Verify Existing Gate:**
The gate should already exist at lines 384-387:

```typescript
// Check if AI is explicitly disabled (enabled defaults to true if not set)
if (ariConfig.enabled === false) {
  console.log(`[Kapso] AI is disabled for workspace ${workspaceId}`);
  continue;
}
```

**What to verify:**
1. Gate exists in webhook handler (NOT in processARI action handler)
2. Check happens AFTER ariConfig fetch but BEFORE scheduling processARI
3. Uses `continue` to skip to next message (proper loop control)
4. Console log for debugging

**Why this placement is correct:**
- Gate in webhook handler prevents scheduling processARI at all
- More efficient than scheduling then returning early in processARI
- Skips unnecessary mutation calls when AI is disabled
- Follows same pattern as other continue statements in the loop

**If gate is missing or misplaced:**
This would contradict the research findings. Document actual location and suggest fix.

**No changes expected** - this is pure verification that gate exists in correct location.
  </action>
  <verify>
1. Gate exists in handleKapsoWebhook at lines ~384-387
2. Check: `if (ariConfig.enabled === false)`
3. Located after ariConfig fetch, before ctx.scheduler.runAfter
4. Uses `continue` statement (proper loop control)
5. Console log present for debugging
  </verify>
  <done>
- Verified gate exists in webhook handler (lines 384-387)
- Gate correctly placed before processARI scheduling
- Uses `continue` to skip message when AI disabled
- Console log confirms AI disabled state
  </done>
</task>

<task type="auto">
  <name>Task 2: Add enabled field to DEFAULT_CONFIG in ari-config route</name>
  <files>src/app/api/workspaces/[id]/ari-config/route.ts</files>
  <action>
Update DEFAULT_CONFIG constant in src/app/api/workspaces/[id]/ari-config/route.ts to include enabled field:

**Location:** Lines 32-39 (verified in research)

**Current DEFAULT_CONFIG:**
```typescript
const DEFAULT_CONFIG = {
  enabled: true,  // VERIFY THIS EXISTS, add if missing
  bot_name: 'ARI',
  greeting_style: 'professional',
  language: 'id',
  tone: { supportive: true, clear: true, encouraging: true },
  community_link: null,
}
```

**If enabled field is missing:**
Add `enabled: true` as first field after opening brace.

**Why add here (not mock-data.ts):**
- Research shows DEFAULT_CONFIG already exists in route.ts at line 32
- MOCK_ARI_CONFIG constant does NOT exist in src/lib/mock-data.ts
- route.ts DEFAULT_CONFIG is used by GET endpoint in dev mode
- AIToggle component expects config.enabled field from GET response

**Default Value:**
- Set enabled: true by default (AI on by default for new workspaces)
- User can toggle it off via UI (Plan 01)

**Impact:**
- Dev mode GET /api/workspaces/demo/ari-config returns { enabled: true }
- AIToggle component shows correct initial state (ON)
- Consistent with production ariConfig schema
  </action>
  <verify>
1. DEFAULT_CONFIG found in route.ts at lines 32-39
2. enabled: true field exists
3. TypeScript compiles: `npx tsc --noEmit`
4. Field is first or early in config object
5. GET handler uses DEFAULT_CONFIG for dev mode response
  </verify>
  <done>
- DEFAULT_CONFIG includes enabled: true field
- Dev mode GET endpoint returns enabled field
- AIToggle component receives correct initial state
- Consistent with production config shape
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify Convex schema includes enabled field (no changes needed)</name>
  <files>convex/schema.ts</files>
  <action>
Verify ariConfig table schema in convex/schema.ts includes enabled field (pure verification - no changes expected):

**Location:** Line 117 (verified in research)

**Expected Schema:**
```typescript
ariConfig: defineTable({
  workspace_id: v.id("workspaces"),
  enabled: v.optional(v.boolean()), // AI toggle - true by default if not set
  bot_name: v.string(),
  greeting_style: v.string(), // 'professional', 'friendly', 'casual'
  language: v.string(), // 'id', 'en'
  tone: v.optional(v.any()),
  community_link: v.optional(v.string()),
  created_at: v.number(),
  updated_at: v.number(),
})
  .index('by_workspace', ['workspace_id'])
```

**What to verify:**
1. enabled field exists at line 117
2. Field type is `v.optional(v.boolean())`
3. Comment explains: "AI toggle - true by default if not set"
4. Field positioned near top of schema (before bot_name)

**Why v.optional?**
- Existing workspaces may not have this field yet
- Defaults to true if missing (handled in webhook gate check)
- Optional avoids migration breaking existing data

**If field is missing:**
This would contradict research. Add field and document discrepancy.

**No changes expected** - research confirms field exists at line 117.
  </action>
  <verify>
1. ariConfig table in convex/schema.ts includes enabled field (line 117)
2. Field type is v.optional(v.boolean())
3. Comment present explaining default behavior
4. Schema compiles without errors
  </verify>
  <done>
- Verified enabled field exists in schema (line 117)
- Type is optional boolean (allows existing workspaces without field)
- Comment documents default-true behavior
- No schema changes needed
  </done>
</task>

</tasks>

<verification>
**End-to-End Test (Manual):**

Since processARI is triggered by incoming WhatsApp messages and dev mode doesn't have real Kapso webhook, verification focuses on code inspection and dev mode UI behavior:

1. **Code Verification:**
   - Webhook handler has enabled gate check (lines 384-387)
   - DEFAULT_CONFIG includes enabled field
   - Schema includes enabled field (line 117)

2. **Dev Mode UI Test:**
   - Start dev server: `npm run dev`
   - Navigate to http://localhost:3000/demo/knowledge-base
   - Toggle AI OFF → verify toast shows "AI disabled"
   - Toggle AI ON → verify toast shows "AI enabled"
   - No errors in console

3. **Schema Verification:**
   - Run `npx convex dev` (or check running dev server)
   - No schema errors shown
   - Convex dashboard shows ariConfig table with enabled field

**Production Test (After Deployment):**
- Send test WhatsApp message with AI ON → expect ARI response
- Toggle AI OFF via UI
- Send test WhatsApp message with AI OFF → expect no ARI response (message waits for human)
- Toggle AI ON and verify processing resumes

**Expected Behavior:**
- When AI toggle OFF: webhook handler skips scheduling processARI (continues to next message)
- When AI toggle ON: webhook handler schedules processARI normally (Mouth responds, Brain analyzes)
- Toggle state persists across page reloads
</verification>

<success_criteria>
**Measurable Outcomes:**

1. **Gate Functional:** Webhook handler checks ariConfig.enabled and skips scheduling when false
2. **Efficient Skip:** Uses `continue` statement before ctx.scheduler.runAfter (no unnecessary calls)
3. **Schema Updated:** ariConfig table includes enabled optional boolean field
4. **Mock Data Updated:** DEFAULT_CONFIG includes enabled field for dev mode
5. **Integration Complete:** Toggle UI (Plan 01) + backend gate (Plan 02) work together
6. **No Regressions:** Existing ARI flow works when enabled=true (no changes to core logic)

**What "complete" looks like:**
User toggles AI OFF → incoming WhatsApp messages skip processARI scheduling → messages wait for human response. User toggles AI ON → webhook schedules processARI → ARI responds automatically. Gate operates at webhook level (before scheduling), not in processARI itself.
</success_criteria>

<output>
After completion, create `.planning/phases/03-your-intern-configuration/03-02-SUMMARY.md`
</output>
