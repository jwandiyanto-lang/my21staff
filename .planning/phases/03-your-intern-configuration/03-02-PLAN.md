---
phase: 03-your-intern-configuration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - convex/kapso.ts
  - src/lib/mock-data.ts
autonomous: true

must_haves:
  truths:
    - "When AI toggle is OFF, incoming WhatsApp messages skip ARI processing"
    - "When AI toggle is ON, incoming WhatsApp messages go through ARI (Mouth + Brain)"
    - "processARI checks ariConfig.enabled before executing"
    - "Dev mode mock data includes enabled field for testing"
  artifacts:
    - path: "convex/kapso.ts"
      provides: "processARI gate checking ariConfig.enabled"
      contains: "if (!ariConfig?.enabled)"
    - path: "src/lib/mock-data.ts"
      provides: "MOCK_ARI_CONFIG with enabled field"
      contains: "enabled: true"
  key_links:
    - from: "convex/kapso.ts"
      to: "convex/ari.ts"
      via: "getAriConfig query before processARI"
      pattern: "getAriConfig.*workspace_id"
    - from: "processARI"
      to: "ariConfig.enabled"
      via: "Early return if disabled"
      pattern: "if.*!.*enabled.*return"
---

<objective>
Wire Global AI Toggle to skip processARI execution when disabled. AI toggle OFF means no automatic responses, messages wait for human.

Purpose: Complete the toggle integration by connecting UI state to backend processing logic.
Output: ProcessARI respects ariConfig.enabled flag and skips execution when false.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-your-intern-configuration/03-01-SUMMARY.md
@.planning/phases/03-your-intern-configuration/03-CONTEXT.md
@.planning/phases/03-your-intern-configuration/03-RESEARCH.md

# Backend processing files
@convex/kapso.ts
@convex/ari.ts
@src/lib/mock-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ariConfig.enabled gate to processARI</name>
  <files>convex/kapso.ts</files>
  <action>
Modify processARI mutation in convex/kapso.ts to check ariConfig.enabled before processing:

**Location:** Find the processARI mutation function (likely near top of file)

**Add Early Return Check:**
After fetching ariConfig (likely already exists), add gate:

```typescript
export const processARI = mutation({
  args: {
    // existing args
  },
  handler: async (ctx, args) => {
    // ... existing code to get workspace, conversation, etc.

    // Fetch ARI config
    const ariConfig = await ctx.db
      .query('ariConfig')
      .withIndex('by_workspace', (q) => q.eq('workspace_id', workspaceId))
      .first()

    // GATE: Skip processing if AI is disabled
    if (!ariConfig?.enabled) {
      console.log('[processARI] AI disabled for workspace, skipping processing')
      return {
        success: false,
        message: 'AI processing disabled',
        skipped: true,
      }
    }

    // ... rest of existing processARI logic (Mouth, Brain, etc.)
  },
})
```

**Key Points:**
1. Check happens AFTER workspace lookup but BEFORE any AI calls
2. Return early with explicit skipped flag
3. Console log for debugging (helps verify gate is working)
4. Keep existing processARI logic unchanged below this gate

**Why this placement:**
- ariConfig fetch already exists in processARI (from v3.3)
- Early return prevents unnecessary Mouth/Brain API calls
- Skipped flag allows caller (webhook handler) to differentiate between error and intentional skip

**If ariConfig fetch doesn't exist yet:**
Add it before the gate:
```typescript
const ariConfig = await ctx.db
  .query('ariConfig')
  .withIndex('by_workspace', (q) => q.eq('workspace_id', workspaceId))
  .first()
```

**Test Logic:**
- When enabled=true: processARI runs as normal (Mouth responds, Brain analyzes)
- When enabled=false: processARI returns early with skipped=true, no AI calls made
  </action>
  <verify>
1. Find processARI mutation in convex/kapso.ts
2. Verify ariConfig fetch exists (or add it)
3. Verify enabled gate check added before AI processing
4. Early return includes skipped flag
5. TypeScript compiles: `npx tsc --noEmit`
6. Check convex schema has enabled field in ariConfig table
  </verify>
  <done>
- processARI checks ariConfig.enabled before executing
- Early return with skipped flag when disabled
- Console log added for debugging
- Existing processARI logic unchanged (only gate added at top)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add enabled field to mock ARI config for dev mode</name>
  <files>src/lib/mock-data.ts</files>
  <action>
Update MOCK_ARI_CONFIG in src/lib/mock-data.ts to include enabled field:

**Find Existing Mock Config:**
Look for MOCK_ARI_CONFIG constant (likely exported for use in API routes)

**Add enabled Field:**
```typescript
export const MOCK_ARI_CONFIG = {
  workspace_id: 'demo',
  enabled: true,  // ADD THIS FIELD
  bot_name: 'ARI',
  greeting_style: 'professional',
  language: 'id',
  tone: {
    description: 'Professional and supportive',
    greeting_template: 'Hello! I am ARI...',
    supportive: true,
    clear: true,
    encouraging: true,
  },
  community_link: null,
  // ... any other existing fields
}
```

**Why add this:**
- Dev mode API routes return MOCK_ARI_CONFIG
- AIToggle component expects config.enabled field
- Without this field, toggle would show undefined state in dev mode
- Keeps dev mode experience consistent with production

**Default Value:**
- Set enabled: true by default (AI on by default for new workspaces)
- User can toggle it off via UI

**If MOCK_ARI_CONFIG doesn't exist:**
Check for similar mock constant (might be named differently). Look in:
- src/lib/mock-data.ts
- src/app/api/workspaces/[id]/ari-config/route.ts (might have DEFAULT_CONFIG)

If found in route.ts, add enabled: true there instead and document location.
  </action>
  <verify>
1. MOCK_ARI_CONFIG or equivalent found
2. enabled: true field added
3. TypeScript compiles: `npx tsc --noEmit`
4. Check that ari-config GET route returns this mock in dev mode
  </verify>
  <done>
- Mock ARI config includes enabled field
- Default value is true (AI enabled)
- Dev mode toggle UI shows correct initial state
- Consistent with production config shape
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Convex schema to ensure enabled field exists</name>
  <files>convex/schema.ts</files>
  <action>
Verify and update ariConfig table schema in convex/schema.ts to include enabled field:

**Find ariConfig Table Definition:**
Look for defineTable for ariConfig (likely in schema.ts)

**Ensure Field Exists:**
```typescript
ariConfig: defineTable({
  workspace_id: v.id('workspaces'),
  enabled: v.boolean(),  // VERIFY THIS EXISTS, add if missing
  bot_name: v.string(),
  greeting_style: v.optional(v.string()),
  language: v.string(),
  tone: v.optional(v.object({
    description: v.optional(v.string()),
    greeting_template: v.optional(v.string()),
    supportive: v.optional(v.boolean()),
    clear: v.optional(v.boolean()),
    encouraging: v.optional(v.boolean()),
  })),
  community_link: v.union(v.string(), v.null()),
  // ... any other fields
})
  .index('by_workspace', ['workspace_id'])
```

**If enabled Field Missing:**
1. Add `enabled: v.boolean()` to the table definition
2. Run `npx convex dev` to apply schema migration (note: this happens automatically when dev server runs)

**Default Value Handling:**
- In convex/ari.ts, check upsertAriConfig mutation includes enabled field
- Should default to `true` if not provided:
```typescript
export const upsertAriConfig = mutation({
  handler: async (ctx, args) => {
    // ...
    const config = {
      workspace_id: args.workspace_id,
      enabled: args.enabled ?? true,  // Default to enabled
      bot_name: args.bot_name,
      // ...
    }
  }
})
```

**Why verify this:**
- Convex schema changes require migration
- Schema must match what processARI queries
- Better to verify now than debug runtime errors later

**If Schema Already Has enabled Field:**
- Document that verification passed
- No changes needed
  </action>
  <verify>
1. ariConfig table in convex/schema.ts includes enabled field
2. Field type is v.boolean()
3. upsertAriConfig mutation in convex/ari.ts handles enabled field
4. Default value is true (AI enabled by default)
5. Schema compiles: `npx convex dev` (or check running dev server)
  </verify>
  <done>
- Convex schema includes enabled field in ariConfig table
- Type is boolean (not optional)
- upsertAriConfig mutation handles field with true default
- Schema migration applied (if needed)
  </done>
</task>

</tasks>

<verification>
**End-to-End Test (Manual):**

Since processARI is triggered by incoming WhatsApp messages and dev mode doesn't have real Kapso webhook, verification focuses on code inspection and dev mode UI behavior:

1. **Code Verification:**
   - processARI has enabled gate check
   - Mock config includes enabled field
   - Schema includes enabled field

2. **Dev Mode UI Test:**
   - Start dev server: `npm run dev`
   - Navigate to http://localhost:3000/demo/knowledge-base
   - Toggle AI OFF → verify toast shows "AI disabled"
   - Toggle AI ON → verify toast shows "AI enabled"
   - No errors in console

3. **Schema Verification:**
   - Run `npx convex dev` (or check running dev server)
   - No schema errors shown
   - Convex dashboard shows ariConfig table with enabled field

**Production Test (After Deployment):**
- Send test WhatsApp message with AI ON → expect ARI response
- Toggle AI OFF via UI
- Send test WhatsApp message with AI OFF → expect no ARI response (message waits for human)
- Toggle AI ON and verify processing resumes

**Expected Behavior:**
- When AI toggle OFF: processARI returns early, no Mouth/Brain calls
- When AI toggle ON: processARI runs normally (Mouth responds, Brain analyzes)
- Toggle state persists across page reloads
</verification>

<success_criteria>
**Measurable Outcomes:**

1. **Gate Functional:** processARI checks ariConfig.enabled and skips if false
2. **Early Return:** processARI returns with skipped=true when disabled, not error
3. **Schema Updated:** ariConfig table includes enabled boolean field
4. **Mock Data Updated:** Dev mode config includes enabled field
5. **Integration Complete:** Toggle UI (Plan 01) + backend gate (Plan 02) work together
6. **No Regressions:** Existing ARI flow works when enabled=true (no changes to core logic)

**What "complete" looks like:**
User toggles AI OFF → incoming WhatsApp messages skip processARI → messages wait for human response. User toggles AI ON → processARI resumes → ARI responds automatically. All changes are backend-only (no new UI components).
</success_criteria>

<output>
After completion, create `.planning/phases/03-your-intern-configuration/03-02-SUMMARY.md`
</output>
