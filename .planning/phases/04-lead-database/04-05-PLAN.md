---
phase: 04-lead-database
plan: 05
type: execute
wave: 1
depends_on: ["04-01"]
files_modified:
  - convex/leads.ts
autonomous: true

must_haves:
  truths:
    - "Lead status can be updated with validation"
    - "Notes can be added to contacts"
    - "Sarah data can sync to contacts via internal mutation"
  artifacts:
    - path: "convex/leads.ts"
      provides: "Lead management mutations"
      exports: ["updateLeadStatus", "addContactNote", "syncSarahData"]
  key_links:
    - from: "convex/leads.ts"
      to: "convex/schema.ts"
      via: "schema validation"
      pattern: "contacts.*leadStatus"
---

<objective>
Create leads.ts with status management mutations, notes management, and Sarah sync internal mutation.

Purpose: Provide mutations for lead status workflow, note management, and Sarah data sync to contacts table.
Output: New convex/leads.ts with 3 mutations for lead management.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-lead-database/04-CONTEXT.md
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create leads.ts with status management mutations</name>
  <files>convex/leads.ts</files>
  <action>
Create new file `convex/leads.ts` with the following mutations:

**1. updateLeadStatus mutation:**
```typescript
import { mutation, internalMutation, query } from "./_generated/server";
import { v } from "convex/values";

// Valid status transitions
const validTransitions: Record<string, string[]> = {
  new: ["qualified", "archived"],
  qualified: ["contacted", "archived"],
  contacted: ["converted", "qualified", "archived"], // allow backwards
  converted: ["archived"],
  archived: ["new"], // allow re-engagement
};

export const updateLeadStatus = mutation({
  args: {
    contactId: v.id("contacts"),
    newStatus: v.union(
      v.literal("new"),
      v.literal("qualified"),
      v.literal("contacted"),
      v.literal("converted"),
      v.literal("archived")
    ),
    changedBy: v.string(), // "sarah-bot" | "grok-bot" | user email
  },
  handler: async (ctx, args) => {
    const contact = await ctx.db.get(args.contactId);
    if (!contact) throw new Error("Contact not found");

    const currentStatus = contact.leadStatus || "new";
    const allowed = validTransitions[currentStatus] || [];

    if (!allowed.includes(args.newStatus)) {
      throw new Error(`Invalid transition: ${currentStatus} -> ${args.newStatus}`);
    }

    await ctx.db.patch(args.contactId, {
      leadStatus: args.newStatus,
      statusChangedAt: Date.now(),
      statusChangedBy: args.changedBy,
      lastActivityAt: Date.now(),
      updated_at: Date.now(),
    });

    return { success: true, newStatus: args.newStatus };
  },
});
```

**2. addContactNote mutation:**
```typescript
export const addContactNote = mutation({
  args: {
    contactId: v.id("contacts"),
    content: v.string(),
    addedBy: v.string(), // "sarah-bot" | "grok-bot" | user email
  },
  handler: async (ctx, args) => {
    const contact = await ctx.db.get(args.contactId);
    if (!contact) throw new Error("Contact not found");

    const existingNotes = contact.notes || [];
    const MAX_NOTES = 100;

    // Limit array size (keep last 100)
    const notes = existingNotes.length >= MAX_NOTES
      ? [...existingNotes.slice(-MAX_NOTES + 1), {
          content: args.content,
          addedBy: args.addedBy,
          addedAt: Date.now(),
        }]
      : [...existingNotes, {
          content: args.content,
          addedBy: args.addedBy,
          addedAt: Date.now(),
        }];

    await ctx.db.patch(args.contactId, {
      notes,
      lastActivityAt: Date.now(),
      updated_at: Date.now(),
    });

    return { success: true, noteCount: notes.length };
  },
});
```

**3. Internal mutation for Sarah sync:**
```typescript
export const syncSarahData = internalMutation({
  args: {
    contactId: v.id("contacts"),
    extractedData: v.object({
      name: v.optional(v.string()),
      businessType: v.optional(v.string()),
      domisili: v.optional(v.string()),
      businessDuration: v.optional(v.string()),
      painPoints: v.optional(v.array(v.string())),
      interestMotivation: v.optional(v.string()),
      priority: v.optional(v.string()),
      urgencyLevel: v.optional(v.string()),
      leadScore: v.optional(v.number()),
      leadTemperature: v.optional(v.string()),
    }),
    sarahLanguage: v.optional(v.string()),
    currentPhase: v.optional(v.string()), // A, B, C, D
  },
  handler: async (ctx, args) => {
    const { contactId, extractedData, sarahLanguage, currentPhase } = args;

    // Map Sarah phase to lead status
    const phaseToStatus: Record<string, string> = {
      A: "new",
      B: "qualified",
      C: "qualified",
      D: "contacted",
    };

    const updates: Record<string, any> = {
      ...extractedData,
      sarahLanguage,
      lastActivityAt: Date.now(),
      updated_at: Date.now(),
    };

    // Update lead status based on phase if provided
    if (currentPhase && phaseToStatus[currentPhase]) {
      updates.leadStatus = phaseToStatus[currentPhase];
      updates.statusChangedAt = Date.now();
      updates.statusChangedBy = "sarah-bot";
    }

    // Validate and cast leadTemperature
    if (extractedData.leadTemperature) {
      const validTemps = ["hot", "warm", "lukewarm", "cold"];
      if (validTemps.includes(extractedData.leadTemperature)) {
        updates.leadTemperature = extractedData.leadTemperature;
      }
    }

    await ctx.db.patch(contactId, updates);
    return { success: true };
  },
});
```

Export all functions at module level.
  </action>
  <verify>
1. Run `npx convex dev --once` to validate new functions compile
2. Grep convex/leads.ts for "updateLeadStatus" - should find export
3. Grep convex/leads.ts for "addContactNote" - should find export
4. Grep convex/leads.ts for "syncSarahData" - should find export
  </verify>
  <done>
leads.ts exists with updateLeadStatus, addContactNote, and syncSarahData mutations. Status transitions are validated. Notes array is limited to 100.
  </done>
</task>

</tasks>

<verification>
1. `npx convex dev --once` completes without errors
2. leads.ts exports 3 functions (2 mutations + 1 internalMutation)
3. Status transition validation works (new -> contacted should fail)
4. Notes array limited to 100 entries
</verification>

<success_criteria>
- updateLeadStatus validates status transitions
- addContactNote appends notes with MAX 100 limit
- syncSarahData maps Sarah phases to lead status
- All functions compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-lead-database/04-05-SUMMARY.md`
</output>
