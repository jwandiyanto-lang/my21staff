---
phase: 04-lead-database
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-05"]
files_modified:
  - convex/sarah.ts
  - convex/syncFailures.ts
autonomous: true

must_haves:
  truths:
    - "Sarah state updates sync extracted data to contacts table"
    - "Lead status updates based on Sarah conversation phase"
    - "HTTP endpoint preserves backward compatibility"
    - "Sync failures are logged for visibility"
  artifacts:
    - path: "convex/sarah.ts"
      provides: "Sarah state sync to contacts"
      contains: "syncToContacts"
    - path: "convex/syncFailures.ts"
      provides: "Sync failure logging for monitoring"
      exports: ["logSyncFailure", "getSyncFailures"]
  key_links:
    - from: "convex/sarah.ts"
      to: "contacts table"
      via: "ctx.db.patch"
      pattern: "leadStatus.*sarah-bot"
---

<objective>
Modify Sarah state management to sync extracted data and conversation phase to the contacts table when state updates. Add sync failure logging for monitoring.

Purpose: When Sarah extracts lead information (name, business type, pain points), that data should flow to the contacts table for dashboard display and lead scoring. Sync failures should be logged for visibility.
Output: Updated sarah.ts with contact sync logic, new syncFailures.ts for failure tracking.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-lead-database/04-RESEARCH.md
@convex/sarah.ts
@convex/http.ts
@convex/leads.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add contact lookup and sync to Sarah state management</name>
  <files>convex/sarah.ts</files>
  <action>
Add a new internal mutation to sarah.ts that syncs Sarah data to the contacts table.

**Add new imports at top of file:**
```typescript
import { internal } from "./_generated/api";
```

**Add new internal mutation after the existing `update` mutation:**

```typescript
/**
 * Sync Sarah conversation data to contacts table
 * Called after each Sarah state update to keep lead data current
 */
export const syncToContacts = internalMutation({
  args: {
    contact_phone: v.string(),
    workspace_id: v.optional(v.string()),
    state: v.string(),
    lead_score: v.number(),
    lead_temperature: v.string(),
    extracted_data: v.any(),
    language: v.string(),
  },
  handler: async (ctx, args) => {
    const {
      contact_phone,
      workspace_id,
      state,
      lead_score,
      lead_temperature,
      extracted_data,
      language,
    } = args;

    // Normalize phone for contact lookup
    const normalizedPhone = contact_phone.replace(/\D/g, "");

    // Find contact by phone (search all workspaces if workspace_id not provided)
    let contact;
    if (workspace_id) {
      // @ts-ignore - workspace_id is string from Kapso, contacts use Id
      contact = await ctx.db
        .query("contacts")
        .filter((q) => q.eq(q.field("phone"), normalizedPhone))
        .first();
    } else {
      contact = await ctx.db
        .query("contacts")
        .filter((q) => q.eq(q.field("phone"), normalizedPhone))
        .first();
    }

    if (!contact) {
      console.log(`[Sarah Sync] No contact found for phone: ${normalizedPhone}`);
      return { synced: false, reason: "contact_not_found" };
    }

    // Map Sarah state to lead status
    // Sarah states: 'greeting' | 'qualifying' | 'scoring' | 'handoff' | 'completed'
    const stateToStatus: Record<string, string> = {
      greeting: "new",
      qualifying: "qualified",
      scoring: "qualified",
      handoff: "contacted",
      completed: "converted",
    };

    // Validate lead temperature
    const validTemps = ["hot", "warm", "lukewarm", "cold"];
    const safeTemperature = validTemps.includes(lead_temperature)
      ? lead_temperature
      : "cold";

    const now = Date.now();

    // Build updates object with Sarah data
    const updates: Record<string, any> = {
      // Sarah Phase 1 fields
      businessType: extracted_data?.business_type,
      // Sarah Phase 2 fields
      painPoints: extracted_data?.pain_points,
      // Sarah Phase 3 fields
      leadScore: lead_score,
      leadTemperature: safeTemperature,
      // Language
      sarahLanguage: language,
      // Status
      leadStatus: stateToStatus[state] || contact.leadStatus || "new",
      statusChangedAt: now,
      statusChangedBy: "sarah-bot",
      // Timestamps
      lastActivityAt: now,
      updated_at: now,
    };

    // Only set name if extracted and contact doesn't have one
    if (extracted_data?.name && !contact.name) {
      updates.name = extracted_data.name;
    }

    // Patch contact with Sarah data
    await ctx.db.patch(contact._id, updates);

    console.log(`[Sarah Sync] Synced data to contact ${contact._id}: score=${lead_score}, status=${updates.leadStatus}`);
    return { synced: true, contactId: contact._id };
  },
});
```

This mutation:
1. Finds contact by normalized phone number
2. Maps Sarah state to lead status
3. Validates lead temperature
4. Syncs all Sarah extraction fields
5. Logs sync for debugging
  </action>
  <verify>
1. Run `npx convex dev --once` to validate new mutation compiles
2. Grep sarah.ts for "syncToContacts" - should find export
3. Grep sarah.ts for "leadStatus" - should find in updates object
4. Grep sarah.ts for "contact_not_found" - should find error handling
  </verify>
  <done>
sarah.ts has syncToContacts mutation that maps Sarah data to contacts table fields. Mutation returns {synced: boolean, reason?: string} for tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify upsertSarahState to trigger contact sync with failure logging</name>
  <files>convex/sarah.ts</files>
  <action>
Update the `upsertSarahState` HTTP action to call syncToContacts after saving Sarah state, with failure logging.

**Modify the upsertSarahState function:**

After the existing state save logic (after `await ctx.runMutation(internal.sarah.update, ...)` or `create`), add the sync call with failure tracking:

```typescript
// NEW: Sync to contacts table for dashboard
let syncResult = { synced: false, reason: "not_attempted" };
try {
  syncResult = await ctx.runMutation(internal.sarah.syncToContacts, {
    contact_phone,
    workspace_id: body.workspace_id,
    state: state || "greeting",
    lead_score: lead_score || 0,
    lead_temperature: lead_temperature || "cold",
    extracted_data: extracted_data || {},
    language: language || "id",
  });
} catch (syncError) {
  // Log failure for monitoring but don't break Sarah state save
  syncResult = { synced: false, reason: String(syncError) };
  console.error("[Sarah] Contact sync failed:", syncError);

  // Log to syncFailures table for visibility
  try {
    await ctx.runMutation(internal.syncFailures.logSyncFailure, {
      source: "sarah",
      contact_phone,
      error: String(syncError),
      payload: JSON.stringify({
        state: state || "greeting",
        lead_score: lead_score || 0,
        lead_temperature: lead_temperature || "cold",
      }),
    });
  } catch (logError) {
    // Don't fail if logging fails
    console.error("[Sarah] Failed to log sync failure:", logError);
  }
}

return new Response(JSON.stringify({
  success: true,
  sync: syncResult.synced,
  syncReason: syncResult.reason
}), {
  status: 200,
  headers: { "Content-Type": "application/json" },
});
```

Key points:
1. Sync is wrapped in try/catch - Sarah state save should succeed even if contact sync fails
2. workspace_id is passed through if present in request body
3. Sync happens after successful state save
4. Failures are logged to syncFailures table for monitoring
5. Response includes sync status for debugging
  </action>
  <verify>
1. Run `npx convex dev --once` to validate
2. Grep sarah.ts for "syncToContacts" - should find call in upsertSarahState
3. Grep sarah.ts for "logSyncFailure" - should find failure logging call
4. Grep sarah.ts for '"sync":' or "sync:" - should find in response
  </verify>
  <done>
upsertSarahState HTTP action triggers contact sync on every Sarah state update. Failures are logged to syncFailures table for visibility.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create syncFailures.ts for failure monitoring</name>
  <files>convex/syncFailures.ts</files>
  <action>
Create new file `convex/syncFailures.ts` for sync failure logging.

```typescript
import { internalMutation, query } from "./_generated/server";
import { v } from "convex/values";

/**
 * Log a sync failure for monitoring
 */
export const logSyncFailure = internalMutation({
  args: {
    source: v.string(), // "sarah" | "kapso" | "background"
    contact_phone: v.optional(v.string()),
    error: v.string(),
    payload: v.optional(v.string()), // JSON stringified for flexibility
  },
  handler: async (ctx, args) => {
    const now = Date.now();

    // Keep only last 1000 failures (cleanup old ones)
    const oldFailures = await ctx.db
      .query("syncFailures" as any)
      .order("asc")
      .take(100);

    const totalCount = await ctx.db
      .query("syncFailures" as any)
      .collect()
      .then(all => all.length);

    if (totalCount > 1000) {
      // Delete oldest entries
      for (const old of oldFailures.slice(0, Math.min(100, totalCount - 900))) {
        await ctx.db.delete(old._id);
      }
    }

    await ctx.db.insert("syncFailures" as any, {
      source: args.source,
      contact_phone: args.contact_phone,
      error: args.error,
      payload: args.payload,
      created_at: now,
      resolved: false,
    });

    console.log(`[SyncFailure] Logged: ${args.source} - ${args.error.substring(0, 100)}`);
    return { logged: true };
  },
});

/**
 * Get recent sync failures for monitoring
 */
export const getSyncFailures = query({
  args: {
    limit: v.optional(v.number()),
    source: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit || 50;

    let failures = await ctx.db
      .query("syncFailures" as any)
      .order("desc")
      .take(limit * 2); // Get more to allow filtering

    if (args.source) {
      failures = failures.filter((f: any) => f.source === args.source);
    }

    return failures.slice(0, limit);
  },
});

/**
 * Mark failures as resolved
 */
export const resolveFailures = internalMutation({
  args: {
    failureIds: v.array(v.id("syncFailures" as any)),
  },
  handler: async (ctx, args) => {
    for (const id of args.failureIds) {
      await ctx.db.patch(id, { resolved: true });
    }
    return { resolved: args.failureIds.length };
  },
});
```

**Also add syncFailures table to schema.ts:**
```typescript
// In convex/schema.ts, add:
syncFailures: defineTable({
  source: v.string(),
  contact_phone: v.optional(v.string()),
  error: v.string(),
  payload: v.optional(v.string()),
  created_at: v.number(),
  resolved: v.boolean(),
}).index("by_created", ["created_at"])
  .index("by_source", ["source"]),
```
  </action>
  <verify>
1. Run `npx convex dev --once` to validate new file compiles
2. Check convex/syncFailures.ts exists with logSyncFailure export
3. Check convex/schema.ts contains syncFailures table definition
  </verify>
  <done>
syncFailures.ts created with logSyncFailure, getSyncFailures, and resolveFailures functions. Schema includes syncFailures table. Failures auto-cleanup to last 1000 entries.
  </done>
</task>

</tasks>

<verification>
1. `npx convex dev --once` completes without errors
2. sarah.ts exports syncToContacts internal mutation
3. upsertSarahState calls syncToContacts after state save
4. Sync failure does not break Sarah state save (graceful degradation)
5. Failures are logged to syncFailures table for visibility
6. getSyncFailures query available for monitoring
</verification>

<success_criteria>
- Every Sarah state update syncs extracted data to contacts table
- Lead status updates based on Sarah conversation phase (greeting->new, qualifying->qualified, etc.)
- HTTP endpoint maintains backward compatibility (still returns success for state save)
- Sync errors are logged to syncFailures table for visibility
- Sync failure does not break Sarah state save
</success_criteria>

<output>
After completion, create `.planning/phases/04-lead-database/04-03-SUMMARY.md`
</output>
