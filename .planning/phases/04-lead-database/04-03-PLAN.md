---
phase: 04-lead-database
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - convex/sarah.ts
  - convex/http.ts
autonomous: true

must_haves:
  truths:
    - "Sarah state updates sync extracted data to contacts table"
    - "Lead status updates based on Sarah conversation phase"
    - "HTTP endpoint preserves backward compatibility"
  artifacts:
    - path: "convex/sarah.ts"
      provides: "Sarah state sync to contacts"
      contains: "syncToContacts"
    - path: "convex/http.ts"
      provides: "Updated Sarah state endpoint"
  key_links:
    - from: "convex/sarah.ts"
      to: "convex/leads.ts"
      via: "internal.leads.syncSarahData"
      pattern: "syncSarahData"
---

<objective>
Modify Sarah state management to sync extracted data and conversation phase to the contacts table when state updates.

Purpose: When Sarah extracts lead information (name, business type, pain points), that data should flow to the contacts table for dashboard display and lead scoring.
Output: Updated sarah.ts with contact sync logic, modified HTTP endpoint to trigger sync.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-lead-database/04-RESEARCH.md
@convex/sarah.ts
@convex/http.ts
@convex/leads.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add contact lookup and sync to Sarah state management</name>
  <files>convex/sarah.ts</files>
  <action>
Add a new internal mutation to sarah.ts that syncs Sarah data to the contacts table.

**Add new imports at top of file:**
```typescript
import { internal } from "./_generated/api";
```

**Add new internal mutation after the existing `update` mutation:**

```typescript
/**
 * Sync Sarah conversation data to contacts table
 * Called after each Sarah state update to keep lead data current
 */
export const syncToContacts = internalMutation({
  args: {
    contact_phone: v.string(),
    workspace_id: v.optional(v.string()),
    state: v.string(),
    lead_score: v.number(),
    lead_temperature: v.string(),
    extracted_data: v.any(),
    language: v.string(),
  },
  handler: async (ctx, args) => {
    const {
      contact_phone,
      workspace_id,
      state,
      lead_score,
      lead_temperature,
      extracted_data,
      language,
    } = args;

    // Normalize phone for contact lookup
    const normalizedPhone = contact_phone.replace(/\D/g, "");

    // Find contact by phone (search all workspaces if workspace_id not provided)
    let contact;
    if (workspace_id) {
      // @ts-ignore - workspace_id is string from Kapso, contacts use Id
      contact = await ctx.db
        .query("contacts")
        .filter((q) => q.eq(q.field("phone"), normalizedPhone))
        .first();
    } else {
      contact = await ctx.db
        .query("contacts")
        .filter((q) => q.eq(q.field("phone"), normalizedPhone))
        .first();
    }

    if (!contact) {
      console.log(`[Sarah Sync] No contact found for phone: ${normalizedPhone}`);
      return { synced: false, reason: "contact_not_found" };
    }

    // Map Sarah state to lead status
    // Sarah states: 'greeting' | 'qualifying' | 'scoring' | 'handoff' | 'completed'
    const stateToStatus: Record<string, string> = {
      greeting: "new",
      qualifying: "qualified",
      scoring: "qualified",
      handoff: "contacted",
      completed: "converted",
    };

    // Validate lead temperature
    const validTemps = ["hot", "warm", "lukewarm", "cold"];
    const safeTemperature = validTemps.includes(lead_temperature)
      ? lead_temperature
      : "cold";

    const now = Date.now();

    // Build updates object with Sarah data
    const updates: Record<string, any> = {
      // Sarah Phase 1 fields
      businessType: extracted_data?.business_type,
      // Sarah Phase 2 fields
      painPoints: extracted_data?.pain_points,
      // Sarah Phase 3 fields
      leadScore: lead_score,
      leadTemperature: safeTemperature,
      // Language
      sarahLanguage: language,
      // Status
      leadStatus: stateToStatus[state] || contact.leadStatus || "new",
      statusChangedAt: now,
      statusChangedBy: "sarah-bot",
      // Timestamps
      lastActivityAt: now,
      updated_at: now,
    };

    // Only set name if extracted and contact doesn't have one
    if (extracted_data?.name && !contact.name) {
      updates.name = extracted_data.name;
    }

    // Patch contact with Sarah data
    await ctx.db.patch(contact._id, updates);

    console.log(`[Sarah Sync] Synced data to contact ${contact._id}: score=${lead_score}, status=${updates.leadStatus}`);
    return { synced: true, contactId: contact._id };
  },
});
```

This mutation:
1. Finds contact by normalized phone number
2. Maps Sarah state to lead status
3. Validates lead temperature
4. Syncs all Sarah extraction fields
5. Logs sync for debugging
  </action>
  <verify>
Run `npx convex dev --once` to validate new mutation compiles.
  </verify>
  <done>
sarah.ts has syncToContacts mutation that maps Sarah data to contacts table fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify upsertSarahState to trigger contact sync</name>
  <files>convex/sarah.ts</files>
  <action>
Update the `upsertSarahState` HTTP action to call syncToContacts after saving Sarah state.

**Modify the upsertSarahState function:**

After the existing state save logic (after `await ctx.runMutation(internal.sarah.update, ...)` or `create`), add the sync call:

```typescript
// Sync to contacts table for dashboard
await ctx.runMutation(internal.sarah.syncToContacts, {
  contact_phone,
  workspace_id: body.workspace_id, // Optional, may not be present
  state: state || "greeting",
  lead_score: lead_score || 0,
  lead_temperature: lead_temperature || "cold",
  extracted_data: extracted_data || {},
  language: language || "id",
});
```

The full updated upsertSarahState should be:

```typescript
export const upsertSarahState = httpAction(async (ctx, request) => {
  const body = await request.json();
  const {
    contact_phone,
    state,
    lead_score,
    lead_temperature,
    extracted_data,
    language,
    message_count,
  } = body;

  // Validate required fields
  if (!contact_phone) {
    return new Response(
      JSON.stringify({ error: "contact_phone is required" }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const now = Date.now();

  // Check for existing conversation
  const existing = await ctx.runQuery(internal.sarah.getByPhone, { contact_phone });

  const data = {
    contact_phone,
    state: state || "greeting",
    lead_score: lead_score || 0,
    lead_temperature: lead_temperature || "cold",
    extracted_data: extracted_data || {},
    language: language || "id",
    message_count: message_count || 0,
    updated_at: now,
    last_message_at: now,
  };

  if (existing) {
    // Update existing conversation
    await ctx.runMutation(internal.sarah.update, { id: existing._id, ...data });
  } else {
    // Create new conversation
    await ctx.runMutation(internal.sarah.create, {
      ...data,
      created_at: now,
    });
  }

  // NEW: Sync to contacts table for dashboard
  try {
    await ctx.runMutation(internal.sarah.syncToContacts, {
      contact_phone,
      workspace_id: body.workspace_id,
      state: state || "greeting",
      lead_score: lead_score || 0,
      lead_temperature: lead_temperature || "cold",
      extracted_data: extracted_data || {},
      language: language || "id",
    });
  } catch (syncError) {
    // Log but don't fail - Sarah state was saved successfully
    console.error("[Sarah] Contact sync failed:", syncError);
  }

  return new Response(JSON.stringify({ success: true }), {
    status: 200,
    headers: { "Content-Type": "application/json" },
  });
});
```

Key points:
1. Sync is wrapped in try/catch - Sarah state save should succeed even if contact sync fails
2. workspace_id is passed through if present in request body
3. Sync happens after successful state save
  </action>
  <verify>
1. Run `npx convex dev --once` to validate
2. Check upsertSarahState contains "syncToContacts" call
  </verify>
  <done>
upsertSarahState HTTP action triggers contact sync on every Sarah state update.
  </done>
</task>

</tasks>

<verification>
1. `npx convex dev --once` completes without errors
2. sarah.ts exports syncToContacts internal mutation
3. upsertSarahState calls syncToContacts after state save
4. Sync failure does not break Sarah state save (graceful degradation)
</verification>

<success_criteria>
- Every Sarah state update syncs extracted data to contacts table
- Lead status updates based on Sarah conversation phase (greeting->new, qualifying->qualified, etc.)
- HTTP endpoint maintains backward compatibility (still returns success for state save)
- Sync errors are logged but don't break the flow
</success_criteria>

<output>
After completion, create `.planning/phases/04-lead-database/04-03-SUMMARY.md`
</output>
