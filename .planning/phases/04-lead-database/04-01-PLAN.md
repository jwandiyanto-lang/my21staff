---
phase: 04-lead-database
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/leads.ts
autonomous: true

must_haves:
  truths:
    - "Contacts table includes all Sarah extraction fields"
    - "Lead status enum supports full workflow (new -> qualified -> contacted -> converted -> archived)"
    - "Notes array allows bot and human annotations"
    - "Timestamp fields track all activity types"
  artifacts:
    - path: "convex/schema.ts"
      provides: "Extended contacts schema with Sarah fields, status, notes, timestamps"
      contains: "businessType"
    - path: "convex/leads.ts"
      provides: "Lead status mutation with validation"
      exports: ["updateLeadStatus"]
  key_links:
    - from: "convex/leads.ts"
      to: "convex/schema.ts"
      via: "schema validation"
      pattern: "contacts.*leadStatus"
---

<objective>
Extend Convex contacts schema with Sarah extraction fields, lead status workflow, notes timeline, and timestamp tracking.

Purpose: Create the data structure to store all lead information from Sarah conversations, enabling dashboard display and lead management.
Output: Updated schema.ts with extended contacts table, new leads.ts with status management mutations.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-lead-database/04-CONTEXT.md
@.planning/phases/04-lead-database/04-RESEARCH.md
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend contacts schema with Sarah fields</name>
  <files>convex/schema.ts</files>
  <action>
Add the following fields to the existing `contacts` table definition. All new fields must be `v.optional()` to avoid breaking existing contacts.

**Sarah Phase 1 (Gathering) fields:**
```typescript
businessType: v.optional(v.string()),
domisili: v.optional(v.string()),
businessDuration: v.optional(v.string()),
story: v.optional(v.string()),
sarahLanguage: v.optional(v.string()), // 'id' | 'en' - renamed to avoid conflict
```

**Sarah Phase 2 (Interest) fields:**
```typescript
painPoints: v.optional(v.array(v.string())),
interestMotivation: v.optional(v.string()),
priority: v.optional(v.string()),
urgencyLevel: v.optional(v.string()),
```

**Sarah Phase 3 (Closing) fields:**
```typescript
leadScore: v.optional(v.number()), // 0-100, separate from existing lead_score for Sarah-specific
leadTemperature: v.optional(v.union(
  v.literal("hot"),
  v.literal("warm"),
  v.literal("lukewarm"),
  v.literal("cold")
)),
closingTechnique: v.optional(v.string()),
objectionRaised: v.optional(v.string()),
```

**Status workflow fields:**
```typescript
leadStatus: v.optional(v.union(
  v.literal("new"),
  v.literal("qualified"),
  v.literal("contacted"),
  v.literal("converted"),
  v.literal("archived")
)),
statusChangedAt: v.optional(v.number()),
statusChangedBy: v.optional(v.string()), // "sarah-bot" | "grok-bot" | user email
```

**Notes timeline array:**
```typescript
notes: v.optional(v.array(v.object({
  content: v.string(),
  addedBy: v.string(), // "sarah-bot" | "grok-bot" | user email
  addedAt: v.number(),
}))),
```

**Timestamp fields:**
```typescript
lastContactAt: v.optional(v.number()), // Last human outreach (outbound)
lastActivityAt: v.optional(v.number()), // Any interaction (message, status, note)
```

**Add new index for analytics queries:**
```typescript
.index("by_workspace_status", ["workspace_id", "leadStatus"])
.index("by_workspace_temperature", ["workspace_id", "leadTemperature"])
```

Do NOT remove or modify existing fields. Only ADD new fields.
  </action>
  <verify>
Run `npx convex dev --once` to validate schema changes. Should complete without errors.
  </verify>
  <done>
Contacts table in schema.ts includes all 16 new fields (Sarah extraction, status, notes, timestamps) and 2 new indexes. All fields are optional.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create leads.ts with status management</name>
  <files>convex/leads.ts</files>
  <action>
Create new file `convex/leads.ts` with the following mutations:

**1. updateLeadStatus mutation:**
```typescript
import { mutation, internalMutation } from "./_generated/server";
import { v } from "convex/values";

// Valid status transitions
const validTransitions: Record<string, string[]> = {
  new: ["qualified", "archived"],
  qualified: ["contacted", "archived"],
  contacted: ["converted", "qualified", "archived"], // allow backwards
  converted: ["archived"],
  archived: ["new"], // allow re-engagement
};

export const updateLeadStatus = mutation({
  args: {
    contactId: v.id("contacts"),
    newStatus: v.union(
      v.literal("new"),
      v.literal("qualified"),
      v.literal("contacted"),
      v.literal("converted"),
      v.literal("archived")
    ),
    changedBy: v.string(), // "sarah-bot" | "grok-bot" | user email
  },
  handler: async (ctx, args) => {
    const contact = await ctx.db.get(args.contactId);
    if (!contact) throw new Error("Contact not found");

    const currentStatus = contact.leadStatus || "new";
    const allowed = validTransitions[currentStatus] || [];

    if (!allowed.includes(args.newStatus)) {
      throw new Error(`Invalid transition: ${currentStatus} -> ${args.newStatus}`);
    }

    await ctx.db.patch(args.contactId, {
      leadStatus: args.newStatus,
      statusChangedAt: Date.now(),
      statusChangedBy: args.changedBy,
      lastActivityAt: Date.now(),
      updated_at: Date.now(),
    });

    return { success: true, newStatus: args.newStatus };
  },
});
```

**2. addContactNote mutation:**
```typescript
export const addContactNote = mutation({
  args: {
    contactId: v.id("contacts"),
    content: v.string(),
    addedBy: v.string(), // "sarah-bot" | "grok-bot" | user email
  },
  handler: async (ctx, args) => {
    const contact = await ctx.db.get(args.contactId);
    if (!contact) throw new Error("Contact not found");

    const existingNotes = contact.notes || [];
    const MAX_NOTES = 100;

    // Limit array size (keep last 100)
    const notes = existingNotes.length >= MAX_NOTES
      ? [...existingNotes.slice(-MAX_NOTES + 1), {
          content: args.content,
          addedBy: args.addedBy,
          addedAt: Date.now(),
        }]
      : [...existingNotes, {
          content: args.content,
          addedBy: args.addedBy,
          addedAt: Date.now(),
        }];

    await ctx.db.patch(args.contactId, {
      notes,
      lastActivityAt: Date.now(),
      updated_at: Date.now(),
    });

    return { success: true, noteCount: notes.length };
  },
});
```

**3. Internal mutation for Sarah sync (used in Task 3 of next plan):**
```typescript
export const syncSarahData = internalMutation({
  args: {
    contactId: v.id("contacts"),
    extractedData: v.object({
      name: v.optional(v.string()),
      businessType: v.optional(v.string()),
      domisili: v.optional(v.string()),
      businessDuration: v.optional(v.string()),
      painPoints: v.optional(v.array(v.string())),
      interestMotivation: v.optional(v.string()),
      priority: v.optional(v.string()),
      urgencyLevel: v.optional(v.string()),
      leadScore: v.optional(v.number()),
      leadTemperature: v.optional(v.string()),
    }),
    sarahLanguage: v.optional(v.string()),
    currentPhase: v.optional(v.string()), // A, B, C, D
  },
  handler: async (ctx, args) => {
    const { contactId, extractedData, sarahLanguage, currentPhase } = args;

    // Map Sarah phase to lead status
    const phaseToStatus: Record<string, string> = {
      A: "new",
      B: "qualified",
      C: "qualified",
      D: "contacted",
    };

    const updates: Record<string, any> = {
      ...extractedData,
      sarahLanguage,
      lastActivityAt: Date.now(),
      updated_at: Date.now(),
    };

    // Update lead status based on phase if provided
    if (currentPhase && phaseToStatus[currentPhase]) {
      updates.leadStatus = phaseToStatus[currentPhase];
      updates.statusChangedAt = Date.now();
      updates.statusChangedBy = "sarah-bot";
    }

    // Validate and cast leadTemperature
    if (extractedData.leadTemperature) {
      const validTemps = ["hot", "warm", "lukewarm", "cold"];
      if (validTemps.includes(extractedData.leadTemperature)) {
        updates.leadTemperature = extractedData.leadTemperature;
      }
    }

    await ctx.db.patch(contactId, updates);
    return { success: true };
  },
});
```

Export all functions at module level.
  </action>
  <verify>
Run `npx convex dev --once` to validate new functions compile. Check no TypeScript errors.
  </verify>
  <done>
leads.ts exists with updateLeadStatus, addContactNote, and syncSarahData mutations. Status transitions are validated. Notes array is limited to 100.
  </done>
</task>

</tasks>

<verification>
1. `npx convex dev --once` completes without errors
2. Schema shows 16 new fields on contacts table
3. leads.ts exports 3 mutations
4. Status transition validation works (test: new -> contacted should fail)
</verification>

<success_criteria>
- Contacts schema extended with all Sarah fields
- Lead status enum with full workflow support
- Notes timeline array with append mutation
- Status transition validation prevents invalid moves
- All fields are optional (existing contacts unaffected)
</success_criteria>

<output>
After completion, create `.planning/phases/04-lead-database/04-01-SUMMARY.md`
</output>
