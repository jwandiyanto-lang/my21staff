---
phase: 04-lead-database
plan: 06
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - convex/backgroundSync.ts
  - convex/crons.ts
autonomous: true

must_haves:
  truths:
    - "Background sync runs periodically to catch missed webhooks"
    - "Stale contacts are identified and flagged for re-sync"
    - "Sync health can be monitored via query"
  artifacts:
    - path: "convex/backgroundSync.ts"
      provides: "Background sync reconciliation service"
      exports: ["reconcileContacts", "getSyncHealth"]
    - path: "convex/crons.ts"
      provides: "Scheduled cron job for background sync"
      contains: "backgroundSync"
  key_links:
    - from: "convex/crons.ts"
      to: "convex/backgroundSync.ts"
      via: "scheduler"
      pattern: "reconcileContacts"
---

<objective>
Create background sync service that periodically reconciles Convex data with Kapso to catch missed webhooks and ensure data freshness.

Purpose: Webhooks can fail silently. A background sync service ensures data integrity by periodically checking for stale contacts and flagging them for attention. This addresses LEAD-06 requirement.
Output: New backgroundSync.ts with reconciliation logic, crons.ts for scheduled execution.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-lead-database/04-CONTEXT.md
@convex/kapso.ts
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backgroundSync.ts with reconciliation logic</name>
  <files>convex/backgroundSync.ts</files>
  <action>
Create new file `convex/backgroundSync.ts` for background sync reconciliation.

```typescript
import { internalMutation, internalAction, query } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";

/**
 * Reconcile contacts - find and flag stale contacts
 *
 * A contact is considered stale if:
 * 1. lastActivityAt is older than staleThresholdMs (default 1 hour)
 * 2. Has an active conversation (not archived)
 *
 * This doesn't re-fetch from Kapso (expensive), but flags contacts
 * that may need attention for manual review or future Kapso API call.
 */
export const reconcileContacts = internalMutation({
  args: {
    workspaceId: v.id("workspaces"),
    staleThresholdMs: v.optional(v.number()), // Default 1 hour
  },
  handler: async (ctx, args) => {
    const { workspaceId, staleThresholdMs = 60 * 60 * 1000 } = args;
    const now = Date.now();
    const staleThreshold = now - staleThresholdMs;

    // Find contacts with active conversations that haven't been updated recently
    const contacts = await ctx.db
      .query("contacts")
      .withIndex("by_workspace", (q) => q.eq("workspace_id", workspaceId))
      .collect();

    const staleContacts = contacts.filter((c) => {
      // Skip archived/converted leads
      if (c.leadStatus === "archived" || c.leadStatus === "converted") {
        return false;
      }

      // Check if lastActivityAt is stale
      const lastActivity = c.lastActivityAt || c.updated_at || c.created_at;
      return lastActivity < staleThreshold;
    });

    // Flag stale contacts by adding a note
    let flaggedCount = 0;
    for (const contact of staleContacts.slice(0, 50)) { // Limit batch size
      const existingNotes = contact.notes || [];

      // Check if already flagged recently (within 24 hours)
      const recentFlag = existingNotes.find(
        (n: any) => n.addedBy === "background-sync" && n.addedAt > now - 24 * 60 * 60 * 1000
      );

      if (!recentFlag) {
        const notes = [
          ...existingNotes,
          {
            content: `Sync check: No activity for ${Math.round((now - (contact.lastActivityAt || contact.updated_at || 0)) / (60 * 60 * 1000))} hours`,
            addedBy: "background-sync",
            addedAt: now,
          },
        ];

        await ctx.db.patch(contact._id, { notes });
        flaggedCount++;
      }
    }

    // Log sync run
    await ctx.db.insert("syncHealth" as any, {
      workspace_id: workspaceId,
      run_at: now,
      contacts_checked: contacts.length,
      stale_found: staleContacts.length,
      flagged: flaggedCount,
    });

    console.log(`[BackgroundSync] Workspace ${workspaceId}: checked ${contacts.length}, found ${staleContacts.length} stale, flagged ${flaggedCount}`);

    return {
      checked: contacts.length,
      stale: staleContacts.length,
      flagged: flaggedCount,
    };
  },
});

/**
 * Run reconciliation for all active workspaces
 */
export const reconcileAllWorkspaces = internalMutation({
  args: {},
  handler: async (ctx) => {
    const workspaces = await ctx.db
      .query("workspaces")
      .collect();

    // Filter to workspaces with Kapso configured
    const activeWorkspaces = workspaces.filter(
      (w) => w.kapso_phone_id && w.meta_access_token
    );

    let totalChecked = 0;
    let totalStale = 0;
    let totalFlagged = 0;

    for (const workspace of activeWorkspaces) {
      try {
        const result = await reconcileContactsHandler(ctx, {
          workspaceId: workspace._id,
          staleThresholdMs: 60 * 60 * 1000, // 1 hour
        });
        totalChecked += result.checked;
        totalStale += result.stale;
        totalFlagged += result.flagged;
      } catch (error) {
        console.error(`[BackgroundSync] Failed for workspace ${workspace._id}:`, error);
      }
    }

    console.log(`[BackgroundSync] Complete: ${activeWorkspaces.length} workspaces, ${totalChecked} contacts, ${totalStale} stale, ${totalFlagged} flagged`);

    return {
      workspaces: activeWorkspaces.length,
      checked: totalChecked,
      stale: totalStale,
      flagged: totalFlagged,
    };
  },
});

// Helper to run reconciliation logic (used by both mutations)
async function reconcileContactsHandler(
  ctx: any,
  args: { workspaceId: any; staleThresholdMs: number }
) {
  const { workspaceId, staleThresholdMs } = args;
  const now = Date.now();
  const staleThreshold = now - staleThresholdMs;

  const contacts = await ctx.db
    .query("contacts")
    .withIndex("by_workspace", (q: any) => q.eq("workspace_id", workspaceId))
    .collect();

  const staleContacts = contacts.filter((c: any) => {
    if (c.leadStatus === "archived" || c.leadStatus === "converted") {
      return false;
    }
    const lastActivity = c.lastActivityAt || c.updated_at || c.created_at;
    return lastActivity < staleThreshold;
  });

  let flaggedCount = 0;
  for (const contact of staleContacts.slice(0, 50)) {
    const existingNotes = contact.notes || [];
    const recentFlag = existingNotes.find(
      (n: any) => n.addedBy === "background-sync" && n.addedAt > now - 24 * 60 * 60 * 1000
    );

    if (!recentFlag) {
      const notes = [
        ...existingNotes,
        {
          content: `Sync check: No activity for ${Math.round((now - (contact.lastActivityAt || contact.updated_at || 0)) / (60 * 60 * 1000))} hours`,
          addedBy: "background-sync",
          addedAt: now,
        },
      ];
      await ctx.db.patch(contact._id, { notes });
      flaggedCount++;
    }
  }

  await ctx.db.insert("syncHealth" as any, {
    workspace_id: workspaceId,
    run_at: now,
    contacts_checked: contacts.length,
    stale_found: staleContacts.length,
    flagged: flaggedCount,
  });

  return { checked: contacts.length, stale: staleContacts.length, flagged: flaggedCount };
}

/**
 * Get sync health statistics
 */
export const getSyncHealth = query({
  args: {
    workspaceId: v.optional(v.id("workspaces")),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit || 10;

    let query = ctx.db.query("syncHealth" as any);

    if (args.workspaceId) {
      query = query.filter((q) => q.eq(q.field("workspace_id"), args.workspaceId));
    }

    const runs = await query.order("desc").take(limit);

    return {
      runs,
      summary: runs.length > 0
        ? {
            lastRun: runs[0].run_at,
            avgStale: Math.round(runs.reduce((sum: number, r: any) => sum + r.stale_found, 0) / runs.length),
            totalFlagged: runs.reduce((sum: number, r: any) => sum + r.flagged, 0),
          }
        : null,
    };
  },
});
```

**Also add syncHealth table to schema.ts:**
```typescript
// In convex/schema.ts, add:
syncHealth: defineTable({
  workspace_id: v.id("workspaces"),
  run_at: v.number(),
  contacts_checked: v.number(),
  stale_found: v.number(),
  flagged: v.number(),
}).index("by_workspace", ["workspace_id"])
  .index("by_run_at", ["run_at"]),
```
  </action>
  <verify>
1. Run `npx convex dev --once` to validate new file compiles
2. Grep backgroundSync.ts for "reconcileContacts" - should find export
3. Grep backgroundSync.ts for "getSyncHealth" - should find export
4. Check schema.ts contains syncHealth table definition
  </verify>
  <done>
backgroundSync.ts created with reconcileContacts, reconcileAllWorkspaces, and getSyncHealth functions. Schema includes syncHealth table for tracking sync runs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create crons.ts for scheduled background sync</name>
  <files>convex/crons.ts</files>
  <action>
Create or update `convex/crons.ts` to schedule background sync.

```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Run background sync every hour to catch missed webhooks
// This identifies stale contacts that may have missed webhook updates
crons.interval(
  "background-sync",
  { hours: 1 },
  internal.backgroundSync.reconcileAllWorkspaces
);

export default crons;
```

If crons.ts already exists, add the new cron job to the existing file.

Key points:
1. Runs every hour (configurable)
2. Calls reconcileAllWorkspaces to check all active workspaces
3. Non-blocking - failure in one workspace doesn't stop others
  </action>
  <verify>
1. Check convex/crons.ts exists with backgroundSync reference
2. Run `npx convex dev --once` to validate cron configuration
3. Grep crons.ts for "background-sync" - should find cron name
  </verify>
  <done>
crons.ts created with hourly background sync job. Job calls reconcileAllWorkspaces to check all active workspaces.
  </done>
</task>

</tasks>

<verification>
1. `npx convex dev --once` completes without errors
2. backgroundSync.ts exports reconcileContacts, reconcileAllWorkspaces, getSyncHealth
3. crons.ts schedules hourly background sync
4. syncHealth table tracks sync run history
</verification>

<success_criteria>
- Background sync runs hourly via cron job
- Stale contacts (>1 hour no activity) are identified and flagged
- Sync health can be monitored via getSyncHealth query
- Flags don't duplicate (24-hour cooldown per contact)
- Failures are logged but don't stop other workspaces
</success_criteria>

<output>
After completion, create `.planning/phases/04-lead-database/04-06-SUMMARY.md`
</output>
