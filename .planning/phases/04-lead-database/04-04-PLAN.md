---
phase: 04-lead-database
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03"]
files_modified:
  - convex/leads.ts
autonomous: false

must_haves:
  truths:
    - "Dashboard can query leads by status"
    - "Dashboard can query leads needing follow-up"
    - "Lead list displays with Sarah-extracted data"
    - "End-to-end flow verified: Kapso message -> Sarah -> Contacts"
  artifacts:
    - path: "convex/leads.ts"
      provides: "Dashboard query functions"
      exports: ["getLeadsByStatus", "getLeadsNeedingFollowUp"]
  key_links:
    - from: "convex/leads.ts"
      to: "contacts table"
      via: "ctx.db.query"
      pattern: "by_workspace_status"
---

<objective>
Add dashboard query functions and verify end-to-end lead database sync from Kapso message to Sarah to Contacts.

Purpose: Enable the dashboard to query leads by status and activity, and verify the complete sync pipeline works.
Output: Query functions in leads.ts, verified end-to-end flow with checkpoint.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-lead-database/04-RESEARCH.md
@convex/leads.ts
@convex/sarah.ts
@convex/kapso.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dashboard query functions to leads.ts</name>
  <files>convex/leads.ts</files>
  <action>
Add query functions to leads.ts for dashboard use.

**Add imports if not present:**
```typescript
import { query } from "./_generated/server";
```

**Add these query functions:**

```typescript
/**
 * Get leads by status for dashboard filtering
 */
export const getLeadsByStatus = query({
  args: {
    workspaceId: v.id("workspaces"),
    status: v.optional(v.union(
      v.literal("new"),
      v.literal("qualified"),
      v.literal("contacted"),
      v.literal("converted"),
      v.literal("archived")
    )),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const { workspaceId, status, limit = 50 } = args;

    let query = ctx.db
      .query("contacts")
      .withIndex("by_workspace", (q) => q.eq("workspace_id", workspaceId));

    const contacts = await query.order("desc").take(limit);

    // Filter by status in memory (Convex doesn't support compound index filters well)
    const filtered = status
      ? contacts.filter((c) => c.leadStatus === status)
      : contacts;

    return filtered.map((c) => ({
      _id: c._id,
      phone: c.phone,
      name: c.name || c.kapso_name || "Unknown",
      leadStatus: c.leadStatus || "new",
      leadScore: c.leadScore || c.lead_score || 0,
      leadTemperature: c.leadTemperature || "cold",
      businessType: c.businessType,
      painPoints: c.painPoints,
      lastActivityAt: c.lastActivityAt || c.updated_at,
      lastContactAt: c.lastContactAt,
      created_at: c.created_at,
    }));
  },
});

/**
 * Get leads needing follow-up (no contact in X days, qualified status)
 */
export const getLeadsNeedingFollowUp = query({
  args: {
    workspaceId: v.id("workspaces"),
    daysSinceContact: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const { workspaceId, daysSinceContact = 7 } = args;
    const cutoffTime = Date.now() - daysSinceContact * 24 * 60 * 60 * 1000;

    const contacts = await ctx.db
      .query("contacts")
      .withIndex("by_workspace", (q) => q.eq("workspace_id", workspaceId))
      .collect();

    // Filter: qualified status AND (no lastContactAt OR lastContactAt < cutoff)
    const needFollowUp = contacts.filter((c) => {
      const isQualified = c.leadStatus === "qualified";
      const noRecentContact = !c.lastContactAt || c.lastContactAt < cutoffTime;
      return isQualified && noRecentContact;
    });

    // Sort by lead score (highest priority first)
    needFollowUp.sort((a, b) => (b.leadScore || 0) - (a.leadScore || 0));

    return needFollowUp.map((c) => ({
      _id: c._id,
      phone: c.phone,
      name: c.name || c.kapso_name || "Unknown",
      leadScore: c.leadScore || c.lead_score || 0,
      leadTemperature: c.leadTemperature || "cold",
      businessType: c.businessType,
      lastActivityAt: c.lastActivityAt || c.updated_at,
      lastContactAt: c.lastContactAt,
      daysSinceContact: c.lastContactAt
        ? Math.floor((Date.now() - c.lastContactAt) / (24 * 60 * 60 * 1000))
        : null,
    }));
  },
});

/**
 * Get lead statistics for dashboard
 */
export const getLeadStats = query({
  args: {
    workspaceId: v.id("workspaces"),
  },
  handler: async (ctx, args) => {
    const contacts = await ctx.db
      .query("contacts")
      .withIndex("by_workspace", (q) => q.eq("workspace_id", args.workspaceId))
      .collect();

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayMs = today.getTime();

    const thisWeekMs = todayMs - 7 * 24 * 60 * 60 * 1000;
    const thisMonthMs = todayMs - 30 * 24 * 60 * 60 * 1000;

    return {
      total: contacts.length,
      byStatus: {
        new: contacts.filter((c) => c.leadStatus === "new" || !c.leadStatus).length,
        qualified: contacts.filter((c) => c.leadStatus === "qualified").length,
        contacted: contacts.filter((c) => c.leadStatus === "contacted").length,
        converted: contacts.filter((c) => c.leadStatus === "converted").length,
        archived: contacts.filter((c) => c.leadStatus === "archived").length,
      },
      byTemperature: {
        hot: contacts.filter((c) => c.leadTemperature === "hot").length,
        warm: contacts.filter((c) => c.leadTemperature === "warm").length,
        cold: contacts.filter((c) => c.leadTemperature === "cold" || !c.leadTemperature).length,
      },
      newToday: contacts.filter((c) => c.created_at >= todayMs).length,
      newThisWeek: contacts.filter((c) => c.created_at >= thisWeekMs).length,
      newThisMonth: contacts.filter((c) => c.created_at >= thisMonthMs).length,
      avgScore: contacts.length > 0
        ? Math.round(contacts.reduce((sum, c) => sum + (c.leadScore || c.lead_score || 0), 0) / contacts.length)
        : 0,
    };
  },
});
```

These queries:
1. `getLeadsByStatus` - Filter leads by status for list view
2. `getLeadsNeedingFollowUp` - Prioritized list of leads needing attention
3. `getLeadStats` - Dashboard statistics (counts, temperatures, scores)
  </action>
  <verify>
Run `npx convex dev --once` to validate queries compile.
  </verify>
  <done>
leads.ts exports getLeadsByStatus, getLeadsNeedingFollowUp, and getLeadStats queries.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete lead database sync pipeline: Kapso webhook -> contact creation/update -> Sarah sync -> dashboard queries</what-built>
  <how-to-verify>
Test the end-to-end flow:

1. **Start Convex dev server:**
   ```bash
   cd /home/jfransisco/Desktop/21/my21staff
   npx convex dev
   ```

2. **Send a test WhatsApp message to +62 813-1859-025**
   - Send any message to trigger webhook
   - Wait 2-3 seconds for processing

3. **Check Convex Dashboard (https://dashboard.convex.dev):**
   - Go to your project -> Data -> contacts table
   - Find the contact by phone number
   - Verify these fields exist:
     - `lastActivityAt` is set (recent timestamp)
     - `leadStatus` is "new" or appropriate value

4. **Test Sarah sync (if Sarah is responding):**
   - Have a short conversation with Sarah
   - After Sarah responds, check contacts table again
   - Verify Sarah-extracted fields appear:
     - `leadScore` (if scoring occurred)
     - `leadTemperature` (if set)
     - `businessType` (if extracted)

5. **Test queries in Convex Dashboard:**
   - Go to Functions -> leads:getLeadStats
   - Run with your workspace ID
   - Should return statistics with total > 0

Expected results:
- Contact created/updated within 1 second of message
- Sarah data syncs to contact after conversation
- Dashboard queries return data without errors
  </how-to-verify>
  <resume-signal>Type "approved" if end-to-end flow works, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `npx convex dev --once` completes without errors
2. leads.ts exports 5 functions (3 queries + 2 mutations from Plan 01)
3. End-to-end flow verified via checkpoint
</verification>

<success_criteria>
- Dashboard query functions work correctly
- Kapso message creates/updates contact with timestamps
- Sarah data syncs to contacts table
- Lead statistics query returns accurate counts
</success_criteria>

<output>
After completion, create `.planning/phases/04-lead-database/04-04-SUMMARY.md`
</output>
