---
phase: 08-performance-optimization
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queries/use-conversations.ts
  - src/app/(dashboard)/[workspace]/inbox/page.tsx
  - src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx
  - src/app/(dashboard)/[workspace]/database/page.tsx
  - src/app/(dashboard)/[workspace]/database/database-client.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Returning to Inbox loads instantly from TanStack Query cache (no skeleton)"
    - "Returning to Database loads instantly from TanStack Query cache (no skeleton)"
    - "First load still shows skeleton while data fetches"
    - "Real-time updates still work for both pages"
  artifacts:
    - path: "src/lib/queries/use-conversations.ts"
      provides: "useConversations hook for client-side conversation fetching"
      exports: ["useConversations"]
    - path: "src/app/(dashboard)/[workspace]/inbox/page.tsx"
      provides: "Minimal server component passing workspace info"
    - path: "src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx"
      provides: "Client component fetching via TanStack Query"
    - path: "src/app/(dashboard)/[workspace]/database/page.tsx"
      provides: "Minimal server component passing workspace info"
    - path: "src/app/(dashboard)/[workspace]/database/database-client.tsx"
      provides: "Client component fetching via TanStack Query"
  key_links:
    - from: "inbox-client.tsx"
      to: "use-conversations.ts"
      via: "useConversations hook"
      pattern: "useConversations\\("
    - from: "database-client.tsx"
      to: "use-contacts.ts"
      via: "useContacts hook"
      pattern: "useContacts\\("
---

<objective>
Fix client-side caching for Inbox and Database pages so navigation returns instantly from TanStack Query cache instead of showing skeleton on every visit.

Purpose: Address UAT gaps 1 and 2 - "Returning to Inbox/Database loads instantly from cache (no skeleton)"

Output: Both pages use client-side TanStack Query for data fetching, enabling cache hits on navigation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-performance-optimization/08-UAT.md

Architecture context:
- TanStack Query provider already set up in src/app/providers.tsx
- useContacts hook already exists at src/lib/queries/use-contacts.ts (use as pattern)
- useMessages hook already exists at src/lib/queries/use-messages.ts
- loading.tsx files exist and show skeletons during server render
- The problem: Server components fetch data on EVERY navigation. loading.tsx shows during server render, BEFORE client mounts and can check TanStack Query cache.

Root cause from debug session:
- page.tsx is async server component that refetches on every navigation
- loading.tsx shows during server render BEFORE client can check TanStack Query cache
- Client-side hooks don't help if server component blocks first

Solution pattern:
- Server component becomes minimal shell (workspace lookup only)
- Client component fetches data via TanStack Query
- First visit: client shows skeleton while fetching (same UX as before)
- Return visit: TanStack Query cache hit, instant render (no skeleton)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useConversations hook</name>
  <files>src/lib/queries/use-conversations.ts</files>
  <action>
Create a new TanStack Query hook for conversations, following the pattern in use-contacts.ts:

```typescript
'use client'

import { useQuery, useQueryClient } from '@tanstack/react-query'
import { createClient } from '@/lib/supabase/client'
import { useEffect } from 'react'
import type { ConversationWithContact, WorkspaceMember, Profile } from '@/types/database'
import { isDevMode, MOCK_CONVERSATIONS } from '@/lib/mock-data'

export type TeamMember = WorkspaceMember & { profile: Profile | null }

interface ConversationsResponse {
  conversations: ConversationWithContact[]
  totalCount: number
  teamMembers: TeamMember[]
  quickReplies: Array<{id: string, label: string, text: string}>
  contactTags: string[]
}

const PAGE_SIZE = 50

export function useConversations(workspaceId: string, page: number = 0) {
  const queryClient = useQueryClient()

  const query = useQuery({
    queryKey: ['conversations', workspaceId, page],
    queryFn: async (): Promise<ConversationsResponse> => {
      if (isDevMode()) {
        return {
          conversations: MOCK_CONVERSATIONS,
          totalCount: MOCK_CONVERSATIONS.length,
          teamMembers: [],
          quickReplies: [],
          contactTags: ['Community', '1on1'],
        }
      }

      const response = await fetch(
        `/api/conversations?workspace=${workspaceId}&page=${page}&limit=${PAGE_SIZE}`
      )
      if (!response.ok) {
        throw new Error('Failed to load conversations')
      }
      return response.json()
    },
    staleTime: 60 * 1000, // 1 minute - same as default
    placeholderData: (previousData) => previousData, // Keep previous data while fetching
  })

  // Real-time subscription - update cache on conversation changes
  useEffect(() => {
    if (isDevMode() || !workspaceId) return

    const supabase = createClient()
    const channel = supabase
      .channel(`conversations-list:${workspaceId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'conversations',
          filter: `workspace_id=eq.${workspaceId}`,
        },
        () => {
          // Invalidate to refetch on changes
          queryClient.invalidateQueries({ queryKey: ['conversations', workspaceId] })
        }
      )
      .subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [workspaceId, queryClient])

  return query
}
```

Key design decisions:
- staleTime: 1 minute (matches provider default, conversations are reasonably fresh)
- placeholderData keeps old data visible during refetch (no flash)
- Real-time subscription invalidates cache (triggers refetch, not direct update)
- Returns all the data InboxClient needs (teamMembers, quickReplies, contactTags)
  </action>
  <verify>
- File exists at src/lib/queries/use-conversations.ts
- TypeScript compiles: `npx tsc --noEmit src/lib/queries/use-conversations.ts`
  </verify>
  <done>useConversations hook created with real-time subscription and proper typing</done>
</task>

<task type="auto">
  <name>Task 2: Migrate Inbox to client-side fetching</name>
  <files>
    src/app/(dashboard)/[workspace]/inbox/page.tsx
    src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx
  </files>
  <action>
**Step 1: Simplify page.tsx to minimal server component**

The server component should ONLY:
1. Validate workspace exists (for 404)
2. Pass workspace info to client

Remove ALL data fetching (conversations, members, settings). This prevents the server-side fetch that blocks navigation.

```typescript
import { notFound } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'
import { InboxClient } from './inbox-client'
import { isDevMode, MOCK_WORKSPACE } from '@/lib/mock-data'

interface InboxPageProps {
  params: Promise<{ workspace: string }>
}

export default async function InboxPage({ params }: InboxPageProps) {
  const { workspace: workspaceSlug } = await params

  // Dev mode: use mock workspace
  if (isDevMode()) {
    return (
      <InboxClient
        workspace={{
          id: MOCK_WORKSPACE.id,
          name: MOCK_WORKSPACE.name,
          slug: MOCK_WORKSPACE.slug,
        }}
      />
    )
  }

  // Production: validate workspace exists
  const supabase = await createClient()
  const { data: workspace, error } = await supabase
    .from('workspaces')
    .select('id, name, slug')
    .eq('slug', workspaceSlug)
    .single()

  if (error || !workspace) {
    notFound()
  }

  return <InboxClient workspace={workspace} />
}
```

**Step 2: Update InboxClient to fetch via TanStack Query**

Remove props that were server-fetched. Use useConversations hook instead.

Key changes to inbox-client.tsx:
1. Remove initialConversations, totalCount, quickReplies, teamMembers, contactTags from props
2. Keep only workspace prop
3. Add useConversations hook call
4. Handle loading state (show InboxSkeleton while loading)
5. Keep existing real-time subscription for unread updates (it updates local state)

Update the interface and component:

```typescript
interface InboxClientProps {
  workspace: Pick<Workspace, 'id' | 'name' | 'slug'>
}

export function InboxClient({ workspace }: InboxClientProps) {
  // TanStack Query for conversations with all related data
  const { data, isLoading: isLoadingConversations } = useConversations(workspace.id)

  // Extract data from query result
  const conversations = data?.conversations ?? []
  const totalCount = data?.totalCount ?? 0
  const quickReplies = data?.quickReplies ?? []
  const teamMembers = data?.teamMembers ?? []
  const contactTags = data?.contactTags ?? ['Community', '1on1']

  // Show skeleton while loading (first visit only - cached visits skip this)
  if (isLoadingConversations) {
    return <InboxSkeleton />
  }

  // ... rest of existing component logic
}
```

Import InboxSkeleton from '@/components/skeletons/inbox-skeleton'.

IMPORTANT: The existing useState for conversations should use the query data:
- Change: `const [conversationsState, setConversationsState] = useState<ConversationWithContact[]>(conversations)`
- The real-time subscription in the existing useEffect updates this local state for optimistic UI

Keep the existing real-time subscription logic for conversation updates (lines ~132-183) - it handles optimistic updates to unread counts and status. But initialize from query data, not props.
  </action>
  <verify>
- `npm run build` succeeds (no TypeScript errors)
- Visit Inbox, navigate away to Database, return to Inbox
- On return: No skeleton flash, instant load from cache
- New messages still appear in real-time
  </verify>
  <done>Inbox page uses client-side TanStack Query, returns from cache instantly</done>
</task>

<task type="auto">
  <name>Task 3: Migrate Database to client-side fetching</name>
  <files>
    src/app/(dashboard)/[workspace]/database/page.tsx
    src/app/(dashboard)/[workspace]/database/database-client.tsx
  </files>
  <action>
**Step 1: Simplify page.tsx to minimal server component**

Same pattern as Inbox - only validate workspace, pass to client.

```typescript
import { notFound } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'
import { DatabaseClient } from './database-client'
import { isDevMode, MOCK_WORKSPACE } from '@/lib/mock-data'

interface DatabasePageProps {
  params: Promise<{ workspace: string }>
}

export default async function DatabasePage({ params }: DatabasePageProps) {
  const { workspace: workspaceSlug } = await params

  // Dev mode: use mock workspace
  if (isDevMode()) {
    return (
      <DatabaseClient
        workspace={{
          id: MOCK_WORKSPACE.id,
          name: MOCK_WORKSPACE.name,
          slug: MOCK_WORKSPACE.slug,
        }}
      />
    )
  }

  // Production: validate workspace exists
  const supabase = await createClient()
  const { data: workspace, error } = await supabase
    .from('workspaces')
    .select('id, name, slug')
    .eq('slug', workspaceSlug)
    .single()

  if (error || !workspace) {
    notFound()
  }

  return <DatabaseClient workspace={workspace} />
}
```

**Step 2: Update DatabaseClient to fetch via TanStack Query**

The database-client.tsx already uses useContacts! The issue is it still receives initialContacts from server.

Key changes:
1. Remove contacts, totalCount, contactTags, teamMembers from props
2. Keep only workspace prop
3. Fetch contactTags and teamMembers via a new hook or API call
4. Handle loading state (show TableSkeleton while loading)

For contactTags and teamMembers, create a simple useWorkspaceSettings hook or fetch inline:

```typescript
interface DatabaseClientProps {
  workspace: Pick<Workspace, 'id' | 'name' | 'slug'>
}

export function DatabaseClient({ workspace }: DatabaseClientProps) {
  const [currentPage, setCurrentPage] = useState(1)

  // TanStack Query for contacts (already exists)
  const { data: contactsData, isLoading: isLoadingContacts, isFetching } = useContacts(workspace.id, currentPage)

  // TanStack Query for workspace settings (team members, tags)
  const { data: settingsData, isLoading: isLoadingSettings } = useWorkspaceSettings(workspace.id)

  const contacts = contactsData?.contacts ?? []
  const totalCount = contactsData?.total ?? 0
  const teamMembers = settingsData?.teamMembers ?? []
  const contactTags = settingsData?.contactTags ?? ['Community', '1on1']

  // Show skeleton only on initial load (not page transitions)
  if (isLoadingContacts && !contactsData) {
    return <TableSkeleton columns={7} rows={10} />
  }

  // ... rest of component
}
```

Create useWorkspaceSettings hook in src/lib/queries/use-workspace-settings.ts:

```typescript
'use client'

import { useQuery } from '@tanstack/react-query'
import { createClient } from '@/lib/supabase/client'
import type { WorkspaceMember, Profile } from '@/types/database'
import { isDevMode, MOCK_TEAM_MEMBERS } from '@/lib/mock-data'

export type TeamMember = WorkspaceMember & { profile: Profile | null }

interface WorkspaceSettingsResponse {
  teamMembers: TeamMember[]
  contactTags: string[]
}

export function useWorkspaceSettings(workspaceId: string) {
  return useQuery({
    queryKey: ['workspace-settings', workspaceId],
    queryFn: async (): Promise<WorkspaceSettingsResponse> => {
      if (isDevMode()) {
        return {
          teamMembers: MOCK_TEAM_MEMBERS,
          contactTags: ['Community', '1on1'],
        }
      }

      const supabase = createClient()

      // Fetch workspace settings
      const { data: workspace } = await supabase
        .from('workspaces')
        .select('settings')
        .eq('id', workspaceId)
        .single()

      // Fetch team members
      const { data: members } = await supabase
        .from('workspace_members')
        .select('*, profile:profiles(*)')
        .eq('workspace_id', workspaceId)

      // Get current user to ensure they're in list
      const { data: { user } } = await supabase.auth.getUser()

      let teamMembers = (members || []) as unknown as TeamMember[]

      if (user && !teamMembers.some(m => m.user_id === user.id)) {
        const { data: profile } = await supabase
          .from('profiles')
          .select('*')
          .eq('id', user.id)
          .single()

        if (profile) {
          teamMembers = [{
            id: `current-${user.id}`,
            workspace_id: workspaceId,
            user_id: user.id,
            role: 'owner',
            created_at: new Date().toISOString(),
            profile,
          } as TeamMember, ...teamMembers]
        }
      }

      const contactTags = (workspace?.settings as Record<string, unknown>)?.contact_tags as string[] || ['Community', '1on1']

      return { teamMembers, contactTags }
    },
    staleTime: 5 * 60 * 1000, // 5 minutes - settings change rarely
  })
}
```

Add file to files_modified list.
  </action>
  <verify>
- `npm run build` succeeds
- Visit Database, navigate to Inbox, return to Database
- On return: No skeleton flash, instant load from cache
- Pagination still works
- Filters still work
  </verify>
  <done>Database page uses client-side TanStack Query, returns from cache instantly</done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. Inbox caching test:
   - Visit Inbox (skeleton shows while loading)
   - Navigate to Database
   - Return to Inbox - should load instantly (no skeleton)
3. Database caching test:
   - Visit Database (skeleton shows while loading)
   - Navigate to Inbox
   - Return to Database - should load instantly (no skeleton)
4. Real-time still works:
   - Send WhatsApp message, appears in Inbox without refresh
5. No regressions:
   - Filters work in both pages
   - Pagination works in Database
   - Contact detail sheet works
   - Message thread loads correctly
</verification>

<success_criteria>
- Returning to Inbox from another page shows no skeleton (cache hit)
- Returning to Database from another page shows no skeleton (cache hit)
- First visit to each page still shows appropriate skeleton
- All existing functionality preserved (filters, pagination, real-time)
</success_criteria>

<output>
After completion, create `.planning/phases/08-performance-optimization/08-04-SUMMARY.md`
</output>
