---
phase: 08-performance-optimization
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx
  - src/app/(dashboard)/[workspace]/inbox/message-thread.tsx
  - src/app/(dashboard)/[workspace]/database/database-client.tsx
  - src/lib/queries/use-messages.ts
  - src/lib/queries/use-contacts.ts
autonomous: true

must_haves:
  truths:
    - "Inbox messages load with stale-while-revalidate (cached data shown instantly, fresh data fetched in background)"
    - "Database/leads pagination uses TanStack Query (no full page reload feel)"
    - "Real-time subscriptions integrate with query cache (new messages appear without refetch)"
  artifacts:
    - path: "src/lib/queries/use-messages.ts"
      provides: "Custom hook for messages with TanStack Query"
      exports: ["useMessages"]
    - path: "src/lib/queries/use-contacts.ts"
      provides: "Custom hook for contacts with TanStack Query"
      exports: ["useContacts"]
  key_links:
    - from: "src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx"
      to: "src/lib/queries/use-messages.ts"
      via: "import useMessages"
      pattern: "useMessages"
    - from: "src/app/(dashboard)/[workspace]/database/database-client.tsx"
      to: "src/lib/queries/use-contacts.ts"
      via: "import useContacts"
      pattern: "useContacts"
---

<objective>
Migrate core data-fetching pages (Inbox and Database) to TanStack Query for client-side caching and stale-while-revalidate behavior.

Purpose: These are the two most frequently used pages. Caching eliminates redundant fetches and makes navigation feel instant.
Output: useMessages and useContacts hooks, migrated inbox-client and database-client.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-performance-optimization/08-RESEARCH.md
@.planning/phases/08-performance-optimization/08-01-SUMMARY.md

Current inbox-client.tsx pattern:
- useState for messages array
- useEffect to fetch messages on conversation change
- Real-time subscription via Supabase channel
- Manual loading state management

Current database-client.tsx pattern:
- useState for contacts array
- fetch() call in goToPage callback
- Manual isLoadingPage state
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useMessages hook and migrate inbox message fetching</name>
  <files>
    - src/lib/queries/use-messages.ts
    - src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx
    - src/app/(dashboard)/[workspace]/inbox/message-thread.tsx
  </files>
  <action>
Create src/lib/queries/use-messages.ts:
```typescript
'use client'

import { useQuery, useQueryClient } from '@tanstack/react-query'
import { createClient } from '@/lib/supabase/client'
import { useEffect } from 'react'
import type { Message } from '@/types/database'
import { isDevMode, MOCK_MESSAGES } from '@/lib/mock-data'

export function useMessages(conversationId: string | null) {
  const queryClient = useQueryClient()

  const query = useQuery({
    queryKey: ['messages', conversationId],
    queryFn: async () => {
      if (!conversationId) return []

      if (isDevMode()) {
        const filtered = MOCK_MESSAGES.filter((m) => m.conversation_id === conversationId)
        filtered.sort((a, b) => new Date(a.created_at || 0).getTime() - new Date(b.created_at || 0).getTime())
        return filtered
      }

      const supabase = createClient()
      const { data } = await supabase
        .from('messages')
        .select('*')
        .eq('conversation_id', conversationId)
        .order('created_at', { ascending: true })
        .limit(100)
      return data || []
    },
    enabled: !!conversationId,
    staleTime: 10 * 1000, // 10 seconds - messages are critical real-time
  })

  // Real-time subscription - invalidate query on new messages
  useEffect(() => {
    if (isDevMode() || !conversationId) return

    const supabase = createClient()
    const channel = supabase
      .channel(`messages:${conversationId}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: `conversation_id=eq.${conversationId}`,
        },
        (payload) => {
          // Add new message to cache directly (optimistic-friendly)
          queryClient.setQueryData<Message[]>(['messages', conversationId], (old) => {
            if (!old) return [payload.new as Message]
            // Avoid duplicates
            if (old.some((m) => m.id === (payload.new as Message).id)) return old
            return [...old, payload.new as Message]
          })
        }
      )
      .subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [conversationId, queryClient])

  return query
}

// Helper to add optimistic message
export function useAddOptimisticMessage() {
  const queryClient = useQueryClient()

  return (conversationId: string, message: Message) => {
    queryClient.setQueryData<Message[]>(['messages', conversationId], (old) => {
      if (!old) return [message]
      return [...old, message]
    })
  }
}

// Helper to remove optimistic message on error
export function useRemoveOptimisticMessage() {
  const queryClient = useQueryClient()

  return (conversationId: string, messageId: string) => {
    queryClient.setQueryData<Message[]>(['messages', conversationId], (old) => {
      if (!old) return []
      return old.filter((m) => m.id !== messageId)
    })
  }
}
```

Update inbox-client.tsx:
- Remove useState for messages
- Remove useEffect for loading messages
- Remove useEffect for real-time subscription (now in hook)
- Import and use useMessages(selectedConversation?.id)
- Use query.data for messages, query.isLoading for isLoadingMessages
- Keep optimistic update handlers but use the new cache helpers

Update message-thread.tsx:
- Accept isLoading from parent (already does)
- No changes needed if it just renders messages prop
  </action>
  <verify>
- Select a conversation in inbox - messages load
- Switch conversations - messages update (with cache for previously viewed)
- Send a message - appears immediately (optimistic)
- Receive a message via real-time - appears without manual refresh
- No duplicate messages on real-time events
  </verify>
  <done>Inbox messages use TanStack Query with 10s stale time and real-time cache updates</done>
</task>

<task type="auto">
  <name>Task 2: Create useContacts hook and migrate database pagination</name>
  <files>
    - src/lib/queries/use-contacts.ts
    - src/app/(dashboard)/[workspace]/database/database-client.tsx
  </files>
  <action>
Create src/lib/queries/use-contacts.ts:
```typescript
'use client'

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import type { Contact } from '@/types/database'

const PAGE_SIZE = 25

interface ContactsResponse {
  contacts: Contact[]
  total: number
}

export function useContacts(workspaceId: string, page: number) {
  return useQuery({
    queryKey: ['contacts', workspaceId, page],
    queryFn: async (): Promise<ContactsResponse> => {
      const response = await fetch(
        `/api/contacts?workspace=${workspaceId}&page=${page}&limit=${PAGE_SIZE}`
      )
      if (!response.ok) {
        throw new Error('Failed to load contacts')
      }
      return response.json()
    },
    staleTime: 2 * 60 * 1000, // 2 minutes - leads change less frequently
    placeholderData: (previousData) => previousData, // Keep previous data while fetching new page
  })
}

// Mutation for updating contact (status, tags, assignee)
export function useUpdateContact(workspaceId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ contactId, updates }: { contactId: string; updates: Partial<Contact> }) => {
      const response = await fetch(`/api/contacts/${contactId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      })
      if (!response.ok) {
        throw new Error('Failed to update contact')
      }
      return response.json()
    },
    onMutate: async ({ contactId, updates }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['contacts', workspaceId] })

      // Snapshot previous values
      const previousQueries = queryClient.getQueriesData({ queryKey: ['contacts', workspaceId] })

      // Optimistically update all cached pages
      queryClient.setQueriesData({ queryKey: ['contacts', workspaceId] }, (old: ContactsResponse | undefined) => {
        if (!old) return old
        return {
          ...old,
          contacts: old.contacts.map((c) =>
            c.id === contactId ? { ...c, ...updates } : c
          ),
        }
      })

      return { previousQueries }
    },
    onError: (err, variables, context) => {
      // Rollback on error
      if (context?.previousQueries) {
        context.previousQueries.forEach(([queryKey, data]) => {
          queryClient.setQueryData(queryKey, data)
        })
      }
    },
  })
}
```

Update database-client.tsx:
- Import useContacts and useUpdateContact from '@/lib/queries/use-contacts'
- Replace useState for contacts with useContacts(workspace.id, currentPage)
- Use query.data?.contacts and query.data?.total
- Use query.isLoading or query.isFetching for loading states
- Replace handleStatusChange/handleAssigneeChange/handleTagsChange to use mutation
- Remove direct fetch() calls for pagination - TanStack Query handles it
- Keep filter state local (activeStatus, selectedTags, etc.) - these filter cached data

NOTE: Initial contacts from SSR can be used as initialData to avoid loading flash:
```typescript
const { data } = useContacts(workspace.id, currentPage)
// If SSR passes initialContacts, use useQuery with initialData option
```
  </action>
  <verify>
- Database page loads with contacts
- Pagination works (click page 2, data loads with loading indicator)
- Navigate away and back - cached data shows instantly
- Update contact status inline - changes optimistically, persists after refresh
- Error on update - reverts to previous state
  </verify>
  <done>Database/leads page uses TanStack Query with 2-minute stale time and optimistic updates</done>
</task>

</tasks>

<verification>
1. Inbox: Select conversation, see messages (from cache if previously viewed)
2. Inbox: Real-time message appears in thread without full refetch
3. Database: Navigate pages, see loading state, data loads
4. Database: Go back to page 1 - instant (cached)
5. Database: Update contact status - optimistic update works
6. No console errors about TanStack Query
</verification>

<success_criteria>
- Inbox messages: stale-while-revalidate with 10s stale time
- Database contacts: stale-while-revalidate with 2-min stale time
- Real-time subscriptions integrate with query cache
- Optimistic updates work for inline edits
- Navigation between pages feels snappier (cached data)
</success_criteria>

<output>
After completion, create `.planning/phases/08-performance-optimization/08-02-SUMMARY.md`
</output>
