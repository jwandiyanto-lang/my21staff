---
phase: 08-performance-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - next.config.ts
  - src/app/providers.tsx
  - src/app/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Bundle analyzer runs and produces visualization"
    - "Bundle analysis findings documented with dynamic import decision"
    - "TanStack Query provider wraps the app"
    - "QueryClient configured with sensible defaults"
  artifacts:
    - path: "next.config.ts"
      provides: "Bundle analyzer configuration"
      contains: "@next/bundle-analyzer"
    - path: "src/app/providers.tsx"
      provides: "Client-side providers including QueryClientProvider"
      exports: ["Providers"]
    - path: "src/app/layout.tsx"
      provides: "Root layout with Providers wrapper"
      contains: "Providers"
  key_links:
    - from: "src/app/layout.tsx"
      to: "src/app/providers.tsx"
      via: "import and render"
      pattern: "<Providers>"
---

<objective>
Set up performance optimization infrastructure: bundle analyzer for visibility and TanStack Query for client-side caching.

Purpose: Foundation for all subsequent optimization work. Bundle analyzer reveals targets; TanStack Query enables stale-while-revalidate patterns.
Output: Configured bundle analyzer, working QueryClientProvider in app root.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-performance-optimization/08-RESEARCH.md

Current state:
- No TanStack Query in package.json
- No bundle analyzer
- No client-side providers wrapper (Toaster rendered directly in layout)
- next.config.ts exists but is minimal
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and configure bundle analyzer</name>
  <files>
    - package.json
    - next.config.ts
  </files>
  <action>
Install @tanstack/react-query v5 and @next/bundle-analyzer:
```bash
npm install @tanstack/react-query @next/bundle-analyzer
```

Update next.config.ts to wrap with bundle analyzer:
```typescript
import type { NextConfig } from 'next'

const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})

const nextConfig: NextConfig = {
  // existing config...
}

export default withBundleAnalyzer(nextConfig)
```

Add analyze script to package.json:
```json
"analyze": "ANALYZE=true next build"
```

Run `npm run analyze` to generate initial bundle report (saved to .next/analyze/).
  </action>
  <verify>
- `npm run analyze` completes and opens browser with bundle visualization
- @tanstack/react-query appears in package.json dependencies
  </verify>
  <done>Bundle analyzer configured and produces visualization on `npm run analyze`</done>
</task>

<task type="checkpoint:review">
  <name>Task 2: Review bundle analysis and document findings</name>
  <files>
    - .planning/phases/08-performance-optimization/08-01-SUMMARY.md
  </files>
  <action>
Review the bundle analyzer visualization from Task 1. Document in the SUMMARY.md:

1. **Largest client-side chunks** - What's taking up space?
2. **Dynamic import candidates** - Components used only in modals/sheets/detail pages
3. **Unexpected large dependencies** - Third-party libs that seem oversized

**Decision point:**
- If significant optimization targets found (chunks > 50kb that could be lazy-loaded), create 08-04-PLAN.md for dynamic imports
- If bundle is already well-optimized, note "No significant dynamic import targets identified"

This addresses the ROADMAP scope item "Dynamic imports for heavy components" by letting analysis drive the decision rather than guessing what to optimize.
  </action>
  <verify>
- Bundle analysis findings documented in SUMMARY.md
- Clear decision: either 08-04-PLAN.md created OR "no significant targets" noted
  </verify>
  <done>Bundle analysis reviewed and optimization path determined</done>
</task>

<task type="auto">
  <name>Task 3: Create TanStack Query provider and wire to layout</name>
  <files>
    - src/app/providers.tsx
    - src/app/layout.tsx
  </files>
  <action>
Create src/app/providers.tsx as a 'use client' component:
```typescript
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useState } from 'react'

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // Stale time: how long data is considered fresh
            staleTime: 60 * 1000, // 1 minute default
            // Don't refetch on window focus for dashboard apps
            refetchOnWindowFocus: false,
            // Retry once on failure
            retry: 1,
          },
        },
      })
  )

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}
```

Update src/app/layout.tsx to wrap children with Providers:
- Import Providers from './providers'
- Wrap {children} with <Providers>{children}</Providers>
- Keep Toaster outside Providers (it's independent)

IMPORTANT: Use useState for QueryClient to prevent re-creation on every render.
  </action>
  <verify>
- App still loads without errors: `npm run dev` and visit http://localhost:3000
- No console errors about QueryClient
- React DevTools shows QueryClientProvider in component tree (optional verification)
  </verify>
  <done>TanStack Query provider wraps the entire app, QueryClient configured with dashboard-appropriate defaults</done>
</task>

</tasks>

<verification>
1. `npm run analyze` produces bundle visualization
2. App loads normally with no errors
3. QueryClientProvider present in component tree
4. No regressions in existing functionality
</verification>

<success_criteria>
- Bundle analyzer working (can run `npm run analyze`)
- Bundle analysis reviewed and dynamic import decision documented
- TanStack Query v5 installed and provider configured
- App renders without errors
- Foundation ready for useQuery migration in subsequent plans
</success_criteria>

<output>
After completion, create `.planning/phases/08-performance-optimization/08-01-SUMMARY.md`
</output>
