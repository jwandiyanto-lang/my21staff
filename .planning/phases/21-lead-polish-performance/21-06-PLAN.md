---
wave: 3
depends_on: [21-05]
files_modified: [src/components/contact/info-sidebar.tsx, src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx]
autonomous: true
---

# 21-06: Info Panel Extraction and Fix

## Objective

Extract the InfoSidebar into a reusable component and fix data sync issues between the sidebar and main list.

## Tasks

<task id="1">
Create `src/components/contact/info-sidebar.tsx`:

Extract the InfoSidebar function from inbox-client.tsx (lines 627-1274) into its own component file:

```typescript
'use client'

import { useState, useCallback, useMemo } from 'react'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Slider } from '@/components/ui/slider'
import { Checkbox } from '@/components/ui/checkbox'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Separator } from '@/components/ui/separator'
import {
  Phone,
  Mail,
  Calendar,
  MessageSquare,
  User,
  Edit2,
  Check,
  X,
  ExternalLink,
} from 'lucide-react'
import { LEAD_STATUS_CONFIG, LEAD_STATUSES, type LeadStatus } from '@/lib/lead-status'
import { formatWIB, DATE_FORMATS } from '@/lib/utils'
import { toast } from 'sonner'
import type { Contact, Profile, WorkspaceMember } from '@/types/database'

type TeamMember = WorkspaceMember & { profile: Profile | null }

interface ConversationWithContact {
  id: string
  contact_id: string
  status: string
  message_count: number
  last_message_at: string | null
  created_at: string
  contact: Contact | null
}

interface InfoSidebarProps {
  conversation: ConversationWithContact
  teamMembers: TeamMember[]
  contactTags: string[]
  onContactUpdate: (contactId: string, updates: Partial<Contact>) => void
  onClose?: () => void
}

export function InfoSidebar({
  conversation,
  teamMembers,
  contactTags,
  onContactUpdate,
  onClose,
}: InfoSidebarProps) {
  const contact = conversation.contact
  if (!contact) {
    return (
      <div className="p-4 text-center text-muted-foreground">
        No contact information
      </div>
    )
  }

  // Local edit state
  const [isEditingName, setIsEditingName] = useState(false)
  const [isEditingPhone, setIsEditingPhone] = useState(false)
  const [isEditingEmail, setIsEditingEmail] = useState(false)
  const [editName, setEditName] = useState(contact.name || '')
  const [editPhone, setEditPhone] = useState(contact.phone || '')
  const [editEmail, setEditEmail] = useState(contact.email || '')

  // Parse form responses from metadata
  const formResponses = useMemo(() => {
    if (!contact.metadata) return []
    try {
      const meta = typeof contact.metadata === 'string'
        ? JSON.parse(contact.metadata)
        : contact.metadata
      return Object.entries(meta)
        .filter(([key]) => !['id', 'created_at', 'updated_at'].includes(key))
        .map(([key, value]) => ({
          key: key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
          value: String(value)
        }))
    } catch {
      return []
    }
  }, [contact.metadata])

  // Handle field saves
  const handleSave = useCallback(async (field: 'name' | 'phone' | 'email', value: string) => {
    try {
      const response = await fetch(`/api/contacts/${contact.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ [field]: value }),
      })

      if (!response.ok) throw new Error('Failed to update')

      onContactUpdate(contact.id, { [field]: value })
      toast.success(`${field.charAt(0).toUpperCase() + field.slice(1)} updated`)
    } catch (error) {
      toast.error(`Failed to update ${field}`)
    }
  }, [contact.id, onContactUpdate])

  // Handle status change
  const handleStatusChange = useCallback(async (newStatus: LeadStatus) => {
    try {
      const response = await fetch(`/api/contacts/${contact.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ lead_status: newStatus }),
      })

      if (!response.ok) throw new Error('Failed to update')

      onContactUpdate(contact.id, { lead_status: newStatus })
    } catch (error) {
      toast.error('Failed to update status')
    }
  }, [contact.id, onContactUpdate])

  // Handle score change
  const handleScoreChange = useCallback(async (newScore: number) => {
    try {
      const response = await fetch(`/api/contacts/${contact.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ lead_score: newScore }),
      })

      if (!response.ok) throw new Error('Failed to update')

      onContactUpdate(contact.id, { lead_score: newScore })
    } catch (error) {
      toast.error('Failed to update score')
    }
  }, [contact.id, onContactUpdate])

  // Handle assignment change
  const handleAssignmentChange = useCallback(async (assigneeId: string | null) => {
    try {
      const response = await fetch(`/api/contacts/${contact.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ assigned_to: assigneeId }),
      })

      if (!response.ok) throw new Error('Failed to update')

      onContactUpdate(contact.id, { assigned_to: assigneeId })
      toast.success(assigneeId ? 'Contact assigned' : 'Contact unassigned')
    } catch (error) {
      toast.error('Failed to update assignment')
    }
  }, [contact.id, onContactUpdate])

  // Handle tag toggle
  const handleTagToggle = useCallback(async (tag: string) => {
    const currentTags = contact.tags || []
    const newTags = currentTags.includes(tag)
      ? currentTags.filter(t => t !== tag)
      : [...currentTags, tag]

    try {
      const response = await fetch(`/api/contacts/${contact.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tags: newTags }),
      })

      if (!response.ok) throw new Error('Failed to update')

      onContactUpdate(contact.id, { tags: newTags })
    } catch (error) {
      toast.error('Failed to update tags')
    }
  }, [contact.id, contact.tags, onContactUpdate])

  const assignedMember = teamMembers.find(m => m.user_id === contact.assigned_to)

  return (
    <ScrollArea className="h-full">
      <div className="p-4 space-y-6">
        {/* Contact Header */}
        <div className="text-center">
          <div className="w-16 h-16 rounded-full bg-primary/10 flex items-center justify-center mx-auto mb-3">
            <User className="h-8 w-8 text-primary" />
          </div>
          <h3 className="font-semibold text-lg">{contact.name || 'Unknown'}</h3>
          <p className="text-sm text-muted-foreground">{contact.phone}</p>
        </div>

        <Separator />

        {/* Contact Info Section */}
        <div className="space-y-4">
          <h4 className="font-medium text-sm text-muted-foreground">Contact Info</h4>

          {/* Name - Editable */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <User className="h-4 w-4 text-muted-foreground" />
              {isEditingName ? (
                <div className="flex items-center gap-1">
                  <Input
                    value={editName}
                    onChange={(e) => setEditName(e.target.value)}
                    className="h-7 text-sm"
                  />
                  <Button size="icon" variant="ghost" className="h-7 w-7" onClick={() => {
                    handleSave('name', editName)
                    setIsEditingName(false)
                  }}>
                    <Check className="h-3 w-3" />
                  </Button>
                  <Button size="icon" variant="ghost" className="h-7 w-7" onClick={() => setIsEditingName(false)}>
                    <X className="h-3 w-3" />
                  </Button>
                </div>
              ) : (
                <>
                  <span className="text-sm">{contact.name || '-'}</span>
                  <Button size="icon" variant="ghost" className="h-6 w-6" onClick={() => setIsEditingName(true)}>
                    <Edit2 className="h-3 w-3" />
                  </Button>
                </>
              )}
            </div>
          </div>

          {/* Phone - Editable */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Phone className="h-4 w-4 text-muted-foreground" />
              {isEditingPhone ? (
                <div className="flex items-center gap-1">
                  <Input
                    value={editPhone}
                    onChange={(e) => setEditPhone(e.target.value)}
                    className="h-7 text-sm"
                  />
                  <Button size="icon" variant="ghost" className="h-7 w-7" onClick={() => {
                    handleSave('phone', editPhone)
                    setIsEditingPhone(false)
                  }}>
                    <Check className="h-3 w-3" />
                  </Button>
                  <Button size="icon" variant="ghost" className="h-7 w-7" onClick={() => setIsEditingPhone(false)}>
                    <X className="h-3 w-3" />
                  </Button>
                </div>
              ) : (
                <>
                  <span className="text-sm">{contact.phone}</span>
                  <Button size="icon" variant="ghost" className="h-6 w-6" onClick={() => setIsEditingPhone(true)}>
                    <Edit2 className="h-3 w-3" />
                  </Button>
                </>
              )}
            </div>
          </div>

          {/* Email - Editable */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Mail className="h-4 w-4 text-muted-foreground" />
              {isEditingEmail ? (
                <div className="flex items-center gap-1">
                  <Input
                    value={editEmail}
                    onChange={(e) => setEditEmail(e.target.value)}
                    className="h-7 text-sm"
                  />
                  <Button size="icon" variant="ghost" className="h-7 w-7" onClick={() => {
                    handleSave('email', editEmail)
                    setIsEditingEmail(false)
                  }}>
                    <Check className="h-3 w-3" />
                  </Button>
                  <Button size="icon" variant="ghost" className="h-7 w-7" onClick={() => setIsEditingEmail(false)}>
                    <X className="h-3 w-3" />
                  </Button>
                </div>
              ) : (
                <>
                  <span className="text-sm">{contact.email || '-'}</span>
                  <Button size="icon" variant="ghost" className="h-6 w-6" onClick={() => setIsEditingEmail(true)}>
                    <Edit2 className="h-3 w-3" />
                  </Button>
                </>
              )}
            </div>
          </div>

          {/* Created Date */}
          <div className="flex items-center gap-2">
            <Calendar className="h-4 w-4 text-muted-foreground" />
            <span className="text-sm">{formatWIB(contact.created_at, DATE_FORMATS.DATE_LONG)}</span>
          </div>
        </div>

        <Separator />

        {/* Lead Status */}
        <div className="space-y-2">
          <Label className="text-sm text-muted-foreground">Lead Status</Label>
          <Select value={contact.lead_status} onValueChange={handleStatusChange}>
            <SelectTrigger>
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {LEAD_STATUSES.map((status) => {
                const config = LEAD_STATUS_CONFIG[status]
                return (
                  <SelectItem key={status} value={status}>
                    <div className="flex items-center gap-2">
                      <span
                        className="w-2 h-2 rounded-full"
                        style={{ backgroundColor: config.color }}
                      />
                      {config.label}
                    </div>
                  </SelectItem>
                )
              })}
            </SelectContent>
          </Select>
        </div>

        {/* Lead Score */}
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <Label className="text-sm text-muted-foreground">Lead Score</Label>
            <span className="text-sm font-medium">{contact.lead_score}</span>
          </div>
          <Slider
            value={[contact.lead_score]}
            max={100}
            step={5}
            onValueCommit={([value]) => handleScoreChange(value)}
          />
        </div>

        {/* Assignment */}
        <div className="space-y-2">
          <Label className="text-sm text-muted-foreground">Assigned To</Label>
          <Select
            value={contact.assigned_to || 'unassigned'}
            onValueChange={(value) => handleAssignmentChange(value === 'unassigned' ? null : value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Unassigned" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="unassigned">Unassigned</SelectItem>
              {teamMembers.map((member) => (
                <SelectItem key={member.user_id} value={member.user_id}>
                  {member.profile?.full_name || member.profile?.email || 'Unknown'}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>

        <Separator />

        {/* Tags */}
        <div className="space-y-2">
          <Label className="text-sm text-muted-foreground">Tags</Label>
          <div className="space-y-1">
            {contactTags.map((tag) => {
              const isSelected = contact.tags?.includes(tag) ?? false
              return (
                <div
                  key={tag}
                  className="flex items-center gap-2 px-2 py-1.5 rounded hover:bg-muted cursor-pointer"
                  onClick={() => handleTagToggle(tag)}
                >
                  <Checkbox checked={isSelected} />
                  <span className="text-sm">{tag}</span>
                </div>
              )
            })}
          </div>
        </div>

        {/* Form Responses */}
        {formResponses.length > 0 && (
          <>
            <Separator />
            <div className="space-y-2">
              <Label className="text-sm text-muted-foreground">Form Responses</Label>
              <div className="space-y-2">
                {formResponses.map(({ key, value }) => (
                  <div key={key} className="text-sm">
                    <span className="text-muted-foreground">{key}:</span>{' '}
                    <span>{value}</span>
                  </div>
                ))}
              </div>
            </div>
          </>
        )}

        {/* Conversation Stats */}
        <Separator />
        <div className="space-y-2">
          <Label className="text-sm text-muted-foreground">Conversation</Label>
          <div className="flex items-center gap-2 text-sm">
            <MessageSquare className="h-4 w-4 text-muted-foreground" />
            <span>{conversation.message_count} messages</span>
          </div>
          <div className="flex items-center gap-2">
            <Badge variant={conversation.status === 'active' ? 'default' : 'secondary'}>
              {conversation.status}
            </Badge>
          </div>
        </div>
      </div>
    </ScrollArea>
  )
}
```
</task>

<task id="2">
Update `src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx`:

Import the new component:
```typescript
import { InfoSidebar } from '@/components/contact/info-sidebar'
```

Remove the inline InfoSidebar function (lines 627-1274).

Add contact update handler:
```typescript
const handleContactUpdate = useCallback((contactId: string, updates: Partial<Contact>) => {
  setConversations((prev) =>
    prev.map((conv) =>
      conv.contact_id === contactId && conv.contact
        ? { ...conv, contact: { ...conv.contact, ...updates } }
        : conv
    )
  )
}, [])
```

Replace the inline InfoSidebar usage with:
```typescript
<InfoSidebar
  conversation={selectedConversation}
  teamMembers={teamMembers}
  contactTags={contactTags}
  onContactUpdate={handleContactUpdate}
/>
```
</task>

## Verification

- [ ] InfoSidebar extracted to `src/components/contact/info-sidebar.tsx`
- [ ] All inline editing (name, phone, email) works
- [ ] Status, score, assignment, tags updates work
- [ ] Changes sync back to conversation list immediately
- [ ] Form responses display correctly
- [ ] No console errors during interactions

## must_haves

- InfoSidebar as reusable component
- State sync between sidebar and list
- All existing functionality preserved
