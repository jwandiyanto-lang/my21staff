---
phase: 09-testing-polish
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/components/inbox/message-view.tsx
  - src/app/api/messages/send/route.ts
  - src/app/[workspace]/inbox/page.tsx
autonomous: false

must_haves:
  truths:
    - "User can send message from CRM inbox"
    - "Message appears in Kapso within 5 seconds"
    - "Reply from contact appears in CRM inbox"
    - "Conversation flows bidirectionally like native Kapso"
  artifacts:
    - path: "src/components/inbox/message-view.tsx"
      provides: "Message sending UI with Convex real-time"
    - path: "src/app/api/messages/send/route.ts"
      provides: "Send endpoint via Kapso API"
  key_links:
    - from: "MessageView component"
      to: "/api/messages/send"
      via: "fetch POST"
    - from: "/api/messages/send"
      to: "Kapso API"
      via: "kapsoSendMessage"
    - from: "Convex messages table"
      to: "MessageView"
      via: "useQuery(api.messages.listByConversation)"
---

<objective>
Test CRM inbox bidirectional messaging works like native Kapso.

Purpose: The CRM must function as the primary messaging interface, not just a message viewer.
Output: Verified inbox send/receive flow with any fixes applied.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/09-testing-polish/09-CONTEXT.md
@src/components/inbox/message-view.tsx
@src/app/api/messages/send/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Analyze current inbox send flow</name>
  <files>src/components/inbox/message-view.tsx, src/app/api/messages/send/route.ts</files>
  <action>
Review the current message sending implementation:

1. Read message-view.tsx handleSendMessage function
2. Read /api/messages/send route.ts
3. Identify the data flow:
   - What parameters does the API expect?
   - How does it authenticate?
   - How does it send to Kapso?
   - How does it store in Convex?

Check for potential issues:
- Is workspace_id being passed correctly?
- Is conversation_id using Convex ID format?
- Is the Kapso phone config being fetched?
- Is error handling complete?

Document any gaps found between the UI form submission and API expectations.

Known from reading:
- message-view.tsx sends FormData with 'to' (phone), 'body', 'file'
- API expects JSON with workspace_id, conversation_id, content
- This is a MISMATCH - needs fixing
  </action>
  <verify>Mismatch documented: UI sends FormData with 'to'/'body', API expects JSON with workspace_id/conversation_id/content</verify>
  <done>Current implementation analyzed, issues documented</done>
</task>

<task type="auto">
  <name>Task 2: Fix message-view.tsx to send correct payload</name>
  <files>src/components/inbox/message-view.tsx</files>
  <action>
Fix the handleSendMessage function to send the correct JSON payload:

Current (broken):
```typescript
const formData = new FormData();
formData.append('to', phoneNumber);
formData.append('body', messageInput);
await fetch('/api/messages/send', { method: 'POST', body: formData });
```

Required (fix):
```typescript
await fetch('/api/messages/send', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    workspace_id: workspaceId,  // Need to get this from context
    conversation_id: conversationId,
    content: messageInput.trim(),
    message_type: 'text',
  }),
});
```

Steps:
1. Add workspaceId prop to MessageView component Props type
2. Update handleSendMessage to send JSON with correct fields
3. Handle the response to check for errors
4. For file uploads, keep the current FormData approach but use a separate endpoint (/api/messages/send-media)

Note: The component already receives conversationId as a prop.
  </action>
  <verify>Component sends correct JSON payload structure</verify>
  <done>Message-view.tsx sends workspace_id, conversation_id, content correctly</done>
</task>

<task type="auto">
  <name>Task 3: Update inbox page to pass workspaceId</name>
  <files>src/app/[workspace]/inbox/page.tsx</files>
  <action>
Update the inbox page to pass workspaceId to MessageView:

1. Read the current inbox page structure
2. Find where MessageView is rendered
3. Add workspaceId prop from the workspace context

The workspace context should already be available from:
- Route params ([workspace] slug)
- Convex query to resolve slug to ID
- Or from Clerk organization context

Pass the workspace ID string to MessageView.
  </action>
  <verify>npm run lint passes, workspaceId flows to MessageView</verify>
  <done>Inbox page passes workspaceId to MessageView component</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Fixed inbox message sending to use correct API payload</what-built>
  <how-to-verify>
Test the inbox send flow in production:

1. Go to www.my21staff.com and sign in
2. Navigate to Inbox
3. Select the conversation from Plan 01 (the test with Sarah)
4. Type a reply message: "Thanks for the info. What services do you offer?"
5. Click Send

Observe:
- Does the message appear in the inbox? (yes/no)
- Does it show as "sent" status? (yes/no)
- Time for message to appear: ___ seconds

Then verify in Kapso:
- Use Kapso MCP to check if message arrived
- `mcp__kapso__whatsapp_get_conversation_context` with the conversation ID

If message failed:
- Check browser console for errors
- Check API response in Network tab
- Share error details

Target: Message latency under 5 seconds
  </how-to-verify>
  <resume-signal>Type "inbox-sending-works" if successful, or describe the error</resume-signal>
</task>

<task type="auto">
  <name>Task 4: Verify Convex real-time updates</name>
  <files></files>
  <action>
After user confirms sending works, verify the receive side:

1. User should have received a reply from Sarah or can send another test from their phone
2. Use Kapso MCP to check for any new inbound messages
3. Check if those messages appear in the CRM inbox automatically (Convex real-time)

The current implementation uses:
- `useQuery(api.messages.listByConversation)` for real-time updates
- This should auto-update when new messages are synced from Kapso

If messages don't appear:
- Check if the webhook is syncing messages to Convex
- Verify the Kapso -> Convex sync is running
- Check Convex function logs

Document:
- Real-time update working? (yes/no)
- Latency for new messages to appear: ___ seconds
- Any sync issues found
  </action>
  <verify>New messages appear in inbox via Convex real-time</verify>
  <done>Bidirectional messaging verified - send and receive both work</done>
</task>

</tasks>

<verification>
1. Message-view.tsx sends JSON with workspace_id, conversation_id, content
2. API receives and processes correctly
3. Messages appear in Kapso
4. Replies appear in CRM via Convex real-time
5. Latency under 5 seconds for both directions
</verification>

<success_criteria>
- CRM inbox functions as primary messaging interface
- Send message -> appears in Kapso within 5 seconds
- Receive message -> appears in CRM within 5 seconds
- No errors in console during normal flow
- Full conversation continuity maintained
</success_criteria>

<output>
After completion, create `.planning/phases/09-testing-polish/09-02-SUMMARY.md`
</output>
