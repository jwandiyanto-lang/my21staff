---
phase: 02-your-intern-debug
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/(dashboard)/[workspace]/knowledge-base/page.tsx
  - src/app/api/workspaces/[id]/ari-config/route.ts
  - src/app/api/workspaces/[id]/flow-stages/route.ts
  - src/app/api/workspaces/[id]/knowledge/route.ts
  - src/app/api/workspaces/[id]/scoring-config/route.ts
  - src/app/api/workspaces/[id]/slots/route.ts
autonomous: true

must_haves:
  truths:
    - "Your Intern page routes exist at /demo/knowledge-base"
    - "API routes return mock data in dev mode"
    - "Page loads without auth errors in dev mode"
  artifacts:
    - path: "src/app/(dashboard)/[workspace]/knowledge-base/page.tsx"
      provides: "Server component routing to KnowledgeBaseClient"
      contains: "shouldUseMockData"
    - path: "src/app/api/workspaces/[id]/ari-config/route.ts"
      provides: "ARI config endpoint with dev mode handling"
      contains: "isDevMode()"
  key_links:
    - from: "src/app/(dashboard)/[workspace]/knowledge-base/page.tsx"
      to: "src/app/(dashboard)/[workspace]/knowledge-base/knowledge-base-client.tsx"
      via: "imports KnowledgeBaseClient"
      pattern: "import.*KnowledgeBaseClient"
---

<objective>
Create page.tsx for Your Intern and add dev mode handling to all API routes.

Purpose: The Your Intern page components exist (KnowledgeBaseClient and tabs) but have no routing page.tsx, and the API routes fail in dev mode because they require Clerk auth which is unavailable. This plan creates the routing and makes APIs work offline.

Output: Working page at `/demo/knowledge-base` that loads without errors in dev mode.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@planning/PROJECT.md
@planning/ROADMAP.md
@planning/STATE.md

@src/app/(dashboard)/[workspace]/settings/page.tsx
@src/app/(dashboard)/[workspace]/knowledge-base/knowledge-base-client.tsx
@src/lib/mock-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create page.tsx for Your Intern</name>
  <files>src/app/(dashboard)/[workspace]/knowledge-base/page.tsx</files>
  <action>
Create a server component page.tsx following the pattern from settings/page.tsx:

1. Import dependencies:
   - notFound from next/navigation
   - fetchQuery from convex/nextjs
   - api from convex/_generated/api
   - KnowledgeBaseClient from ./knowledge-base-client
   - shouldUseMockData, MOCK_CONVEX_WORKSPACE, MOCK_TEAM_MEMBERS from @/lib/mock-data
   - Id type from convex/_generated/dataModel

2. Define interface for params: { workspace: string }

3. Export default async function KnowledgeBasePage:
   - Await params to get workspaceSlug
   - Check shouldUseMockData(workspaceSlug) first:
     - If true: return KnowledgeBaseClient with mock workspace data (id, name, slug) and mock team members
   - Production path:
     - fetchQuery workspace by slug
     - If not found: notFound()
     - Return KnowledgeBaseClient with real workspace data

4. KnowledgeBaseClient expects:
   - workspace: { id: string, name: string, slug: string }
   - teamMembers: Array<{ id: string, email: string, full_name: string }>

NOTE: Do NOT call any auth-protected queries (like api.ari.getAriConfig) in the server component. The client tabs handle their own data fetching via API routes.
  </action>
  <verify>File exists at src/app/(dashboard)/[workspace]/knowledge-base/page.tsx and contains shouldUseMockData check</verify>
  <done>Page component created with dev mode and production paths, no auth-protected queries in server component</done>
</task>

<task type="auto">
  <name>Task 2: Add dev mode handling to API routes</name>
  <files>
    src/app/api/workspaces/[id]/ari-config/route.ts
    src/app/api/workspaces/[id]/flow-stages/route.ts
    src/app/api/workspaces/[id]/knowledge/route.ts
    src/app/api/workspaces/[id]/scoring-config/route.ts
    src/app/api/workspaces/[id]/slots/route.ts
  </files>
  <action>
For EACH API route file listed, add dev mode handling at the START of each HTTP method handler (GET, POST, PUT, DELETE):

1. Add helper function at top of file if not present:
```typescript
function isDevMode(): boolean {
  return process.env.NEXT_PUBLIC_DEV_MODE === 'true'
}
```

2. In each handler, add dev mode check BEFORE calling requireWorkspaceMembership:
```typescript
const { id: workspaceId } = await params

// Dev mode: return mock data without auth
if (isDevMode() && workspaceId === 'demo') {
  return NextResponse.json({ /* mock response */ })
}

// Production: verify membership
const authResult = await requireWorkspaceMembership(workspaceId)
```

3. Mock responses per endpoint:

**ari-config GET:**
```typescript
return NextResponse.json({
  config: {
    workspace_id: 'demo',
    enabled: true,
    bot_name: 'ARI',
    tone: { description: '', greeting_template: '' },
    community_link: null,
  }
})
```

**flow-stages GET:**
```typescript
import { DEFAULT_FLOW_STAGES } from '@/lib/ari/types'
// Return default stages with mock IDs
const mockStages = DEFAULT_FLOW_STAGES.map((stage, index) => ({
  id: `mock-stage-${index}`,
  workspace_id: 'demo',
  ...stage,
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString(),
}))
return NextResponse.json({ stages: mockStages, isDefault: true })
```

**knowledge GET:**
```typescript
return NextResponse.json({ categories: [], entries: [] })
```

**scoring-config GET:**
```typescript
import { DEFAULT_SCORING_CONFIG } from '@/lib/ari/types'
return NextResponse.json({ config: DEFAULT_SCORING_CONFIG })
```

**slots GET:**
```typescript
return NextResponse.json({ slots: [] })
```

4. For mutation methods (POST, PUT, DELETE), return success response in dev mode:
```typescript
if (isDevMode() && workspaceId === 'demo') {
  return NextResponse.json({ success: true, message: 'Dev mode - no actual changes' })
}
```

The ari-config route already has isDevMode() for PATCH - extend pattern to GET/PUT.
  </action>
  <verify>
Run grep to confirm each file has isDevMode check:
```bash
grep -l "isDevMode()" src/app/api/workspaces/\[id\]/**/route.ts
```
Should list all 5 route files.
  </verify>
  <done>All 5 API routes have dev mode checks that return mock data when workspaceId === 'demo' and NEXT_PUBLIC_DEV_MODE=true</done>
</task>

<task type="auto">
  <name>Task 3: Verify page loads in dev mode</name>
  <files>N/A - verification task</files>
  <action>
Start dev server and test:

1. Run: npm run dev
2. Navigate to: http://localhost:3000/demo/knowledge-base
3. Expected behavior:
   - Page loads without JS errors in console
   - "Your Intern" header visible
   - 5 tabs visible (Persona, Flow, Database, Scoring, Slots)
   - Each tab shows loading spinner then content (or empty state for Database/Slots)
   - No "Unauthorized" or 401 errors in console/network tab

If errors occur:
- Check console for specific error
- Check Network tab for failed API calls
- The error message will indicate which component/API needs additional dev mode handling
  </action>
  <verify>
Page at /demo/knowledge-base loads with:
- No console errors
- No network 401/403 errors
- Tabs are clickable and show content
  </verify>
  <done>Your Intern page loads successfully in dev mode without auth errors</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run dev` starts without errors
2. Navigate to http://localhost:3000/demo/knowledge-base
3. Page renders with "Your Intern" header
4. All 5 tabs are visible and clickable
5. No console errors, no network auth failures
6. Clicking each tab shows its content (forms, empty states, loading spinners)
</verification>

<success_criteria>
- page.tsx exists and uses shouldUseMockData pattern
- All 5 API routes have dev mode handling
- /demo/knowledge-base loads without errors
- Tabs are functional (can switch between them)
</success_criteria>

<output>
After completion, create `.planning/phases/02-your-intern-debug/02-01-SUMMARY.md`
</output>
