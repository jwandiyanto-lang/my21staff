---
phase: 05-data-migration
plan: 04
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - convex/cms.ts
  - src/app/api/articles/route.ts
  - src/app/api/articles/[id]/route.ts
  - src/app/api/webinars/route.ts
  - src/app/api/webinars/[id]/route.ts
  - src/app/api/webinars/register/route.ts
  - src/app/(dashboard)/[workspace]/website/page.tsx
autonomous: true

must_haves:
  truths:
    - "Articles API reads from Convex instead of Supabase"
    - "Webinars API reads from Convex instead of Supabase"
    - "Webinar registration creates records in Convex"
    - "Website manager page displays data from Convex"
  artifacts:
    - path: "convex/cms.ts"
      provides: "Convex queries and mutations for CMS tables"
      exports: ["listArticles", "getArticle", "createArticle", "updateArticle", "deleteArticle", "listWebinars", "registerForWebinar"]
    - path: "src/app/api/articles/route.ts"
      provides: "Articles API using Convex"
      contains: "api\\.cms\\."
  key_links:
    - from: "src/app/api/articles/route.ts"
      to: "convex/cms.ts"
      via: "Convex client"
      pattern: "fetchQuery|fetchMutation"
---

<objective>
Update CMS API routes (articles, webinars) to use Convex instead of Supabase.

Purpose: Complete the API migration for content management system.
Output: All CMS API routes using Convex backend.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/05-data-migration/05-02-SUMMARY.md

Reference existing patterns:
@convex/contacts.ts
@src/app/api/articles/route.ts
@src/app/api/webinars/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CMS Convex queries and mutations</name>
  <files>convex/cms.ts</files>
  <action>
Create convex/cms.ts with queries and mutations for CMS tables:

**Articles:**
```typescript
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";

// List articles for workspace
export const listArticles = query({
  args: { workspaceId: v.id("workspaces") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("articles")
      .withIndex("by_workspace", (q) => q.eq("workspace_id", args.workspaceId))
      .order("desc")
      .collect();
  },
});

// Get article by ID
export const getArticle = query({
  args: { articleId: v.id("articles") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.articleId);
  },
});

// Get published article by workspace and slug (for public pages)
export const getPublishedArticle = query({
  args: { workspaceId: v.id("workspaces"), slug: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("articles")
      .withIndex("by_workspace_slug", (q) =>
        q.eq("workspace_id", args.workspaceId).eq("slug", args.slug)
      )
      .filter((q) => q.eq(q.field("status"), "published"))
      .first();
  },
});

// Create article
export const createArticle = mutation({
  args: {
    workspaceId: v.id("workspaces"),
    title: v.string(),
    slug: v.string(),
    excerpt: v.optional(v.string()),
    content: v.optional(v.string()),
    cover_image_url: v.optional(v.string()),
    status: v.string(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    return await ctx.db.insert("articles", {
      workspace_id: args.workspaceId,
      title: args.title,
      slug: args.slug,
      excerpt: args.excerpt,
      content: args.content,
      cover_image_url: args.cover_image_url,
      status: args.status,
      published_at: args.status === "published" ? now : undefined,
      created_at: now,
      updated_at: now,
    });
  },
});

// Update article
export const updateArticle = mutation({
  args: {
    articleId: v.id("articles"),
    title: v.optional(v.string()),
    slug: v.optional(v.string()),
    excerpt: v.optional(v.string()),
    content: v.optional(v.string()),
    cover_image_url: v.optional(v.string()),
    status: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const { articleId, ...updates } = args;
    const now = Date.now();

    // Set published_at if status changed to published
    const article = await ctx.db.get(articleId);
    if (updates.status === "published" && article?.status !== "published") {
      updates.published_at = now;
    }

    await ctx.db.patch(articleId, {
      ...updates,
      updated_at: now,
    });
    return articleId;
  },
});

// Delete article
export const deleteArticle = mutation({
  args: { articleId: v.id("articles") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.articleId);
  },
});
```

**Webinars** (similar pattern):
- listWebinars(workspaceId)
- getWebinar(webinarId)
- getPublishedWebinar(workspaceId, slug)
- createWebinar, updateWebinar, deleteWebinar

**Webinar Registrations:**
```typescript
// Register for webinar (public, no auth required)
export const registerForWebinar = mutation({
  args: {
    webinarId: v.id("webinars"),
    contactId: v.id("contacts"),
    workspaceId: v.id("workspaces"),
  },
  handler: async (ctx, args) => {
    // Check for existing registration
    const existing = await ctx.db
      .query("webinarRegistrations")
      .withIndex("by_webinar", (q) => q.eq("webinar_id", args.webinarId))
      .filter((q) => q.eq(q.field("contact_id"), args.contactId))
      .first();

    if (existing) return existing._id;

    return await ctx.db.insert("webinarRegistrations", {
      webinar_id: args.webinarId,
      contact_id: args.contactId,
      workspace_id: args.workspaceId,
      registered_at: Date.now(),
      attended: false,
    });
  },
});

// Get registrations for webinar
export const getWebinarRegistrations = query({
  args: { webinarId: v.id("webinars") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("webinarRegistrations")
      .withIndex("by_webinar", (q) => q.eq("webinar_id", args.webinarId))
      .collect();
  },
});
```
  </action>
  <verify>Run `npx convex dev` - all CMS functions compile without errors</verify>
  <done>Convex CMS module created with all queries and mutations</done>
</task>

<task type="auto">
  <name>Task 2: Update articles API routes</name>
  <files>
    src/app/api/articles/route.ts
    src/app/api/articles/[id]/route.ts
  </files>
  <action>
Update articles API routes to use Convex:

**articles/route.ts:**
1. Remove Supabase imports and client
2. Add Convex imports:
   ```typescript
   import { fetchQuery, fetchMutation } from '@/lib/convex/server';
   import { api } from '@/convex/_generated/api';
   ```
3. GET handler:
   - Get workspace by slug: `fetchQuery(api.workspaces.getBySlug, { slug: workspaceId })`
   - List articles: `fetchQuery(api.cms.listArticles, { workspaceId: workspace._id })`
4. POST handler:
   - Create article: `fetchMutation(api.cms.createArticle, { workspaceId: workspace._id, ...data })`
5. Keep auth checks and input validation
6. Remove dev mode mock data (no longer needed)

**articles/[id]/route.ts:**
1. Same Convex import pattern
2. GET: `fetchQuery(api.cms.getArticle, { articleId })`
3. PUT: `fetchMutation(api.cms.updateArticle, { articleId, ...updates })`
4. DELETE: `fetchMutation(api.cms.deleteArticle, { articleId })`

Note: Article IDs will now be Convex IDs (strings starting with 'j' or similar). Frontend may need to adapt, but API remains REST-like.
  </action>
  <verify>
Test with curl:
- GET /api/articles?workspace_id=eagle-overseas returns articles array
- POST /api/articles creates new article
  </verify>
  <done>Articles API routes using Convex</done>
</task>

<task type="auto">
  <name>Task 3: Update webinars API routes and registration</name>
  <files>
    src/app/api/webinars/route.ts
    src/app/api/webinars/[id]/route.ts
    src/app/api/webinars/register/route.ts
  </files>
  <action>
Update webinars API routes to use Convex:

**webinars/route.ts:**
1. Replace Supabase with Convex
2. GET: `fetchQuery(api.cms.listWebinars, { workspaceId })`
3. POST: `fetchMutation(api.cms.createWebinar, { ... })`

**webinars/[id]/route.ts:**
1. GET: `fetchQuery(api.cms.getWebinar, { webinarId })`
2. PUT: `fetchMutation(api.cms.updateWebinar, { webinarId, ...updates })`
3. DELETE: `fetchMutation(api.cms.deleteWebinar, { webinarId })`

**webinars/register/route.ts:**
This is a public endpoint (unauthenticated users register for webinars).
1. Parse request body (contact info, webinar slug)
2. Look up webinar by slug/workspace
3. Find or create contact by phone/email
4. Create registration: `fetchMutation(api.cms.registerForWebinar, { webinarId, contactId, workspaceId })`
5. Keep rate limiting if present
  </action>
  <verify>
Test with curl:
- GET /api/webinars?workspace_id=eagle-overseas returns webinars array
- POST /api/webinars/register with contact info creates registration
  </verify>
  <done>Webinars API routes using Convex</done>
</task>

</tasks>

<verification>
- [ ] `npx convex dev` shows CMS functions deployed
- [ ] Articles list API returns data from Convex
- [ ] Article CRUD operations work
- [ ] Webinars list API returns data from Convex
- [ ] Webinar registration creates record in Convex
- [ ] No Supabase imports in updated files
</verification>

<success_criteria>
CMS APIs migrated to Convex:
- Articles CRUD using Convex
- Webinars CRUD using Convex
- Webinar registration using Convex
- Public article/webinar pages still work
- Ready for final migration in next plan
</success_criteria>

<output>
After completion, create `.planning/phases/05-data-migration/05-04-SUMMARY.md`
</output>
