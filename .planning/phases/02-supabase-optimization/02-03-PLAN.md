---
phase: 02-supabase-optimization
plan: 03
type: execute
wave: 2
depends_on: [01]
files_modified: [src/app/api/conversations/route.ts]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "No select('*') wildcards exist in /api/conversations queries"
    - "Explicit column selection for conversations and nested contact/profile relations"
    - "Query count for /api/conversations reduced from 4 to 3 or fewer"
    - "Response time improved (measured via existing timing)"
  artifacts:
    - path: "src/app/api/conversations/route.ts"
      provides: "Optimized conversations API with explicit columns"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/conversations/route.ts"
      to: "conversations table"
      via: "explicit column selection (no wildcards)"
      pattern: "\.select\(`[^*]+`"
    - from: "src/app/api/conversations/route.ts"
      to: "supabase client"
      via: "parallel queries via Promise.all()"
      pattern: "Promise\.all\(\["
---

<objective>
Refactor /api/conversations to replace select('*') with explicit columns and parallelize independent queries.

Purpose: Currently uses select('*') wildcards in two places (conversations with contacts!inner(*), workspace_members with profiles(*)) and executes 4 sequential queries. Replacing wildcards with explicit columns reduces network overhead and enables index-only scans. Parallelizing independent queries reduces response time.
Output: Updated route.ts with explicit column selection and Promise.all() for parallel queries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-supabase-optimization/02-CONTEXT.md
@.planning/phases/02-supabase-optimization/02-RESEARCH.md
@src/app/api/conversations/route.ts
@src/lib/instrumentation/with-timing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace select('*') with explicit columns</name>
  <files>src/app/api/conversations/route.ts</files>
  <action>
Refactor src/app/api/conversations/route.ts to replace all select('*') with explicit column lists.

Current pattern (lines 43, 98):
```
.select('*, contact:contacts!inner(*)', { count: 'exact' })
...
.select('*, profile:profiles(*)')
```

Replace with explicit columns:

1. Main conversations query:
```
.select(`
  id,
  status,
  assigned_to,
  unread_count,
  last_message_at,
  last_message_preview,
  contact:contacts!inner(
    id,
    name,
    phone,
    lead_status,
    tags,
    assigned_to
  )
`, { count: 'exact' })
```

2. Team members query:
```
.select(`
  id,
  user_id,
  role,
  created_at,
  profile:profiles(
    id,
    email,
    full_name,
    avatar_url
  )
`)
```

Key points:
- Only select columns actually used by the frontend
- Preserve nested relation syntax with explicit columns
- Keep all filters, ordering, pagination logic unchanged
- Keep { count: 'exact' } on main query
- Preserve all existing functionality

For contact.tags and contact.lead_status filtering, the columns are included above.
  </action>
  <verify>src/app/api/conversations/route.ts has no select('*') patterns - all uses explicit column lists</verify>
  <done>All select('*') replaced with explicit column lists in conversations query</done>
</task>

<task type="auto">
  <name>Task 2: Refactor to Promise.all() for parallel queries</name>
  <files>src/app/api/conversations/route.ts</files>
  <action>
Refactor src/app/api/conversations/route.ts to use Promise.all() for queries 2, 3, 4 which are independent of each other.

Current pattern (sequential, lines 76-112):
```
const { data: conversations } = await query
const { count: activeCount } = await supabase.from('conversations')...
const { data: teamMembers } = await supabase.from('workspace_members')...
const { data: contactsWithTags } = await supabase.from('contacts')...
```

New pattern (parallel):
```
// Query 1: Main conversations query with contacts
let queryStart = performance.now()
const { data: conversations, error, count: totalCount } = await query
logQuery(metrics, 'conversations', Math.round(performance.now() - queryStart))

if (error) {
  console.error('Conversations query error:', error)
  return NextResponse.json({ error: error.message }, { status: 500 })
}

// Parallel queries 2, 3, 4 (independent)
const [activeCountResult, teamMembersResult, contactsWithTagsResult] = await Promise.all([
  supabase.from('conversations').select('*', { count: 'exact', head: true })
    .eq('workspace_id', workspaceId)
    .gt('unread_count', 0),
  supabase.from('workspace_members').select('id, user_id, role, created_at, profile:profiles(id, email, full_name, avatar_url)')
    .eq('workspace_id', workspaceId),
  supabase.from('contacts').select('tags')
    .eq('workspace_id', workspaceId)
    .not('tags', 'is', null)
])

// Extract results
const activeCount = activeCountResult.count
const teamMembers = teamMembersResult.data
const contactsWithTags = contactsWithTagsResult.data
```

Key points:
- Main conversations query remains sequential (builds the base query with filters)
- activeCount, teamMembers, contactsWithTags run in parallel (independent)
- Keep all existing timing instrumentation
- Note: activeCount query uses select('*') with head: true - this is acceptable as head: true means no rows returned, just count
- Preserve all existing functionality including tag flattening logic

Note on select('*') with head: true: When head: true is used, no actual data is fetched, only the count. The wildcard has no performance impact in this case.
  </action>
  <verify>src/app/api/conversations/route.ts uses Promise.all() for activeCount, teamMembers, contactsWithTags queries</verify>
  <done>Promise.all() pattern implemented for independent queries 2-4</done>
</task>

<task type="auto">
  <name>Task 3: Verify timing and query count</name>
  <files>src/app/api/conversations/route.ts</files>
  <action>
Test the refactored endpoint to verify instrumentation works correctly:

1. Run dev server: npm run dev
2. Make test request to endpoint with valid workspace_id
3. Check console output for timing logs:
   - [API] /api/conversations GET - Xms - 200
   - [Queries] /api/conversations - 4 queries: ...

Verify:
- Total response time is logged
- Query count shows 4 (main + 3 parallel)
- Individual query timings for each query are visible
- No errors in console
- Response includes all expected fields (conversations, totalCount, activeCount, teamMembers, contactTags)

Note: Performance improvement will be measured after deployment to preview/production where real latency is visible.
  </action>
  <verify>Console shows timing logs with 4 queries and no errors on test request; response includes all expected data</verify>
  <done>Timing instrumentation verified - endpoint logs query count and duration correctly</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. route.ts has no select('*') (except head: true count query where wildcard has no impact)
2. All nested relations use explicit column selection
3. Promise.all() used for activeCount, teamMembers, contactsWithTags queries
4. Main conversations query remains sequential (necessary for building query with filters)
5. Existing instrumentation (logQuery, logQuerySummary) still works
6. All existing functionality preserved (filters, ordering, pagination, tag flattening)
7. Test request returns correct response structure
</verification>

<success_criteria>
/api/conversations refactored with:
- No select('*') wildcards (except head: true count query)
- Explicit column selection for conversations and nested contact/profile relations
- Promise.all() for independent queries (activeCount, teamMembers, contactsWithTags)
- Query count remains 4 (main + 3 parallel)
- Instrumentation logs all query timings
- All existing functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/02-supabase-optimization/02-03-SUMMARY.md`
</output>
