---
phase: 02-supabase-optimization
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified: [src/app/api/contacts/by-phone/route.ts]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Queries 2-3-4 (notes, conversation, messages) execute in parallel via Promise.all()"
    - "Total response time for /api/contacts/by-phone reduced (measured via existing timing)"
    - "Query count remains 4 (sequential dependency on contact lookup is necessary)"
    - "Instrumentation logs show individual query timings and total"
  artifacts:
    - path: "src/app/api/contacts/by-phone/route.ts"
      provides: "Parallel query execution for contact lookup"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/contacts/by-phone/route.ts"
      to: "supabase client"
      via: "Promise.all() for parallel queries"
      pattern: "Promise\.all\(\["
    - from: "src/app/api/contacts/by-phone/route.ts"
      to: "with-timing.ts"
      via: "metrics logging for each query"
      pattern: "logQuery\(metrics"
---

<objective>
Refactor /api/contacts/by-phone to use parallel queries for dependent lookups.

Purpose: Currently executes 4 sequential queries. After contact lookup, queries for notes/conversation/messages are independent and can run in parallel. This reduces response time from (sum of all queries) to (contact query + max of parallel queries).
Output: Updated route.ts with Promise.all() for notes/conversation/messages queries after contact is found.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-supabase-optimization/02-CONTEXT.md
@.planning/phases/02-supabase-optimization/02-RESEARCH.md
@src/app/api/contacts/by-phone/route.ts
@src/lib/instrumentation/with-timing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor queries to Promise.all() pattern</name>
  <files>src/app/api/contacts/by-phone/route.ts</files>
  <action>
Refactor src/app/api/contacts/by-phone/route.ts to use Promise.all() for the three queries that run after contact lookup.

Current pattern (sequential):
```
const { data: contact } = await supabase.from('contacts')...
const { data: notes } = await supabase.from('contact_notes')...
const { data: conversation } = await supabase.from('conversations')...
const { data: messages } = await supabase.from('messages')...
```

New pattern (parallel after contact):
```
const { data: contact } = await supabase.from('contacts')...

if (!contact) {
  return NextResponse.json({ found: false, context: null })
}

// Parallel queries for notes, conversation, messages
const [notesResult, conversationResult, messagesResult] = await Promise.all([
  supabase.from('contact_notes').select(...).eq('contact_id', contact.id)...,
  supabase.from('conversations').select(...).eq('contact_id', contact.id).single(),
  supabase.from('conversations')
    .select('id')
    .eq('contact_id', contact.id)
    .single()
    .then(conv => {
      if (!conv?.id) return { data: null, error: null }
      return supabase.from('messages').select(...).eq('conversation_id', conv.id)...
    })
])

// Extract results
const notes = notesResult.data
const conversation = conversationResult.data
const messages = messagesResult?.data
```

Key points:
- Contact lookup remains sequential (must happen first to get contact.id)
- Notes and conversation can be parallelized (both only need contact.id)
- Messages depends on conversation.id, so it's chained in the Promise.all array
- Keep existing explicit column selection (already optimized)
- Keep existing timing instrumentation via logQuery() for each query
- Keep existing summarization logic

Preserve all existing functionality: error handling, null checks, summarization function.
  </action>
  <verify>src/app/api/contacts/by-phone/route.ts uses Promise.all() for dependent queries after contact lookup</verify>
  <done>Promise.all() pattern implemented for notes/conversation/messages queries</done>
</task>

<task type="auto">
  <name>Task 2: Verify timing and query count</name>
  <files>src/app/api/contacts/by-phone/route.ts</files>
  <action>
Test the refactored endpoint to verify instrumentation works correctly:

1. Run dev server: npm run dev
2. Make test request to endpoint with valid phone and workspace_id
3. Check console output for timing logs:
   - [API] /api/contacts/by-phone GET - Xms - 200
   - [Queries] /api/contacts/by-phone - 4 queries: ...

Verify:
- Total response time is logged
- Query count shows 4 (unchanged)
- Individual query timings for each query are visible
- No errors in console

Note: Performance improvement will be measured after deployment to preview/production where real latency is visible.
  </action>
  <verify>Console shows timing logs with 4 queries and no errors on test request</verify>
  <done>Timing instrumentation verified - endpoint logs query count and duration correctly</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. route.ts uses Promise.all() for parallel execution
2. Contact lookup remains sequential (necessary for contact.id)
3. Notes, conversation queries run in parallel after contact lookup
4. Messages query handles the conversation.id dependency properly
5. Existing instrumentation (logQuery, logQuerySummary) still works
6. All existing functionality preserved (error handling, summarization)
</verification>

<success_criteria>
/api/contacts/by-phone refactored to use Promise.all() for queries that can run in parallel.
Contact lookup remains sequential (necessary).
Notes and conversation run in parallel after contact found.
Messages query properly handles conversation.id dependency within Promise.all.
Instrumentation logs show 4 queries with individual timings.
</success_criteria>

<output>
After completion, create `.planning/phases/02-supabase-optimization/02-02-SUMMARY.md`
</output>
