---
phase: 02-supabase-optimization
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified: [src/app/api/contacts/by-phone/route.ts]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Queries 2-3-4 (notes, conversation, messages) execute in parallel via Promise.all()"
    - "Total response time for /api/contacts/by-phone reduced (measured via existing timing)"
    - "Contact lookup remains sequential (necessary to get contact.id first)"
    - "Messages query properly handles conversation.id dependency within parallel structure"
    - "Instrumentation logs show individual query timings and total"
  artifacts:
    - path: "src/app/api/contacts/by-phone/route.ts"
      provides: "Parallel query execution for contact lookup"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/contacts/by-phone/route.ts"
      to: "supabase client"
      via: "Promise.all() for parallel queries"
      pattern: "Promise\.all\(\["
    - from: "src/app/api/contacts/by-phone/route.ts"
      to: "with-timing.ts"
      via: "metrics logging for each query"
      pattern: "logQuery\(metrics"
---

<objective>
Refactor /api/contacts/by-phone to use parallel queries for dependent lookups.

Purpose: Currently executes 4 sequential queries. After contact lookup, queries for notes/conversation/messages are independent and can run in parallel. This reduces response time from (sum of all queries) to (contact query + max of parallel queries).

Note on nested relations (SUPA-06): True nested relations using Supabase's select() nesting are best for joining related tables in a single query (e.g., conversations -> contacts). For /api/contacts/by-phone, the data structure (notes as separate table with multiple rows, messages depending on conversation.id) makes Promise.all() the appropriate optimization pattern.

Output: Updated route.ts with Promise.all() for notes/conversation/messages queries after contact is found.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-supabase-optimization/02-CONTEXT.md
@.planning/phases/02-supabase-optimization/02-RESEARCH.md
@src/app/api/contacts/by-phone/route.ts
@src/lib/instrumentation/with-timing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor queries to Promise.all() pattern</name>
  <files>src/app/api/contacts/by-phone/route.ts</files>
  <action>
Refactor src/app/api/contacts/by-phone/route.ts to use Promise.all() for the three queries that run after contact lookup.

Current pattern (sequential):
```typescript
// Query 1: Contact (must happen first)
const { data: contact } = await supabase.from('contacts')...
logQuery(metrics, 'contacts', ...)

// Query 2: Notes (sequential, waits for contact)
const { data: notes } = await supabase.from('contact_notes')...
logQuery(metrics, 'contact_notes', ...)

// Query 3: Conversation (sequential, waits for notes)
const { data: conversation } = await supabase.from('conversations')...
logQuery(metrics, 'conversations', ...)

// Query 4: Messages (sequential, waits for conversation)
const { data: messages } = await supabase.from('messages')...
logQuery(metrics, 'messages', ...)
```

New pattern (parallel after contact):
```typescript
// Query 1: Contact lookup (must happen first to get contact.id)
const { data: contact, error: contactError } = await supabase
  .from('contacts')
  .select(`
    id,
    name,
    phone,
    email,
    lead_status,
    lead_score,
    tags,
    metadata,
    created_at
  `)
  .eq('workspace_id', workspaceId)
  .eq('phone', normalizedPhone)
  .single()

logQuery(metrics, 'contacts', Math.round(performance.now() - queryStart))

if (contactError || !contact) {
  return NextResponse.json({ found: false, context: null })
}

// Query 2-4: Notes, Conversation, Messages in parallel
const [notesResult, conversationResult, messagesRaw] = await Promise.all([
  // Notes query (needs contact.id)
  supabase
    .from('contact_notes')
    .select('content, created_at')
    .eq('contact_id', contact.id)
    .order('created_at', { ascending: false })
    .limit(5)
    .then(result => {
      logQuery(metrics, 'contact_notes', timing)
      return result
    }),

  // Conversation query (needs contact.id)
  supabase
    .from('conversations')
    .select('id, last_message_preview, last_message_at')
    .eq('contact_id', contact.id)
    .single()
    .then(result => {
      logQuery(metrics, 'conversations', timing)
      return result
    }),

  // Messages query (needs conversation.id - run in parallel with conversation lookup)
  // Note: We need the conversation.id first, so we chain this appropriately
  (async () => {
    const { data: conv } = await supabase
      .from('conversations')
      .select('id')
      .eq('contact_id', contact.id)
      .single()

    if (!conv?.id) {
      logQuery(metrics, 'messages', 0)
      return { data: null }
    }

    const start = performance.now()
    const result = await supabase
      .from('messages')
      .select('content, direction, created_at')
      .eq('conversation_id', conv.id)
      .order('created_at', { ascending: false })
      .limit(10)

    logQuery(metrics, 'messages', Math.round(performance.now() - start))
    return result
  })()
])

// Extract results
const notes = notesResult.data
const conversation = conversationResult.data
const messages = messagesRaw?.data || []
```

Alternative simpler approach (recommended for clarity):
```typescript
// Query 2-3: Notes and Conversation in parallel
const [notesResult, conversationResult] = await Promise.all([
  supabase
    .from('contact_notes')
    .select('content, created_at')
    .eq('contact_id', contact.id)
    .order('created_at', { ascending: false })
    .limit(5),
  supabase
    .from('conversations')
    .select('id, last_message_preview, last_message_at')
    .eq('contact_id', contact.id)
    .single()
])

// Log timings for parallel queries
logQuery(metrics, 'contact_notes', notesTiming)
logQuery(metrics, 'conversations', conversationTiming)

// Query 4: Messages (depends on conversation.id)
let recentMessages: { content: string; direction: string; created_at: string }[] = []
if (conversationResult.data) {
  queryStart = performance.now()
  const { data: messages } = await supabase
    .from('messages')
    .select('content, direction, created_at')
    .eq('conversation_id', conversationResult.data.id)
    .order('created_at', { ascending: false })
    .limit(10)
  logQuery(metrics, 'messages', Math.round(performance.now() - queryStart))

  recentMessages = (messages || [])
    .filter(m => m.content && m.created_at)
    .map(m => ({
      content: m.content!,
      direction: m.direction,
      created_at: m.created_at!,
    }))
}
```

Key points:
- Contact lookup remains sequential (must happen first to get contact.id)
- Notes and conversation can be parallelized (both only need contact.id)
- Messages depends on conversation.id, so it runs after conversation resolves
- Keep existing explicit column selection (already optimized)
- Keep existing timing instrumentation via logQuery() for each query
- Keep existing summarization logic

Preserve all existing functionality: error handling, null checks, summarization function.
  </action>
  <verify>src/app/api/contacts/by-phone/route.ts uses Promise.all() for at least notes and conversation queries (parallel after contact lookup)</verify>
  <done>Promise.all() pattern implemented for notes/conversation queries; messages query handles conversation.id dependency</done>
</task>

<task type="auto">
  <name>Task 2: Verify timing and query count</name>
  <files>src/app/api/contacts/by-phone/route.ts</files>
  <action>
Test the refactored endpoint to verify instrumentation works correctly:

1. Run dev server: npm run dev
2. Make test request to endpoint with valid phone and workspace_id
3. Check console output for timing logs:
   - [API] /api/contacts/by-phone GET - Xms - 200
   - [Queries] /api/contacts/by-phone - 4 queries: ...

Verify:
- Total response time is logged
- Query count shows 4 (unchanged)
- Individual query timings for each query are visible
- No errors in console

Note: Performance improvement will be measured after deployment to preview/production where real latency is visible.
  </action>
  <verify>Console shows timing logs with 4 queries and no errors on test request</verify>
  <done>Timing instrumentation verified - endpoint logs query count and duration correctly</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. route.ts uses Promise.all() for parallel execution of at least notes and conversation
2. Contact lookup remains sequential (necessary for contact.id)
3. Notes and conversation queries run in parallel after contact lookup
4. Messages query properly handles the conversation.id dependency
5. Existing instrumentation (logQuery, logQuerySummary) still works
6. All existing functionality preserved (error handling, summarization)
</verification>

<success_criteria>
/api/contacts/by-phone refactored to use Promise.all() for queries that can run in parallel.
Contact lookup remains sequential (necessary).
Notes and conversation run in parallel after contact found.
Messages query properly handles conversation.id dependency.
Instrumentation logs show 4 queries with individual timings.
</success_criteria>

<output>
After completion, create `.planning/phases/02-supabase-optimization/02-02-SUMMARY.md`
</output>
