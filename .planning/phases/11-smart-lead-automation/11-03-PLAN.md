---
phase: 11-smart-lead-automation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/database.ts
  - src/app/(dashboard)/[workspace]/database/contact-detail-sheet.tsx
  - src/app/(dashboard)/[workspace]/database/lead-panel.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "TypeScript compilation passes without errors"
    - "Dashboard shows lead activity timestamps for follow-up prioritization"
    - "LeadPanel renders with available contact data without crashes"
  artifacts:
    - path: "src/types/database.ts"
      provides: "Extended Contact type with optional Sarah fields"
      contains: "lastActivityAt"
    - path: "src/app/(dashboard)/[workspace]/database/contact-detail-sheet.tsx"
      provides: "Type-safe LeadPanel integration"
      min_lines: 1400
    - path: "src/app/(dashboard)/[workspace]/database/lead-panel.tsx"
      provides: "LeadPanel with flexible contact prop type"
      min_lines: 300
  key_links:
    - from: "contact-detail-sheet.tsx"
      to: "lead-panel.tsx"
      via: "LeadPanel component import"
      pattern: "LeadPanel"
---

<objective>
Fix TypeScript compilation errors in Phase 11 by extending the Contact type and creating a proper type-safe mapping between Supabase contacts and LeadPanel props.

Purpose: The backend implementation is complete (phone deduplication, lastActivityAt tracking, conversation linking), but the frontend cannot deploy due to TypeScript errors. This plan closes the gap by:
1. Extending the Supabase Contact type with optional Sarah-specific fields
2. Creating a safe mapping that only passes available fields to LeadPanel
3. Making LeadPanel gracefully handle missing fields

Output: TypeScript compilation passes, LeadPanel renders with available data, deployment unblocked.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-smart-lead-automation/11-CONTEXT.md
@.planning/phases/11-smart-lead-automation/11-VERIFICATION.md
@src/types/database.ts
@src/app/(dashboard)/[workspace]/database/contact-detail-sheet.tsx
@src/app/(dashboard)/[workspace]/database/lead-panel.tsx
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Contact type with optional Sarah fields</name>
  <files>src/types/database.ts</files>
  <action>
    Add an extended Contact type that includes all Sarah-specific fields as optional properties.

    At the end of the file (after the existing `Contact` type alias), add:

    ```typescript
    // Extended Contact type with optional Sarah/Convex fields
    // These fields exist in Convex but may not exist in Supabase rows
    export type ContactWithSarahFields = Contact & {
      // Sarah Phase 1 (Gathering) fields
      businessType?: string | null
      domisili?: string | null
      businessDuration?: string | null
      story?: string | null
      sarahLanguage?: string | null

      // Sarah Phase 2 (Interest) fields
      painPoints?: string[] | null
      interestMotivation?: string | null
      priority?: string | null
      urgencyLevel?: string | null

      // Sarah Phase 3 (Closing) fields
      leadScore?: number | null
      leadTemperature?: 'hot' | 'warm' | 'lukewarm' | 'cold' | null
      closingTechnique?: string | null
      objectionRaised?: string | null

      // Status workflow fields
      leadStatus?: 'new' | 'qualified' | 'contacted' | 'converted' | 'archived' | null
      statusChangedAt?: number | null
      statusChangedBy?: string | null

      // Timestamp fields (numbers for Convex compatibility)
      lastContactAt?: number | null
      lastActivityAt?: number | null

      // Source field
      source?: string | null
    }
    ```

    This creates a union type that extends the base Supabase Contact with optional fields that may come from Convex or other sources.
  </action>
  <verify>
    Run `npm run type-check 2>&1 | grep -c "error TS"` - should show fewer errors than before (or same, but later tasks will fix them).
    Also verify the type is exported: `grep -n "ContactWithSarahFields" src/types/database.ts`
  </verify>
  <done>
    ContactWithSarahFields type exported from src/types/database.ts with all Sarah-specific optional fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix contact-detail-sheet.tsx type mapping</name>
  <files>src/app/(dashboard)/[workspace]/database/contact-detail-sheet.tsx</files>
  <action>
    Update the contact-detail-sheet.tsx to:

    1. Import the new type:
       Change the import line from:
       ```typescript
       import type { Contact, ContactNote, Profile, WorkspaceMember } from '@/types/database'
       ```
       to:
       ```typescript
       import type { Contact, ContactWithSarahFields, ContactNote, Profile, WorkspaceMember } from '@/types/database'
       ```

    2. Update the ContactDetailSheetProps interface to accept ContactWithSarahFields:
       ```typescript
       interface ContactDetailSheetProps {
         contact: ContactWithSarahFields | null
         // ... rest unchanged
       }
       ```

    3. Fix the LeadPanel props (around line 901-925) to create a properly typed object:
       Replace the inline object creation with a helper that safely maps available fields:

       Before the return statement (around line 805), add:
       ```typescript
       // Helper to map contact to LeadPanel props with type safety
       const mapContactToLeadPanelProps = (c: ContactWithSarahFields) => ({
         _id: c.id as any, // String ID, LeadPanel expects Convex Id but uses it as string
         workspace_id: workspace.slug as any,
         name: c.name ?? undefined,
         phone: c.phone,
         phone_normalized: c.phone_normalized ?? undefined,
         email: c.email ?? undefined,
         lead_score: c.lead_score ?? 0,
         lead_status: c.lead_status ?? 'new',
         leadStatus: c.leadStatus ?? undefined,
         leadTemperature: c.leadTemperature ?? undefined,
         tags: c.tags ?? undefined,
         source: c.source ?? undefined,
         metadata: (c.metadata as Record<string, unknown>) ?? undefined,
         lastActivityAt: c.lastActivityAt ?? undefined,
         lastContactAt: c.lastContactAt ?? undefined,
         created_at: typeof c.created_at === 'string' ? new Date(c.created_at).getTime() : (c.created_at ?? Date.now()),
         updated_at: typeof c.updated_at === 'string' ? new Date(c.updated_at).getTime() : (c.updated_at ?? Date.now()),
         businessType: c.businessType ?? undefined,
         domisili: c.domisili ?? undefined,
         story: c.story ?? undefined,
         painPoints: c.painPoints ?? undefined,
         urgencyLevel: c.urgencyLevel ?? undefined,
       })
       ```

    4. Update the LeadPanel usage (around line 901) to use the mapper:
       ```tsx
       <LeadPanel
         contact={mapContactToLeadPanelProps(contact)}
         workspaceId={workspace.slug}
       />
       ```

    This approach:
    - Keeps type safety by explicitly mapping fields
    - Converts string dates to numbers where needed
    - Gracefully handles missing optional fields with undefined
    - Uses type assertions only where necessary (for Convex Id compatibility)
  </action>
  <verify>
    Run `npm run type-check 2>&1 | grep "contact-detail-sheet.tsx"` - should show no errors for this file.
  </verify>
  <done>
    contact-detail-sheet.tsx compiles without TypeScript errors, LeadPanel receives properly typed props.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update LeadPanel to accept flexible contact type</name>
  <files>src/app/(dashboard)/[workspace]/database/lead-panel.tsx</files>
  <action>
    Update the LeadPanel component to:

    1. Change the Contact interface to use more flexible types and make fields optional:

       ```typescript
       interface Contact {
         _id: string | { toString(): string } // Accept both string and Convex Id
         workspace_id: string | { toString(): string }
         name?: string | null
         phone: string
         phone_normalized?: string | null
         email?: string | null
         lead_score: number
         lead_status: string
         leadStatus?: string | null
         leadTemperature?: string | null
         tags?: string[] | null
         source?: string | null
         metadata?: Record<string, unknown> | null
         lastActivityAt?: number | null
         lastContactAt?: number | null
         created_at: number
         updated_at: number
         // Sarah fields
         businessType?: string | null
         domisili?: string | null
         story?: string | null
         painPoints?: string[] | null
         urgencyLevel?: string | null
       }
       ```

    2. Fix the updateContact mutation call to avoid type instantiation issues.
       Change line 61 from:
       ```typescript
       const updateContact = useMutation(api.mutations.updateContact)
       ```
       to use a type assertion that breaks the deep type chain:
       ```typescript
       // eslint-disable-next-line @typescript-eslint/no-explicit-any
       const updateContact = useMutation(api.mutations.updateContact) as any
       ```

    3. Update handleFieldSave to handle the any type:
       ```typescript
       const handleFieldSave = async (field: string, value: string) => {
         try {
           await updateContact({
             contact_id: String(contact._id), // Ensure string
             workspace_id: workspaceId,
             [field]: value || null,
           })
           toast.success('Saved')
         } catch (error) {
           toast.error('Failed to save')
           throw error
         }
       }
       ```

    WHY: The "type instantiation excessively deep" error occurs because Convex generates deeply nested generic types. Using `as any` for the mutation function type breaks this chain while preserving runtime behavior. This is a known pattern for Convex type issues.
  </action>
  <verify>
    Run `npm run type-check 2>&1 | grep "lead-panel.tsx"` - should show no errors.
    Run `npm run type-check 2>&1 | grep -c "error TS"` - should be significantly reduced or zero.
  </verify>
  <done>
    LeadPanel compiles without TypeScript errors, accepts flexible contact prop, handles missing optional fields gracefully.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript compilation passes:**
   ```bash
   npm run type-check
   ```
   Expected: Exit code 0, no errors (or only unrelated warnings)

2. **Build succeeds:**
   ```bash
   npm run build
   ```
   Expected: Build completes without errors

3. **Dev server runs:**
   ```bash
   npm run dev
   # Then visit http://localhost:3000/demo/database
   ```
   Expected: Database page loads, clicking a contact opens detail sheet with LeadPanel visible

4. **LeadPanel renders data:**
   - Contact Vitals section shows name, phone, email
   - Engagement Signals section shows lead status and score
   - Source Intelligence section shows source badge
   - No console errors about missing props
</verification>

<success_criteria>
- TypeScript compilation passes (`npm run type-check` exits 0)
- LeadPanel renders in contact detail sheet without runtime errors
- Available contact data (name, phone, lead_status, lead_score) displays correctly
- Optional fields (lastActivityAt, businessType, etc.) show when present, hide gracefully when absent
- No regression in existing contact-detail-sheet functionality
</success_criteria>

<output>
After completion, create `.planning/phases/11-smart-lead-automation/11-03-SUMMARY.md`
</output>
