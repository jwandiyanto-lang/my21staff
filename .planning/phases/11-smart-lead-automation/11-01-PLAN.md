---
phase: 11-smart-lead-automation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/mutations.ts
autonomous: true

must_haves:
  truths:
    - "New WhatsApp contact automatically creates lead in database"
    - "Existing contact messages update lastActivityAt (no duplicate leads)"
    - "Phone normalization prevents duplicates (+62813 = 0813)"
    - "Webhook retries don't create duplicate leads (idempotency via kapso_message_id in existing webhook code)"
    - "Leads are linked to Kapso conversations via kapso_conversation_id field"
  artifacts:
    - path: "convex/schema.ts"
      provides: "Index for phone_normalized lookup"
      contains: "by_workspace_phone_normalized"
    - path: "convex/mutations.ts"
      provides: "Fixed findOrCreateContactWebhook mutation with conversation linking"
      contains: "by_workspace_phone_normalized"
  key_links:
    - from: "src/app/api/webhook/kapso/route.ts"
      to: "convex/mutations.ts:findOrCreateContactWebhook"
      via: "convex.mutation call with phone_normalized and kapso_conversation_id"
      pattern: "findOrCreateContactWebhook"
    - from: "src/app/api/webhook/kapso/route.ts"
      to: "convex/mutations.ts:messageExistsByKapsoId"
      via: "kapso_message_id deduplication check (existing - provides webhook idempotency)"
      pattern: "messageExistsByKapsoId"
---

<objective>
Fix the phone number deduplication bug, add activity timestamp tracking, and link leads to Kapso conversations so that:
1. First message from new phone creates a lead linked to its Kapso conversation
2. Subsequent messages from same phone update existing lead (no duplicates)
3. lastActivityAt is updated on every inbound message for follow-up prioritization
4. Leads can be navigated to their Kapso inbox conversation

Purpose: This is the core lead automation requirement - automatic lead creation without duplicates, with conversation linking.
Output: Fixed Convex mutations that correctly deduplicate by normalized phone number and store conversation links.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-smart-lead-automation/11-CONTEXT.md
@.planning/phases/11-smart-lead-automation/11-RESEARCH.md
@convex/schema.ts
@convex/mutations.ts
@src/lib/phone/normalize.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add phone_normalized index to contacts table</name>
  <files>convex/schema.ts</files>
  <action>
Add a new index to the contacts table definition for querying by workspace_id and phone_normalized.

In the contacts table (around line 106-110), add this index after the existing "by_workspace_phone" index:

```typescript
.index("by_workspace_phone_normalized", ["workspace_id", "phone_normalized"])
```

This enables efficient lookup by normalized phone number, which is critical for deduplication.

The existing "by_workspace_phone" index queries by raw phone, which causes duplicates when the same number arrives in different formats (0813, 62813, +62813).
  </action>
  <verify>
Run `npx convex dev --once` to validate schema. Should show index being created.
Check that the index appears in the schema definition.
  </verify>
  <done>
contacts table has "by_workspace_phone_normalized" index defined in schema.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix findOrCreateContactWebhook to use normalized phone lookup and link conversations</name>
  <files>convex/mutations.ts</files>
  <action>
Update the findOrCreateContactWebhook mutation (around line 1770-1824) to:

1. Accept optional kapso_conversation_id argument for linking leads to conversations
2. Query by phone_normalized field instead of phone field
3. Update lastActivityAt on every inbound message (both new and existing contacts)
4. Store kapso_conversation_id when creating new contacts
5. Update kapso_conversation_id for existing contacts if not already set
6. Only update kapso_name if contact.name is empty (preserve manual CRM edits)

**Current args (missing conversation linking):**
```typescript
args: {
  workspace_id: v.string(),
  phone: v.string(),
  phone_normalized: v.string(),
  kapso_name: v.optional(v.string()),
},
```

**Fixed args (with conversation linking):**
```typescript
args: {
  workspace_id: v.string(),
  phone: v.string(),
  phone_normalized: v.string(),
  kapso_name: v.optional(v.string()),
  kapso_conversation_id: v.optional(v.string()), // Links lead to Kapso conversation
},
```

**Current code (WRONG - queries by raw phone):**
```typescript
const existing = await ctx.db
  .query("contacts")
  .withIndex("by_workspace_phone", (q) =>
    q.eq("workspace_id", args.workspace_id as any).eq("phone", args.phone)
  )
  .first();
```

**Fixed code (queries by normalized phone):**
```typescript
const existing = await ctx.db
  .query("contacts")
  .withIndex("by_workspace_phone_normalized", (q) =>
    q.eq("workspace_id", args.workspace_id as any).eq("phone_normalized", args.phone_normalized)
  )
  .first();
```

Full replacement for the mutation handler:

```typescript
handler: async (ctx, args) => {
  // Query by normalized phone to prevent duplicates
  const existing = await ctx.db
    .query("contacts")
    .withIndex("by_workspace_phone_normalized", (q) =>
      q.eq("workspace_id", args.workspace_id as any).eq("phone_normalized", args.phone_normalized)
    )
    .first();

  const now = Date.now();

  if (existing) {
    // Always update activity timestamp + cache
    // Only update kapso_name if we have new data
    // Only update name if not manually set (preserve CRM edits)
    // Link to conversation if not already linked
    await ctx.db.patch(existing._id, {
      lastActivityAt: now,
      cache_updated_at: now,
      updated_at: now,
      ...(args.kapso_name && args.kapso_name !== existing.kapso_name
        ? {
            kapso_name: args.kapso_name,
            // Only overwrite name if empty (preserve manual edits)
            ...(existing.name ? {} : { name: args.kapso_name }),
          }
        : {}),
      // Link to Kapso conversation if provided and not already set
      ...(args.kapso_conversation_id && !existing.kapso_conversation_id
        ? { kapso_conversation_id: args.kapso_conversation_id }
        : {}),
    });
    return await ctx.db.get(existing._id);
  }

  // Create new contact with conversation link
  const contactId = await ctx.db.insert("contacts", {
    workspace_id: args.workspace_id as any,
    phone: args.phone,
    phone_normalized: args.phone_normalized,
    name: args.kapso_name,
    kapso_name: args.kapso_name,
    lead_score: 0,
    lead_status: "new",
    tags: [],
    source: "whatsapp",
    metadata: {},
    cache_updated_at: now,
    lastActivityAt: now,
    created_at: now,
    updated_at: now,
    supabaseId: "",
    // Link to Kapso conversation if provided
    ...(args.kapso_conversation_id ? { kapso_conversation_id: args.kapso_conversation_id } : {}),
  });

  return await ctx.db.get(contactId);
},
```

NOTE: The webhook route (src/app/api/webhook/kapso/route.ts) will need to pass kapso_conversation_id when calling this mutation. This is handled in the webhook code which already has access to the conversation_id.
  </action>
  <verify>
1. Run `npx convex dev --once` to deploy mutation
2. Check TypeScript compiles without errors: `npm run typecheck`
3. Verify the mutation uses "by_workspace_phone_normalized" index
4. Verify lastActivityAt is set on both existing and new contacts
5. Verify kapso_conversation_id is accepted as an argument
  </verify>
  <done>
findOrCreateContactWebhook queries by phone_normalized, updates lastActivityAt, and links to Kapso conversations
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify deduplication and conversation linking</name>
  <files>N/A - testing</files>
  <action>
Verify the code changes are correct by checking:

1. Check current contacts in the database schema:
```bash
npx convex dev --once  # Verify schema deploys
```

2. Code verification checklist - read the updated files and confirm:
   - schema.ts has "by_workspace_phone_normalized" index
   - mutations.ts findOrCreateContactWebhook uses that index
   - mutations.ts sets lastActivityAt in both code paths
   - mutations.ts accepts kapso_conversation_id argument
   - mutations.ts stores kapso_conversation_id on new contacts
   - mutations.ts updates kapso_conversation_id on existing contacts (if not set)

3. Idempotency verification (existing functionality):
   - The webhook already has idempotency via `kapso_message_id` check (lines 255-264 in webhook/kapso/route.ts)
   - This prevents duplicate leads from webhook retries because duplicate messages are filtered BEFORE findOrCreateContactWebhook is called
   - Phone normalization adds a second layer of protection at the database level

The real end-to-end test will happen when a WhatsApp message arrives via webhook.
  </action>
  <verify>
Code review confirms:
- [ ] Index "by_workspace_phone_normalized" in schema.ts
- [ ] findOrCreateContactWebhook uses that index for lookup
- [ ] lastActivityAt set for existing contacts (in patch)
- [ ] lastActivityAt set for new contacts (in insert)
- [ ] kapso_conversation_id accepted as optional argument
- [ ] kapso_conversation_id stored on contact creation
- [ ] Existing webhook idempotency (kapso_message_id) provides retry protection
  </verify>
  <done>
Code changes verified - deduplication fix is in place, activity tracking enabled, conversation linking ready
  </done>
</task>

</tasks>

<verification>
Run these commands to verify the backend changes:

```bash
# 1. Type check passes
npm run typecheck

# 2. Convex schema deploys successfully
npx convex dev --once

# 3. Verify the index exists (search schema.ts)
grep -n "by_workspace_phone_normalized" convex/schema.ts

# 4. Verify mutation uses the index
grep -n "by_workspace_phone_normalized" convex/mutations.ts

# 5. Verify lastActivityAt is set
grep -n "lastActivityAt" convex/mutations.ts | head -20

# 6. Verify kapso_conversation_id is in mutation args
grep -n "kapso_conversation_id" convex/mutations.ts | head -10

# 7. Verify existing idempotency check (this already works)
grep -n "messageExistsByKapsoId" src/app/api/webhook/kapso/route.ts
```
</verification>

<success_criteria>
1. Schema has by_workspace_phone_normalized index
2. findOrCreateContactWebhook queries by phone_normalized (not raw phone)
3. lastActivityAt updated on every inbound message (existing contacts)
4. lastActivityAt set on contact creation (new contacts)
5. kapso_conversation_id accepted and stored (links leads to conversations)
6. All TypeScript compiles without errors
7. Convex schema deploys successfully
8. Webhook idempotency verified (kapso_message_id check exists)
</success_criteria>

<output>
After completion, create `.planning/phases/11-smart-lead-automation/11-01-SUMMARY.md`
</output>
