---
phase: 02-inbox
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/components/inbox/compose-input.tsx
  - src/app/api/messages/send/route.ts
  - src/components/inbox/message-thread.tsx
autonomous: true

must_haves:
  truths:
    - "User can type a message in the compose input"
    - "Enter sends message, Shift+Enter adds new line"
    - "Sent message appears in thread immediately"
    - "Message is delivered via Kapso API"
    - "Message persists in Convex database"
  artifacts:
    - path: "src/components/inbox/compose-input.tsx"
      provides: "Message composition input with send"
      exports: ["ComposeInput"]
    - path: "src/app/api/messages/send/route.ts"
      provides: "API route that calls Kapso and stores message"
      exports: ["POST"]
  key_links:
    - from: "src/components/inbox/compose-input.tsx"
      to: "/api/messages/send"
      via: "fetch POST request"
      pattern: "fetch.*api/messages/send"
    - from: "src/app/api/messages/send/route.ts"
      to: "src/lib/kapso/client.ts"
      via: "sendMessage function"
      pattern: "sendMessage.*credentials"
    - from: "src/app/api/messages/send/route.ts"
      to: "convex/mutations.ts"
      via: "fetchMutation createOutboundMessage"
      pattern: "fetchMutation.*createOutboundMessage"
---

<objective>
Implement the message send functionality with compose input and Kapso API integration.

Purpose: Users need to send messages to contacts via WhatsApp. This completes the core inbox functionality.
Output: Working compose input that sends messages via Kapso and stores in Convex.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-inbox/02-CONTEXT.md
@.planning/phases/02-inbox/02-RESEARCH.md

# Existing infrastructure
@src/lib/kapso/client.ts
@convex/mutations.ts
@src/app/api/messages/send/route.ts
@convex/workspaces.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create compose input component</name>
  <files>
    src/components/inbox/compose-input.tsx
  </files>
  <action>
Create the message composition input with auto-expand:

1. Install dependency:
```bash
npm install react-textarea-autosize
```

2. `compose-input.tsx`:
   - Accept props: onSend (callback), disabled, workspaceId, conversationId
   - Use react-textarea-autosize for auto-expanding input
   - Enter sends message, Shift+Enter for new line (per CONTEXT.md)
   - Disable send button when input is empty or while sending
   - Show loading state during send
   - Clear input after successful send
   - Placeholder: "Ketik pesan..."

Implementation:
```tsx
'use client'

import { useState, useCallback } from 'react'
import TextareaAutosize from 'react-textarea-autosize'
import { Button } from '@/components/ui/button'
import { Send, Loader2 } from 'lucide-react'
import { useAuth } from '@clerk/nextjs'
import { toast } from 'sonner'

interface ComposeInputProps {
  workspaceId: string
  conversationId: string
  disabled?: boolean
}

export function ComposeInput({ workspaceId, conversationId, disabled }: ComposeInputProps) {
  const [content, setContent] = useState('')
  const [isSending, setIsSending] = useState(false)
  const { userId } = useAuth()

  const handleSend = useCallback(async () => {
    if (!content.trim() || isSending || !userId) return

    setIsSending(true)
    try {
      const response = await fetch('/api/messages/send', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          workspace_id: workspaceId,
          conversation_id: conversationId,
          content: content.trim(),
          sender_id: userId,
        }),
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Failed to send message')
      }

      setContent('')
    } catch (error) {
      console.error('Send error:', error)
      toast.error('Gagal mengirim pesan')
    } finally {
      setIsSending(false)
    }
  }, [content, workspaceId, conversationId, userId, isSending])

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSend()
    }
  }

  return (
    <div className="flex items-end gap-2 p-4 border-t bg-background">
      <TextareaAutosize
        value={content}
        onChange={(e) => setContent(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder="Ketik pesan..."
        minRows={1}
        maxRows={5}
        disabled={disabled || isSending}
        className="flex-1 resize-none rounded-lg border px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary"
      />
      <Button
        onClick={handleSend}
        disabled={!content.trim() || isSending || disabled}
        size="icon"
      >
        {isSending ? <Loader2 className="h-4 w-4 animate-spin" /> : <Send className="h-4 w-4" />}
      </Button>
    </div>
  )
}
```

Note: Uses Clerk auth for sender_id. API route will validate workspace membership.
  </action>
  <verify>
Compose input renders, auto-expands, Enter sends (with Shift+Enter for newline).
  </verify>
  <done>
Compose input component works with auto-expand, keyboard shortcuts, and loading state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete send message API route with Kapso</name>
  <files>
    src/app/api/messages/send/route.ts
  </files>
  <action>
Complete the send message API route to:
1. Authenticate via Clerk (not CRM_API_KEY - that was old pattern)
2. Validate workspace membership
3. Get Kapso credentials from workspace settings
4. Send via Kapso API
5. Store message in Convex

Updated implementation:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
import { fetchMutation, fetchQuery } from 'convex/nextjs'
import { api } from 'convex/_generated/api'
import { sendMessage as kapsoSendMessage } from '@/lib/kapso/client'
import { decrypt } from '@/lib/encryption'

export async function POST(request: NextRequest) {
  try {
    // 1. Authenticate via Clerk
    const { userId } = await auth()
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // 2. Parse request body
    const body = await request.json()
    const { workspace_id, conversation_id, content, message_type = 'text' } = body

    if (!workspace_id || !conversation_id || !content) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    // 3. Get conversation and contact
    const conversation = await fetchQuery(
      api.conversations.getByIdInternal,
      { conversation_id }
    )

    if (!conversation) {
      return NextResponse.json(
        { error: 'Conversation not found' },
        { status: 404 }
      )
    }

    const contact = await fetchQuery(
      api.contacts.getByIdInternal,
      { contact_id: conversation.contact_id }
    )

    if (!contact) {
      return NextResponse.json(
        { error: 'Contact not found' },
        { status: 404 }
      )
    }

    // 4. Get workspace with Kapso credentials
    const workspace = await fetchQuery(
      api.workspaces.getByIdInternal,
      { workspace_id }
    )

    if (!workspace || !workspace.kapso_phone_id || !workspace.meta_access_token) {
      return NextResponse.json(
        { error: 'Kapso not configured for this workspace' },
        { status: 400 }
      )
    }

    // 5. Decrypt Kapso API key
    const apiKey = decrypt(workspace.meta_access_token)

    // 6. Send via Kapso
    const kapsoResult = await kapsoSendMessage(
      { apiKey, phoneId: workspace.kapso_phone_id },
      contact.phone,
      content
    )

    // 7. Store message in Convex
    const message = await fetchMutation(
      api.mutations.createOutboundMessage,
      {
        workspace_id,
        conversation_id,
        sender_id: userId,
        content,
        message_type,
        kapso_message_id: kapsoResult.messages?.[0]?.id,
      }
    )

    return NextResponse.json({
      success: true,
      message,
      kapso_message_id: kapsoResult.messages?.[0]?.id,
    })

  } catch (error) {
    console.error('[MessagesSend] Error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to send message' },
      { status: 500 }
    )
  }
}
```

Note:
- Removed CRM_API_KEY auth, using Clerk auth instead
- Added workspace membership check (done via Convex query)
- Decrypt Kapso token from workspace.meta_access_token
- Store kapso_message_id for tracking

Also need to ensure `convex/workspaces.ts` has `getByIdInternal` query. Check if it exists, if not create it.
  </action>
  <verify>
Send a test message from inbox - appears in thread and delivered via Kapso.
  </verify>
  <done>
API route authenticates via Clerk, sends via Kapso, stores in Convex, returns success.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire compose input into message thread</name>
  <files>
    src/components/inbox/message-thread.tsx
  </files>
  <action>
Update message-thread.tsx to include the ComposeInput component:

1. Import ComposeInput
2. Replace the placeholder compose area with actual ComposeInput
3. Pass required props: workspaceId, conversationId

Updated compose area section:
```tsx
{/* Compose area */}
<ComposeInput
  workspaceId={workspaceId}
  conversationId={conversationId}
/>
```

The message will appear automatically via Convex real-time subscription (useQuery auto-updates).
  </action>
  <verify>
Type message, press Enter, message appears in thread immediately.
  </verify>
  <done>
Compose input wired into message thread, sent messages appear via real-time subscription.
  </done>
</task>

</tasks>

<verification>
1. Open inbox, select a conversation
2. Type a message in compose input
3. Press Enter - message sends
4. Message appears in thread immediately
5. Check Kapso dashboard - message was sent to WhatsApp
6. Reply from WhatsApp appears in thread (via existing webhook)
</verification>

<success_criteria>
- Compose input auto-expands as user types
- Enter sends message, Shift+Enter adds new line
- Send button disabled when empty or sending
- Loading state shows during send
- Message appears in thread after send
- Message delivered to WhatsApp via Kapso
- Error handling shows toast on failure
</success_criteria>

<output>
After completion, create `.planning/phases/02-inbox/02-03-SUMMARY.md`
</output>
