---
phase: 04-user-migration-organizations
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - scripts/update-convex-user-ids.ts
  - convex/migrate.ts
autonomous: true

must_haves:
  truths:
    - "All user_id fields in core tables updated to Clerk IDs"
    - "All owner_id fields updated to Clerk IDs"
    - "No Supabase UUIDs remain in user reference fields for core tables"
  artifacts:
    - path: "scripts/update-convex-user-ids.ts"
      provides: "Batch update script for Convex user ID migration (core tables)"
      min_lines: 80
    - path: "convex/migrate.ts"
      provides: "Migration queries and mutations for user ID updates"
      exports: ["listWorkspaces", "updateWorkspaceOwnerIds", "listWorkspaceMembers", "updateWorkspaceMemberUserIds"]
  key_links:
    - from: "scripts/update-convex-user-ids.ts"
      to: ".planning/migrations/user-id-mapping.json"
      via: "JSON file read"
      pattern: "user-id-mapping\\.json"
    - from: "scripts/update-convex-user-ids.ts"
      to: "convex/migrate.ts"
      via: "Convex mutations"
      pattern: "api\\.migrate\\."
---

<objective>
Update core Convex tables to use Clerk user IDs instead of Supabase UUIDs.

Purpose: Complete the user ID migration for core CRM tables so app queries use Clerk IDs consistently
Output: All user references in core tables (workspaces, members, contacts, conversations, messages, notes) point to Clerk IDs
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-user-migration-organizations/04-01-SUMMARY.md
@.planning/phases/04-user-migration-organizations/04-02-SUMMARY.md
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add migration queries and mutations to Convex</name>
  <files>convex/migrate.ts</files>
  <action>
Create or extend migrate.ts with BOTH queries (to list records) AND mutations (to update them).

**IMPORTANT:** The migration script needs to query existing data. Add list queries for each table:

```typescript
import { query, mutation, internalQuery, internalMutation } from "./_generated/server";
import { v } from "convex/values";

// ============================================
// LIST QUERIES (for migration script to read data)
// ============================================

/**
 * List all workspaces with their current owner_id.
 * Used by migration script to find records needing update.
 */
export const listWorkspaces = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("workspaces").collect();
  },
});

export const listWorkspaceMembers = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("workspaceMembers").collect();
  },
});

export const listContacts = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("contacts").collect();
  },
});

export const listConversations = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("conversations").collect();
  },
});

export const listMessages = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("messages").collect();
  },
});

export const listContactNotes = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("contactNotes").collect();
  },
});

// ============================================
// UPDATE MUTATIONS (for migration script to write data)
// ============================================

/**
 * Update owner_id in workspaces table.
 * Changes from Supabase UUID to Clerk ID.
 */
export const updateWorkspaceOwnerIds = mutation({
  args: {
    updates: v.array(v.object({
      workspaceId: v.id("workspaces"),
      newOwnerId: v.string(), // Clerk ID
    })),
  },
  handler: async (ctx, args) => {
    for (const update of args.updates) {
      await ctx.db.patch(update.workspaceId, {
        owner_id: update.newOwnerId,
        updated_at: Date.now(),
      });
    }
    return { updated: args.updates.length };
  },
});

/**
 * Update user_id in workspaceMembers table.
 */
export const updateWorkspaceMemberUserIds = mutation({
  args: {
    updates: v.array(v.object({
      memberId: v.id("workspaceMembers"),
      newUserId: v.string(), // Clerk ID
    })),
  },
  handler: async (ctx, args) => {
    for (const update of args.updates) {
      await ctx.db.patch(update.memberId, {
        user_id: update.newUserId,
      });
    }
    return { updated: args.updates.length };
  },
});

// Similar mutations for:
// - updateContactAssignedTo (contacts.assigned_to - optional field)
// - updateConversationAssignedTo (conversations.assigned_to - optional field)
// - updateMessageSenderId (messages.sender_id - optional field)
// - updateContactNoteUserIds (contactNotes.user_id)
```

Each mutation takes batch of {recordId, newUserId} and patches the record.
Handle optional fields (assigned_to, sender_id) - only update if field has a value.
  </action>
  <verify>
Run `npx convex dev` - no TypeScript errors, queries and mutations appear in Convex dashboard
  </verify>
  <done>Migration queries and mutations exist for all core tables with user ID fields</done>
</task>

<task type="auto">
  <name>Task 2: Create user ID update script for core tables</name>
  <files>scripts/update-convex-user-ids.ts</files>
  <action>
Create a TypeScript script that uses the queries and mutations from migrate.ts:

```typescript
import { ConvexHttpClient } from "convex/browser";
import { api } from "../convex/_generated/api";
import * as dotenv from "dotenv";
import * as fs from "fs";

dotenv.config({ path: ".env.local" });

const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

// Load ID mappings from migration file
const idMapping: Record<string, string> = JSON.parse(
  fs.readFileSync(".planning/migrations/user-id-mapping.json", "utf-8")
);

async function migrateTable<T extends { _id: any }>(
  tableName: string,
  listFn: () => Promise<T[]>,
  updateFn: (updates: any[]) => Promise<{ updated: number }>,
  getOldId: (record: T) => string | undefined,
  makeUpdate: (record: T, newId: string) => any,
  dryRun: boolean
) {
  console.log(`\n--- ${tableName} ---`);

  const records = await listFn();
  const updates = records
    .filter(r => {
      const oldId = getOldId(r);
      return oldId && idMapping[oldId]; // Has value AND has mapping
    })
    .map(r => makeUpdate(r, idMapping[getOldId(r)!]));

  console.log(`  Found: ${records.length} records`);
  console.log(`  To update: ${updates.length} records`);

  if (!dryRun && updates.length > 0) {
    // Batch in chunks of 100
    for (let i = 0; i < updates.length; i += 100) {
      const batch = updates.slice(i, i + 100);
      const result = await updateFn(batch);
      console.log(`  Updated batch: ${result.updated}`);
    }
  }

  return { total: records.length, updated: updates.length };
}

async function main() {
  const dryRun = process.argv.includes("--dry-run");
  console.log(dryRun ? "DRY RUN MODE" : "LIVE MODE");

  const report: Record<string, { total: number; updated: number }> = {};

  // 1. Workspaces (owner_id)
  report.workspaces = await migrateTable(
    "workspaces",
    () => convex.query(api.migrate.listWorkspaces, {}),
    (updates) => convex.mutation(api.migrate.updateWorkspaceOwnerIds, { updates }),
    (r) => r.owner_id,
    (r, newId) => ({ workspaceId: r._id, newOwnerId: newId }),
    dryRun
  );

  // 2. WorkspaceMembers (user_id)
  report.workspaceMembers = await migrateTable(
    "workspaceMembers",
    () => convex.query(api.migrate.listWorkspaceMembers, {}),
    (updates) => convex.mutation(api.migrate.updateWorkspaceMemberUserIds, { updates }),
    (r) => r.user_id,
    (r, newId) => ({ memberId: r._id, newUserId: newId }),
    dryRun
  );

  // 3-6: contacts, conversations, messages, contactNotes
  // (similar pattern for each table)

  // Save report
  if (!dryRun) {
    fs.writeFileSync(
      ".planning/migrations/user-id-update-report-core.json",
      JSON.stringify(report, null, 2)
    );
    console.log("\nReport saved to .planning/migrations/user-id-update-report-core.json");
  }
}

main().catch(console.error);
```

**Tables to process (core tables only):**
1. workspaces.owner_id
2. workspaceMembers.user_id
3. contacts.assigned_to (optional field - skip null values)
4. conversations.assigned_to (optional field - skip null values)
5. messages.sender_id (optional field - skip null values)
6. contactNotes.user_id

Script should support --dry-run to show what would be updated.
  </action>
  <verify>
Run `npx tsx scripts/update-convex-user-ids.ts --dry-run` shows update counts per table
  </verify>
  <done>Script exists and dry-run shows correct update counts for core tables</done>
</task>

<task type="auto">
  <name>Task 3: Run user ID update migration for core tables</name>
  <files>.planning/migrations/user-id-update-report-core.json</files>
  <action>
Execute the migration script:

```bash
npx tsx scripts/update-convex-user-ids.ts
```

Expected output:
- Records updated in each table
- Summary report generated at .planning/migrations/user-id-update-report-core.json
- Any warnings for unmapped IDs logged

After script completes, verify in Convex Dashboard:
- Query a workspace -> owner_id is Clerk ID format (user_xxx)
- Query a workspaceMember -> user_id is Clerk ID format
  </action>
  <verify>
1. Check .planning/migrations/user-id-update-report-core.json exists
2. Verify update counts match expected (no errors)
3. Spot-check Convex data in dashboard: workspaces table shows Clerk IDs in owner_id
  </verify>
  <done>All user references in core Convex tables use Clerk IDs</done>
</task>

</tasks>

<verification>
1. No Supabase UUIDs remain in user_id/owner_id fields for core tables
2. Spot check confirms Clerk ID format (user_xxx)
3. Update report shows all core tables processed
4. No warnings for unmapped IDs (all users migrated)
</verification>

<success_criteria>
- USER-04: User ID mapping preserves data relationships for core tables
- Core Convex tables (workspaces, members, contacts, conversations, messages, notes) use Clerk IDs
- Data integrity maintained (no orphaned references)
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-migration-organizations/04-03-SUMMARY.md`
</output>
