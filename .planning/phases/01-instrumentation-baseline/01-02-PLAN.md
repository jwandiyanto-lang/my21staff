---
phase: 01-instrumentation-baseline
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/app/api/contacts/by-phone/route.ts
  - src/app/api/conversations/route.ts
autonomous: true

must_haves:
  truths:
    - "API response times logged for every request to /api/contacts/by-phone"
    - "API response times logged for every request to /api/conversations"
    - "Query count and individual query times logged per request"
  artifacts:
    - path: "src/app/api/contacts/by-phone/route.ts"
      provides: "Instrumented contact lookup endpoint"
      contains: "withTiming"
    - path: "src/app/api/conversations/route.ts"
      provides: "Instrumented conversations endpoint"
      contains: "withTiming"
  key_links:
    - from: "src/app/api/contacts/by-phone/route.ts"
      to: "src/lib/instrumentation/with-timing.ts"
      via: "import withTiming"
      pattern: "import.*withTiming.*instrumentation"
    - from: "src/app/api/conversations/route.ts"
      to: "src/lib/instrumentation/with-timing.ts"
      via: "import withTiming"
      pattern: "import.*withTiming.*instrumentation"
---

<objective>
Instrument the two hot-path API routes with timing and query logging.

Purpose: Enable visibility into API performance and query patterns in Vercel logs.
Output: Both routes log response time and query breakdown for every request.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-instrumentation-baseline/01-RESEARCH.md
@.planning/phases/01-instrumentation-baseline/01-01-SUMMARY.md
@src/app/api/contacts/by-phone/route.ts
@src/app/api/conversations/route.ts
@src/lib/instrumentation/with-timing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Instrument /api/contacts/by-phone</name>
  <files>src/app/api/contacts/by-phone/route.ts</files>
  <action>
1. Import helpers:
   ```typescript
   import { withTiming, createRequestMetrics, logQuery, logQuerySummary } from '@/lib/instrumentation/with-timing'
   ```

2. Rename existing `GET` function to `getHandler`

3. Add query timing to each Supabase query:
   - Query 1: contacts lookup (lines ~58-73)
   - Query 2: contact_notes (lines ~84-89)
   - Query 3: conversations (lines ~92-96)
   - Query 4: messages (lines ~100-105, inside if block)

   For each query, wrap with:
   ```typescript
   const metrics = createRequestMetrics()

   let queryStart = performance.now()
   const { data: contact, error } = await supabase.from('contacts')...
   logQuery(metrics, 'contacts', performance.now() - queryStart)
   ```

4. Add query summary log before returning:
   ```typescript
   logQuerySummary('/api/contacts/by-phone', metrics)
   ```

5. Export wrapped handler:
   ```typescript
   export const GET = withTiming('/api/contacts/by-phone', getHandler)
   ```

Expected log output per request:
```
[API] /api/contacts/by-phone GET - 234ms - 200
[Queries] /api/contacts/by-phone - 4 queries: contacts:45ms, contact_notes:23ms, conversations:18ms, messages:52ms
```

Note: Messages query only runs if conversation exists, so query count may be 3 or 4.
  </action>
  <verify>
1. `grep "withTiming" src/app/api/contacts/by-phone/route.ts` shows wrapper applied
2. `grep -c "logQuery" src/app/api/contacts/by-phone/route.ts` shows 4 occurrences
3. `npm run build` succeeds
  </verify>
  <done>
- /api/contacts/by-phone wrapped with withTiming
- All 4 queries timed individually
- Query summary logged per request
  </done>
</task>

<task type="auto">
  <name>Task 2: Instrument /api/conversations</name>
  <files>src/app/api/conversations/route.ts</files>
  <action>
1. Import helpers:
   ```typescript
   import { withTiming, createRequestMetrics, logQuery, logQuerySummary } from '@/lib/instrumentation/with-timing'
   ```

2. Rename existing `GET` function to `getHandler`

3. Add query timing to each Supabase query:
   - Query 1: conversations with contacts (line ~33-67)
   - Query 2: activeCount (lines ~75-79)
   - Query 3: teamMembers (lines ~82-85)
   - Query 4: contactsWithTags (lines ~91-95)

   For each query:
   ```typescript
   const metrics = createRequestMetrics()

   let queryStart = performance.now()
   const { data, error, count } = await query
   logQuery(metrics, 'conversations', performance.now() - queryStart)
   ```

4. Add query summary log before returning:
   ```typescript
   logQuerySummary('/api/conversations', metrics)
   ```

5. Export wrapped handler:
   ```typescript
   export const GET = withTiming('/api/conversations', getHandler)
   ```

Expected log output per request:
```
[API] /api/conversations GET - 1234ms - 200
[Queries] /api/conversations - 4 queries: conversations:800ms, activeCount:150ms, teamMembers:120ms, contactsWithTags:90ms
```
  </action>
  <verify>
1. `grep "withTiming" src/app/api/conversations/route.ts` shows wrapper applied
2. `grep -c "logQuery" src/app/api/conversations/route.ts` shows 4 occurrences
3. `npm run build` succeeds
  </verify>
  <done>
- /api/conversations wrapped with withTiming
- All 4 queries timed individually
- Query summary logged per request
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. `npm run build` succeeds
2. Both routes export GET via withTiming wrapper
3. Local test: `curl http://localhost:3000/api/conversations?workspace=xxx` shows timing in terminal
</verification>

<success_criteria>
- Both API routes wrapped with withTiming
- Each query in both routes has individual timing
- Query summary logged at end of each request
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-instrumentation-baseline/01-02-SUMMARY.md`
</output>
