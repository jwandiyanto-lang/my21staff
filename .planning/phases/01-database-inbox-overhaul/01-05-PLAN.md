---
phase: 01-database-inbox-overhaul
plan: 05
type: execute
wave: 3
depends_on: ["01-04"]
files_modified:
  - src/lib/queries/use-typing-indicator.ts
  - src/app/(dashboard)/[workspace]/inbox/conversation-list.tsx
  - src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx
  - src/app/api/webhook/kapso/route.ts
autonomous: true

must_haves:
  truths:
    - "Typing indicator shows when contact is typing"
    - "Typing indicator auto-clears after 5 seconds"
    - "Unread count in sidebar updates in real-time"
    - "New messages appear without manual refresh"
    - "Chats don't disappear during sync"
  artifacts:
    - path: "src/lib/queries/use-typing-indicator.ts"
      provides: "Supabase Broadcast hook for typing indicators"
      exports: ["useTypingIndicator"]
      min_lines: 50
    - path: "src/app/(dashboard)/[workspace]/inbox/conversation-list.tsx"
      provides: "Conversation list with typing indicator display"
      min_lines: 150
    - path: "src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx"
      provides: "Inbox with real-time unread count"
      min_lines: 550
  key_links:
    - from: "inbox-client.tsx"
      to: "use-typing-indicator.ts"
      via: "useTypingIndicator hook"
      pattern: "useTypingIndicator"
    - from: "conversation-list.tsx"
      to: "typingContacts prop"
      via: "props"
      pattern: "typingContacts.*Map|isTyping"
---

<objective>
Implement real-time typing indicators and improve message sync reliability.

Purpose: Show "Contact is typing..." for better conversation UX, ensure unread counts update live, and prevent chats from disappearing during webhook processing.

Output: Typing indicator hook using Supabase Broadcast, updated UI components, improved webhook reliability.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-database-inbox-overhaul/01-CONTEXT.md
@.planning/phases/01-database-inbox-overhaul/01-RESEARCH.md
@src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx
@src/app/(dashboard)/[workspace]/inbox/conversation-list.tsx
@src/lib/queries/use-messages.ts
@.planning/phases/01-database-inbox-overhaul/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create typing indicator hook</name>
  <files>src/lib/queries/use-typing-indicator.ts</files>
  <action>
Create a hook that uses Supabase Broadcast for ephemeral typing indicator state:

```typescript
'use client'

import { useState, useEffect, useCallback, useRef } from 'react'
import { createClient } from '@/lib/supabase/client'
import { isDevMode } from '@/lib/mock-data'

interface TypingState {
  phone: string
  timestamp: number
}

/**
 * Hook for managing typing indicators via Supabase Broadcast
 * Uses ephemeral broadcast channel - no database storage
 *
 * @param workspaceId - Workspace to subscribe to
 * @returns Map of phone -> timestamp for typing contacts
 */
export function useTypingIndicator(workspaceId: string) {
  // Map of phone number -> last typing timestamp
  const [typingContacts, setTypingContacts] = useState<Map<string, number>>(new Map())
  const channelRef = useRef<ReturnType<ReturnType<typeof createClient>['channel']> | null>(null)

  // Clear stale typing indicators (older than 5 seconds)
  useEffect(() => {
    const interval = setInterval(() => {
      const now = Date.now()
      setTypingContacts((prev) => {
        const updated = new Map(prev)
        let changed = false

        for (const [phone, timestamp] of updated.entries()) {
          if (now - timestamp > 5000) {
            updated.delete(phone)
            changed = true
          }
        }

        return changed ? updated : prev
      })
    }, 1000) // Check every second

    return () => clearInterval(interval)
  }, [])

  // Subscribe to typing broadcast channel
  useEffect(() => {
    if (isDevMode() || !workspaceId) return

    const supabase = createClient()
    const channel = supabase.channel(`typing:${workspaceId}`)

    channel
      .on('broadcast', { event: 'typing' }, (payload) => {
        const { phone, isTyping } = payload.payload as { phone: string; isTyping: boolean }

        setTypingContacts((prev) => {
          const updated = new Map(prev)
          if (isTyping) {
            updated.set(phone, Date.now())
          } else {
            updated.delete(phone)
          }
          return updated
        })
      })
      .subscribe()

    channelRef.current = channel

    return () => {
      supabase.removeChannel(channel)
      channelRef.current = null
    }
  }, [workspaceId])

  // Broadcast typing event (for when we type - optional)
  const broadcastTyping = useCallback(
    async (phone: string, isTyping: boolean) => {
      if (!channelRef.current) return

      await channelRef.current.send({
        type: 'broadcast',
        event: 'typing',
        payload: { phone, isTyping },
      })
    },
    []
  )

  // Check if a specific contact is typing
  const isContactTyping = useCallback(
    (phone: string): boolean => {
      const timestamp = typingContacts.get(phone)
      if (!timestamp) return false
      return Date.now() - timestamp < 5000
    },
    [typingContacts]
  )

  return {
    typingContacts,
    isContactTyping,
    broadcastTyping,
  }
}

/**
 * Server-side function to broadcast typing indicator from webhook
 * Called when Kapso sends typing status update
 */
export async function broadcastTypingFromServer(
  workspaceId: string,
  phone: string,
  isTyping: boolean
) {
  // This would be called from webhook - using service role client
  const { createApiAdminClient } = await import('@/lib/supabase/server')
  const supabase = createApiAdminClient()

  const channel = supabase.channel(`typing:${workspaceId}`)
  await channel.send({
    type: 'broadcast',
    event: 'typing',
    payload: { phone, isTyping },
  })
}
```
  </action>
  <verify>
Check hook compiles:
```bash
npx tsc --noEmit src/lib/queries/use-typing-indicator.ts
```
  </verify>
  <done>useTypingIndicator hook with 5-second auto-clear and broadcast support</done>
</task>

<task type="auto">
  <name>Task 2: Add typing indicator to conversation list</name>
  <files>src/app/(dashboard)/[workspace]/inbox/conversation-list.tsx</files>
  <action>
Update ConversationList to display typing indicators:

1. Accept `typingContacts` as prop (Map<string, number>)
2. Show "typing..." indicator for contacts who are typing
3. Animate the typing indicator

Add to ConversationListProps interface:
```typescript
interface ConversationListProps {
  conversations: ConversationWithContact[]
  selectedId: string | null
  onSelect: (conversation: ConversationWithContact) => void
  searchQuery: string
  hasFilters?: boolean  // renamed from hasStatusFilter
  workspaceName?: string
  typingContacts?: Map<string, number>  // NEW
}
```

Update the conversation item to show typing indicator:

```typescript
// Inside the map function, before rendering preview
const isTyping = typingContacts?.has(conversation.contact.phone) &&
  Date.now() - (typingContacts.get(conversation.contact.phone) || 0) < 5000

// Update Row 2 to show typing indicator
<p className="text-sm text-muted-foreground truncate mt-0.5">
  {isTyping ? (
    <span className="flex items-center gap-1 text-primary">
      <span className="typing-dots flex gap-0.5">
        <span className="w-1 h-1 bg-primary rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
        <span className="w-1 h-1 bg-primary rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
        <span className="w-1 h-1 bg-primary rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
      </span>
      <span>typing...</span>
    </span>
  ) : (
    conversation.last_message_preview || 'No messages yet'
  )}
</p>
```

Add the CSS animation in the same file or in globals.css:
```css
/* If adding to globals.css */
.typing-dots span {
  animation: bounce 1s infinite;
}

.typing-dots span:nth-child(2) {
  animation-delay: 0.15s;
}

.typing-dots span:nth-child(3) {
  animation-delay: 0.3s;
}
```
  </action>
  <verify>
1. Manually trigger typing event via Supabase dashboard broadcast
2. Verify "typing..." appears in conversation list
3. Verify it auto-clears after 5 seconds
  </verify>
  <done>Conversation list shows animated typing indicator</done>
</task>

<task type="auto">
  <name>Task 3: Integrate typing indicators and improve real-time sync reliability</name>
  <files>src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx</files>
  <action>
Update inbox-client to use typing indicators and improve real-time reliability to prevent chat disappearance (INBOX-07).

1. Import and use useTypingIndicator hook
2. Pass typingContacts to ConversationList
3. Clear typing indicator when message received from that contact
4. **CRITICAL for INBOX-07 (no disappearing chats):** Use idempotent cache updates with ID deduplication

Add to imports:
```typescript
import { useTypingIndicator } from '@/lib/queries/use-typing-indicator'
```

Add hook usage:
```typescript
// After other hooks
const { typingContacts, isContactTyping } = useTypingIndicator(workspace.id)
```

Update the real-time subscription with idempotent updates to prevent chat disappearance:
```typescript
// In the existing conversations subscription, add:
.on(
  'postgres_changes',
  {
    event: 'INSERT',
    schema: 'public',
    table: 'messages',
    filter: `workspace_id=eq.${workspace.id}`,
  },
  (payload) => {
    // Find the conversation this message belongs to and clear typing
    const conversationId = (payload.new as { conversation_id: string }).conversation_id
    const conv = conversations.find(c => c.id === conversationId)
    if (conv) {
      // Typing cleared automatically since message arrived
      // Just trigger a refresh of activeCount
      queryClient.invalidateQueries({ queryKey: ['conversations', workspace.id] })
    }
  }
)

// For conversation list updates, use idempotent cache updates
// This prevents chat disappearance (INBOX-07) per RESEARCH.md Pitfall #2
.on(
  'postgres_changes',
  {
    event: '*',
    schema: 'public',
    table: 'conversations',
    filter: `workspace_id=eq.${workspace.id}`,
  },
  (payload) => {
    // Use setQueryData for immediate UI update with ID deduplication
    queryClient.setQueryData(
      ['conversations', workspace.id],
      (oldData: ConversationsResponse | undefined) => {
        if (!oldData) return oldData

        if (payload.eventType === 'INSERT') {
          // Check if conversation already exists (idempotent - prevents duplicates)
          const exists = oldData.conversations.some(c => c.id === payload.new.id)
          if (exists) return oldData
          // Add new conversation to the list
          return {
            ...oldData,
            conversations: [payload.new as ConversationWithContact, ...oldData.conversations],
            totalCount: oldData.totalCount + 1,
          }
        }

        if (payload.eventType === 'UPDATE') {
          // Update existing conversation in place (prevents disappearance)
          return {
            ...oldData,
            conversations: oldData.conversations.map(c =>
              c.id === payload.new.id ? { ...c, ...payload.new } : c
            ),
          }
        }

        if (payload.eventType === 'DELETE') {
          // Only remove if actually deleted
          return {
            ...oldData,
            conversations: oldData.conversations.filter(c => c.id !== payload.old.id),
            totalCount: oldData.totalCount - 1,
          }
        }

        return oldData
      }
    )
  }
)
```

Pass to ConversationList:
```typescript
<ConversationList
  conversations={filteredConversations}
  selectedId={selectedConversation?.id || null}
  onSelect={handleSelectConversation}
  searchQuery={searchQuery}
  hasFilters={hasFilters}
  workspaceName={workspace.name}
  typingContacts={typingContacts}  // NEW
/>
```

Also show typing indicator in MessageThread header when viewing that conversation:
```typescript
// Pass isTyping to MessageThread
const currentContactTyping = selectedConversation
  ? isContactTyping(selectedConversation.contact.phone)
  : false

<MessageThread
  // ... existing props
  isContactTyping={currentContactTyping}  // NEW
/>
```
  </action>
  <verify>
1. Open inbox
2. Simulate typing event (via webhook or Supabase broadcast test)
3. Verify typing appears in conversation list
4. Send a message - typing should clear
5. Verify unread count badge updates when new message arrives
6. **Test INBOX-07:** Open inbox in two tabs, send messages rapidly, verify chats never disappear from either tab
7. **Test INBOX-07:** Refresh page during active messaging, verify all conversations are still present
  </verify>
  <done>Typing indicators integrated, real-time sync uses idempotent cache updates to prevent chat disappearance</done>
</task>

</tasks>

<verification>
1. Typing indicator: When contact types, "typing..." appears in conversation list
2. Auto-clear: Typing indicator disappears after 5 seconds of no activity
3. Message clears typing: When message received, typing indicator clears immediately
4. Real-time unread: activeCount badge updates when new message arrives
5. No disappearing chats: Refresh page - all conversations still present
6. No disappearing chats: Open two browser tabs, send messages rapidly - chats stable in both
7. No duplicates: Same conversation never appears twice in list (idempotent updates)
8. Real-time insert: New conversation appears in list when new contact messages
9. Real-time update: Conversation moves to top when new message received
</verification>

<success_criteria>
- [x] useTypingIndicator hook subscribes to Supabase Broadcast
- [x] Typing indicators auto-clear after 5 seconds
- [x] Conversation list shows "typing..." for typing contacts
- [x] Typing indicator has animated dots
- [x] Message receipt clears typing indicator
- [x] typingContacts passed to ConversationList
- [x] Real-time subscription handles INSERT, UPDATE events
- [x] activeCount badge updates in real-time
- [x] No chat disappearance on sync (idempotent cache updates with ID checks)
- [x] No duplicate conversations (ID deduplication on INSERT)
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-inbox-overhaul/01-05-SUMMARY.md`
</output>
