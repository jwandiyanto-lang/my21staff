---
phase: 01-database-inbox-overhaul
plan: 04
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx
  - src/lib/queries/use-conversations.ts
  - src/app/api/conversations/route.ts
autonomous: true

must_haves:
  truths:
    - "User can toggle between Active (unread) and All conversations"
    - "Active filter shows only contacts with unread messages"
    - "User can filter conversations by tags (OR logic)"
    - "User can filter conversations by lead status"
    - "User can save filter presets for quick access"
    - "Sidebar unread count updates when switching to Active view"
  artifacts:
    - path: "src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx"
      provides: "Updated inbox with Active/All toggle and enhanced filters"
      min_lines: 550
    - path: "src/lib/queries/use-conversations.ts"
      provides: "Conversations query with filter support"
      min_lines: 70
    - path: "src/app/api/conversations/route.ts"
      provides: "Conversations API with filter parameters"
      min_lines: 80
  key_links:
    - from: "inbox-client.tsx"
      to: "use-conversations.ts"
      via: "useConversations hook with filters"
      pattern: "useConversations.*showUnreadOnly|activeFilter"
    - from: "use-conversations.ts"
      to: "/api/conversations"
      via: "fetch with query params"
      pattern: "fetch.*api/conversations.*active=|unread="
---

<objective>
Implement Active/All conversation filter toggle and enhance existing tag/status filters.

Purpose: Allow users to quickly focus on conversations needing attention (unread messages) while maintaining access to all conversations. Support saved filter presets for power users.

Output: Updated inbox UI with Active/All toggle, enhanced filter API endpoint, and filter preset storage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-database-inbox-overhaul/01-CONTEXT.md
@.planning/phases/01-database-inbox-overhaul/01-RESEARCH.md
@src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx
@src/lib/queries/use-conversations.ts
@.planning/phases/01-database-inbox-overhaul/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update conversations API for Active/All filtering</name>
  <files>src/app/api/conversations/route.ts</files>
  <action>
Update the conversations API to support Active/All filtering and enhanced filters.

Read the current file first, then add:

1. New query parameters: `active` (boolean - show only unread), `status[]`, `tags[]`
2. Server-side filtering for better performance
3. Count queries for total vs filtered

Key changes:

```typescript
// Add to GET handler query params
const active = searchParams.get('active') === 'true'
const statusFilters = searchParams.getAll('status')
const tagFilters = searchParams.getAll('tags')

// Build query with filters
let query = supabase
  .from('conversations')
  .select('*, contact:contacts!inner(*)', { count: 'exact' })
  .eq('workspace_id', workspaceId)
  .order('last_message_at', { ascending: false })

// Active filter (unread only)
if (active) {
  query = query.gt('unread_count', 0)
}

// Status filter (if provided)
if (statusFilters.length > 0) {
  query = query.in('contact.lead_status', statusFilters)
}

// Tag filter (if provided) - uses array overlap
if (tagFilters.length > 0) {
  // Supabase doesn't support array overlap in JS client directly
  // Use raw SQL filter
  query = query.filter('contact.tags', 'ov', `{${tagFilters.join(',')}}`)
}

// Also return activeCount (unread conversations) for sidebar badge
const { count: activeCount } = await supabase
  .from('conversations')
  .select('*', { count: 'exact', head: true })
  .eq('workspace_id', workspaceId)
  .gt('unread_count', 0)

return NextResponse.json({
  conversations,
  totalCount,
  activeCount, // NEW: for sidebar badge
  teamMembers,
  quickReplies,
  contactTags,
})
```
  </action>
  <verify>
Test API with filters:
```bash
curl "http://localhost:3000/api/conversations?workspace=xxx&active=true"
curl "http://localhost:3000/api/conversations?workspace=xxx&status=hot&status=warm"
curl "http://localhost:3000/api/conversations?workspace=xxx&tags=Australia"
```
  </verify>
  <done>Conversations API supports active, status[], and tags[] query parameters</done>
</task>

<task type="auto">
  <name>Task 2: Update useConversations hook for filter support</name>
  <files>src/lib/queries/use-conversations.ts</files>
  <action>
Update the useConversations hook to accept filter parameters and pass them to API:

```typescript
'use client'

import { useQuery, useQueryClient } from '@tanstack/react-query'
import { createClient } from '@/lib/supabase/client'
import { useEffect } from 'react'
import type { ConversationWithContact, WorkspaceMember, Profile } from '@/types/database'
import { isDevMode, MOCK_CONVERSATIONS } from '@/lib/mock-data'

export type TeamMember = WorkspaceMember & { profile: Profile | null }

interface ConversationFilters {
  active?: boolean
  statusFilters?: string[]
  tagFilters?: string[]
  assignedTo?: string
}

interface ConversationsResponse {
  conversations: ConversationWithContact[]
  totalCount: number
  activeCount: number  // NEW: count of unread conversations
  teamMembers: TeamMember[]
  quickReplies: Array<{id: string, label: string, text: string}>
  contactTags: string[]
}

const PAGE_SIZE = 50

export function useConversations(
  workspaceId: string,
  page: number = 0,
  filters: ConversationFilters = {}
) {
  const queryClient = useQueryClient()

  const query = useQuery({
    // Include filters in query key for proper caching
    queryKey: ['conversations', workspaceId, page, filters],
    queryFn: async (): Promise<ConversationsResponse> => {
      if (isDevMode()) {
        let filtered = MOCK_CONVERSATIONS
        if (filters.active) {
          filtered = filtered.filter(c => (c.unread_count ?? 0) > 0)
        }
        return {
          conversations: filtered,
          totalCount: MOCK_CONVERSATIONS.length,
          activeCount: MOCK_CONVERSATIONS.filter(c => (c.unread_count ?? 0) > 0).length,
          teamMembers: [],
          quickReplies: [],
          contactTags: ['Community', '1on1'],
        }
      }

      // Build URL with filters
      const params = new URLSearchParams({
        workspace: workspaceId,
        page: page.toString(),
        limit: PAGE_SIZE.toString(),
      })

      if (filters.active) {
        params.set('active', 'true')
      }

      if (filters.statusFilters?.length) {
        filters.statusFilters.forEach(s => params.append('status', s))
      }

      if (filters.tagFilters?.length) {
        filters.tagFilters.forEach(t => params.append('tags', t))
      }

      if (filters.assignedTo && filters.assignedTo !== 'all') {
        params.set('assigned', filters.assignedTo)
      }

      const response = await fetch(`/api/conversations?${params.toString()}`)
      if (!response.ok) {
        throw new Error('Failed to load conversations')
      }
      return response.json()
    },
    staleTime: 60 * 1000,
    placeholderData: (previousData) => previousData,
  })

  // Real-time subscription - invalidate on changes
  useEffect(() => {
    if (isDevMode() || !workspaceId) return

    const supabase = createClient()
    const channel = supabase
      .channel(`conversations-list:${workspaceId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'conversations',
          filter: `workspace_id=eq.${workspaceId}`,
        },
        () => {
          // Invalidate all conversation queries for this workspace
          queryClient.invalidateQueries({
            queryKey: ['conversations', workspaceId],
            exact: false, // Invalidate all pages and filter combinations
          })
        }
      )
      .subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [workspaceId, queryClient])

  return query
}
```
  </action>
  <verify>
Check hook compiles without errors:
```bash
npx tsc --noEmit src/lib/queries/use-conversations.ts
```
  </verify>
  <done>useConversations hook accepts filters object and includes them in query key</done>
</task>

<task type="auto">
  <name>Task 3: Update inbox UI with Active/All toggle</name>
  <files>src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx</files>
  <action>
Update the inbox client to use the new filter system:

1. Replace `showUnreadOnly` state with `viewMode` ('active' | 'all')
2. Pass filters to useConversations hook
3. Add Active/All toggle UI (replaces current Unread button)
4. Show activeCount in sidebar badge
5. Remove client-side unread filtering (now server-side)

Key changes:

```typescript
// State changes
const [viewMode, setViewMode] = useState<'active' | 'all'>('active') // Start on Active per CONTEXT decision
const [statusFilter, setStatusFilter] = useState<LeadStatus[]>([])
const [tagFilter, setTagFilter] = useState<string[]>([])
const [assignedFilter, setAssignedFilter] = useState<string>('all')

// Build filters object
const filters = useMemo(() => ({
  active: viewMode === 'active',
  statusFilters: statusFilter,
  tagFilters: tagFilter,
  assignedTo: assignedFilter,
}), [viewMode, statusFilter, tagFilter, assignedFilter])

// Pass filters to hook
const { data, isLoading: isLoadingConversations } = useConversations(
  workspace.id,
  page,
  filters
)

// Extract activeCount for badge
const activeCount = data?.activeCount ?? 0

// Replace Unread button with Active/All toggle
<div className="flex items-center rounded-full bg-muted p-1">
  <button
    onClick={() => setViewMode('active')}
    className={cn(
      'flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium transition-all',
      viewMode === 'active'
        ? 'bg-background text-foreground shadow-sm'
        : 'text-muted-foreground hover:text-foreground'
    )}
  >
    <Mail className="h-3.5 w-3.5" />
    Active
    {activeCount > 0 && (
      <span className="bg-primary text-primary-foreground px-1.5 py-0.5 rounded-full text-[10px]">
        {activeCount}
      </span>
    )}
  </button>
  <button
    onClick={() => setViewMode('all')}
    className={cn(
      'flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium transition-all',
      viewMode === 'all'
        ? 'bg-background text-foreground shadow-sm'
        : 'text-muted-foreground hover:text-foreground'
    )}
  >
    <MailOpen className="h-3.5 w-3.5" />
    All
  </button>
</div>

// Remove the useMemo for filteredConversations that filters by showUnreadOnly
// (filtering is now done server-side)
// Keep only search query filtering (client-side for instant feedback)
const filteredConversations = useMemo(() => {
  if (!searchQuery) return conversations
  return conversations.filter((conv) =>
    conv.contact.name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
    conv.contact.phone.includes(searchQuery)
  )
}, [conversations, searchQuery])
```

Also remove the `hasStatusFilter` prop from ConversationList - update empty state to check filters:

```typescript
// In ConversationList component, update empty state logic
const hasFilters = viewMode === 'active' || statusFilter.length > 0 || tagFilter.length > 0

// Pass hasFilters to ConversationList
<ConversationList
  conversations={filteredConversations}
  selectedId={selectedConversation?.id || null}
  onSelect={handleSelectConversation}
  searchQuery={searchQuery}
  hasFilters={hasFilters}  // renamed from hasStatusFilter
  workspaceName={workspace.name}
/>
```
  </action>
  <verify>
1. Start dev server: `npm run dev`
2. Navigate to inbox
3. Verify Active/All toggle works - Active shows only unread conversations
4. Verify badge shows correct count
5. Verify status and tag filters still work
6. Verify switching between Active/All rerenders conversation list
  </verify>
  <done>Inbox has Active/All toggle, server-side filtering, and activeCount badge</done>
</task>

</tasks>

<verification>
1. Active filter: Click "Active" - only conversations with unread_count > 0 appear
2. All filter: Click "All" - all conversations appear regardless of unread status
3. Status filter: Select "Hot" - only hot leads appear (works in both Active and All)
4. Tag filter: Select "Australia" - only contacts with Australia tag appear
5. Combined filters: Active + Hot + Australia - shows only unread hot leads tagged Australia
6. Badge updates: activeCount in toggle badge matches actual unread conversation count
7. Real-time: When new message arrives, activeCount updates
</verification>

<success_criteria>
- [x] Active/All toggle replaces Unread button
- [x] Active view shows only unread conversations (server-side filter)
- [x] All view shows all conversations
- [x] Default view is Active (per CONTEXT.md decision)
- [x] Badge shows activeCount in Active button
- [x] Status filter works with Active/All
- [x] Tag filter works with Active/All
- [x] Assigned filter works with Active/All
- [x] Filters are passed to API as query params
- [x] Query key includes filters for proper caching
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-inbox-overhaul/01-04-SUMMARY.md`
</output>
