---
phase: 03-convex-spike
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [convex/lib/auth.ts, convex/contacts.ts, convex/conversations.ts]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "requireWorkspaceMembership() helper verifies user is workspace member"
    - "requireAuthentication() helper verifies user is authenticated"
    - "getByPhone query exists and uses by_workspace_phone index"
    - "getContextByPhone query returns full CRM context"
    - "conversations query returns list for workspace"
  artifacts:
    - path: "convex/lib/auth.ts"
      provides: "Authorization helpers for workspace-scoped access"
      exports: ["requireWorkspaceMembership", "requireAuthentication"]
    - path: "convex/contacts.ts"
      provides: "Contact query functions"
      exports: ["getByPhone", "getContextByPhone"]
    - path: "convex/conversations.ts"
      provides: "Conversation query functions"
      exports: ["listByWorkspace", "getByContact"]
  key_links:
    - from: "convex/contacts.ts"
      to: "convex/lib/auth.ts"
      via: "requireWorkspaceMembership() import"
      pattern: "requireWorkspaceMembership"
    - from: "convex/contacts.ts/getByPhone"
      to: "convex/schema.ts"
      via: "by_workspace_phone index"
      pattern: "withIndex.*by_workspace_phone"
    - from: "convex/conversations.ts"
      to: "convex/lib/auth.ts"
      via: "requireWorkspaceMembership() import"
      pattern: "requireWorkspaceMembership"
---

<objective>
Implement authorization helpers and query functions for contacts and conversations in Convex.

Purpose: Create the data access layer that the benchmark will use - contact lookup by phone (the hot path we're optimizing) and workspace-scoped authorization that replaces Supabase RLS.

Output: Working query functions with server-side authorization for workspace-scoped data access.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-convex-spike/03-RESEARCH.md
@.planning/phases/10-convex-spike/README.md
@convex/schema.ts
@convex/auth.config.ts

# Reference existing Supabase query implementation
@src/app/api/contacts/by-phone/route.ts

# Reference permissions types for role mapping
@src/lib/permissions/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create authorization helpers (lib/auth.ts)</name>
  <files>convex/lib/auth.ts</files>
  <action>
    Create convex/lib/auth.ts with authorization helpers:

    1. Import from "./_generated/server":
       - QueryContext, MutationContext
       - getAuthUserId

    2. Export requireAuthentication():
       ```
       export async function requireAuthentication(
         ctx: QueryContext | MutationContext
       ): Promise<string> {
         const userId = await getAuthUserId(ctx);
         if (!userId) {
           throw new Error("Unauthorized");
         }
         return userId;
       }
       ```

    3. Export requireWorkspaceMembership():
       ```
       export async function requireWorkspaceMembership(
         ctx: QueryContext | MutationContext,
         workspaceId: string
       ): Promise<{ userId: string; membership: Doc<"workspaceMembers"> }> {
         const userId = await getAuthUserId(ctx);
         if (!userId) {
           throw new Error("Unauthorized");
         }

         const membership = await ctx.db
           .query("workspaceMembers")
           .withIndex("by_user_workspace", (q) =>
             q.eq("user_id", userId).eq("workspace_id", workspaceId)
           )
           .first();

         if (!membership) {
           throw new Error("Not a member of this workspace");
         }

         return { userId, membership };
       }
       ```

    Reference: 03-RESEARCH.md "Pattern 4: Authorization Helper"
  </action>
  <verify>
    grep -q "export.*requireWorkspaceMembership" convex/lib/auth.ts
    grep -q "withIndex.*by_user_workspace" convex/lib/auth.ts
  </verify>
  <done>
    lib/auth.ts exists with requireAuthentication and requireWorkspaceMembership helpers
  </done>
</task>

<task type="auto">
  <name>Task 2: Create contact query functions (contacts.ts)</name>
  <files>convex/contacts.ts</files>
  <action>
    Create convex/contacts.ts with query functions:

    1. Import from "./_generated/server" and "convex/values":
       - query, v
       - requireWorkspaceMembership

    2. Export getByPhone query:
       ```
       export const getByPhone = query({
         args: {
           phone: v.string(),
           workspace_id: v.string(),
         },
         handler: async (ctx, args) => {
           await requireWorkspaceMembership(ctx, args.workspace_id);

           const contact = await ctx.db
             .query("contacts")
             .withIndex("by_workspace_phone", (q) =>
               q.eq("workspace_id", args.workspace_id).eq("phone", args.phone)
             )
             .first();

           return contact;
         },
       });
       ```

    3. Export getContextByPhone query (returns CRM context for AI):
       ```
       export const getContextByPhone = query({
         args: {
           phone: v.string(),
           workspace_id: v.string(),
         },
         handler: async (ctx, args) => {
           await requireWorkspaceMembership(ctx, args.workspace_id);

           // Get contact
           const contact = await ctx.db
             .query("contacts")
             .withIndex("by_workspace_phone", (q) =>
               q.eq("workspace_id", args.workspace_id).eq("phone", args.phone)
             )
             .first();

           if (!contact) {
             return { found: false, context: null };
           }

           // Get conversation in parallel with notes
           const [conversation, notes] = await Promise.all([
             ctx.db
               .query("conversations")
               .withIndex("by_contact", (q) => q.eq("contact_id", contact._id))
               .first(),
             ctx.db
               .query("contactNotes")
               .withIndex("by_contact", (q) => q.eq("contact_id", contact._id))
               .take(5),
           ]);

           // Get recent messages if conversation exists
           let recentMessages: any[] = [];
           if (conversation) {
             recentMessages = await ctx.db
               .query("messages")
               .withIndex("by_conversation_time", (q) => q.eq("conversation_id", conversation._id))
               .order("desc")
               .take(10);
           }

           return {
             found: true,
             contact: {
               name: contact.name,
               lead_status: contact.lead_status,
               lead_score: contact.lead_score,
               tags: contact.tags,
               is_returning: !!conversation?.last_message_at,
               first_contact_date: contact.created_at,
             },
             notes: notes.map(n => n.content),
             last_interaction: conversation?.last_message_at || null,
             recent_messages: recentMessages.map(m => ({
               content: m.content,
               direction: m.direction,
               created_at: m.created_at,
             })),
           };
         },
       });
       ```

    Reference: 03-RESEARCH.md "Pattern 3: Query Function"
    Reference: src/app/api/contacts/by-phone/route.ts for CRM context structure
  </action>
  <verify>
    grep -q "export const getByPhone = query" convex/contacts.ts
    grep -q "export const getContextByPhone = query" convex/contacts.ts
    grep -q "withIndex.*by_workspace_phone" convex/contacts.ts
  </verify>
  <done>
    contacts.ts exists with getByPhone and getContextByPhone queries using by_workspace_phone index
  </done>
</task>

<task type="auto">
  <name>Task 3: Create conversation query functions (conversations.ts)</name>
  <files>convex/conversations.ts</files>
  <action>
    Create convex/conversations.ts with query functions:

    1. Import from "./_generated/server" and "convex/values":
       - query, v
       - requireWorkspaceMembership

    2. Export listByWorkspace query:
       ```
       export const listByWorkspace = query({
         args: {
           workspace_id: v.string(),
           limit: v.optional(v.number()),
           status: v.optional(v.string()),
         },
         handler: async (ctx, args) => {
           await requireWorkspaceMembership(ctx, args.workspace_id);

           let q = ctx.db
             .query("conversations")
             .withIndex("by_workspace_time", (q) =>
               q.eq("workspace_id", args.workspace_id)
             )
             .order("desc");

           if (args.status) {
             q = q.filter(q => q.eq(q.field("status"), args.status));
           }

           const limit = args.limit || 50;
           const conversations = await q.take(limit);

           // Fetch contacts in parallel
           const contactIds = conversations.map(c => c.contact_id);
           const contacts = await Promise.all(
             contactIds.map(id => ctx.db.get(id))
           );

           return conversations.map(conv => ({
             ...conv,
             contact: contacts.find(c => c?._id === conv.contact_id) || null,
           }));
         },
       });
       ```

    3. Export getByContact query:
       ```
       export const getByContact = query({
         args: {
           contact_id: v.string(),
           workspace_id: v.string(),
         },
         handler: async (ctx, args) => {
           await requireWorkspaceMembership(ctx, args.workspace_id);

           const conversation = await ctx.db
             .query("conversations")
             .withIndex("by_contact", (q) =>
               q.eq("contact_id", args.contact_id)
             )
             .first();

           return conversation;
         },
       });
       ```

    Reference: 03-RESEARCH.md "Pattern 3: Query Function"
  </action>
  <verify>
    grep -q "export const listByWorkspace = query" convex/conversations.ts
    grep -q "export const getByContact = query" convex/conversations.ts
    grep -q "withIndex.*by_workspace_time" convex/conversations.ts
  </verify>
  <done>
    conversations.ts exists with listByWorkspace and getByContact queries using indexes
  </done>
</task>

</tasks>

<verification>
- convex/lib/auth.ts exists with requireWorkspaceMembership and requireAuthentication
- convex/contacts.ts exists with getByPhone and getContextByPhone queries
- convex/conversations.ts exists with listByWorkspace and getByContact queries
- All queries use requireWorkspaceMembership for authorization
- All queries use indexes (by_workspace_phone, by_workspace_time, by_contact)
</verification>

<success_criteria>
- Authorization helpers implement workspace-scoped access control
- Contact queries use by_workspace_phone index for fast lookup
- Conversation queries use by_workspace_time index for ordered results
- All query functions verify workspace membership before returning data
</success_criteria>

<output>
After completion, create `.planning/phases/10-convex-spike/03-02-SUMMARY.md`
</output>
