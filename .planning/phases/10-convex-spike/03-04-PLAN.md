---
phase: 03-convex-spike
plan: 04
type: execute
wave: 3
depends_on: ["03-02"]
files_modified: [convex/http/contacts.ts, src/app/api/contacts/by-phone-convex/route.ts]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Convex HTTP action accepts CRM_API_KEY for authentication"
    - "HTTP action accepts phone and workspace_id query params"
    - "Next.js API route proxies to Convex HTTP endpoint"
    - "Endpoint returns same structure as Supabase version"
  artifacts:
    - path: "convex/http/contacts.ts"
      provides: "HTTP actions for external API access"
      exports: ["http"]
    - path: "src/app/api/contacts/by-phone-convex/route.ts"
      provides: "Next.js API route using Convex"
  key_links:
    - from: "convex/http/contacts.ts"
      to: "convex/contacts.ts"
      via: "getContextByPhone query"
      pattern: "api.contacts.getContextByPhone"
    - from: "src/app/api/contacts/by-phone-convex/route.ts"
      to: "convex/http/contacts.ts"
      via: "HTTP proxy"
      pattern: "fetch.*convex.*http"
---

<objective>
Implement Convex HTTP actions for contact lookup and create Next.js API route using Convex.

Purpose: Create the endpoint that benchmark will measure - /api/contacts/by-phone-convex - which is identical functionality to the current Supabase version but uses Convex for data retrieval. This enables head-to-head performance comparison.

Output: Working HTTP action for contact lookup and Next.js API route that proxies to it.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-convex-spike/03-RESEARCH.md
@.planning/phases/10-convex-spike/README.md
@convex/schema.ts
@convex/contacts.ts

# Reference existing Supabase endpoint structure
@src/app/api/contacts/by-phone/route.ts

# Reference convex-test.html for HTTP pattern
@convex-test.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HTTP action for contact lookup (http/contacts.ts)</name>
  <files>convex/http/contacts.ts</files>
  <action>
    Create convex/http/contacts.ts with HTTP action:

    1. Import from "convex/server":
       - httpRouter, httpAction
       - fetchAction (if needed)

    2. Import from "./_generated/server":
       - api (for calling internal queries)

    3. Define environment variables for CRM_API_KEY verification:
       - Check process.env.CRM_API_KEY exists

    4. Create httpRouter:
       ```
       const http = httpRouter();
       ```

    5. Add route for /webhook/kapso:
       ```
       http.route({
         path: "/webhook/kapso",
         method: "POST",
         handler: httpAction(async (ctx, request) => {
           // Verify API key for internal use
           const apiKey = request.headers.get("x-api-key");
           if (apiKey !== process.env.CRM_API_KEY) {
             return new Response("Unauthorized", { status: 401 });
           }

           const body = await request.json();

           // Process webhook (placeholder for spike)
           // In full implementation: create/update conversation, messages

           // Respond immediately to prevent retries
           return new Response(JSON.stringify({ received: true }), {
             status: 200,
             headers: { "Content-Type": "application/json" },
           });
         }),
       });
       ```

    6. Add route for /http/contacts/getByPhone (matching convex-test.html pattern):
       ```
       http.route({
         path: "/http/contacts/getByPhone",
         method: "GET",
         handler: httpAction(async (ctx, request) => {
           // Verify API key
           const apiKey = request.headers.get("x-api-key");
           if (apiKey !== process.env.CRM_API_KEY) {
             return new Response(
               JSON.stringify({ found: false, error: "Unauthorized" }),
               { status: 401, headers: { "Content-Type": "application/json" } }
             );
           }

           // Get query parameters
           const url = new URL(request.url);
           const phone = url.searchParams.get("phone");
           const workspace_id = url.searchParams.get("workspace_id");

           if (!phone || !workspace_id) {
             return new Response(
               JSON.stringify({ found: false, error: "Missing parameters" }),
               { status: 400, headers: { "Content-Type": "application/json" } }
             );
           }

           // Call getContextByPhone query
           const result = await ctx.runQuery(
             api.contacts.getContextByPhone,
             { phone, workspace_id }
           );

           return new Response(JSON.stringify(result), {
             status: 200,
             headers: { "Content-Type": "application/json" },
           });
         }),
       });
       ```

    7. Export default http router:
       ```
       export default http;
       ```

    Reference: 03-RESEARCH.md "Pattern 5: HTTP Action for Webhook"
    Reference: convex-test.html for HTTP endpoint pattern (/http/contacts/getByPhone)

    NOTE: For the spike, we use CRM_API_KEY for auth. In production with Supabase JWT auth,
    we'd use the JWT token instead. The spike uses API key to enable headless testing.
  </action>
  <verify>
    grep -q "http.route" convex/http/contacts.ts
    grep -q "/http/contacts/getByPhone" convex/http/contacts.ts
    grep -q "getContextByPhone" convex/http/contacts.ts
  </verify>
  <done>
    http/contacts.ts exists with getByPhone HTTP action, accepts CRM_API_KEY, calls getContextByPhone query
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Next.js API route using Convex</name>
  <files>src/app/api/contacts/by-phone-convex/route.ts</files>
  <action>
    Create src/app/api/contacts/by-phone-convex/route.ts:

    This route proxies to Convex HTTP endpoint, maintaining identical interface to Supabase version.

    1. Import from "convex/server":
       - fetchAction, fetchQuery

    2. Import "./_generated/api":
       - api

    3. Import from "@/lib/instrumentation/with-timing":
       - withTiming, createRequestMetrics, logQuerySummary

    4. Define handler:
       ```
       async function getHandler(request: NextRequest) {
         try {
           // Verify API key
           const apiKey = request.headers.get('x-api-key');
           const expectedKey = process.env.CRM_API_KEY;

           if (!expectedKey) {
             console.error('[ContactLookupConvex] CRM_API_KEY not configured');
             return NextResponse.json(
               { error: 'Service not configured' },
               { status: 500 }
             );
           }

           if (apiKey !== expectedKey) {
             return NextResponse.json(
               { error: 'Unauthorized' },
               { status: 401 }
             );
           }

           // Get query parameters
           const { searchParams } = new URL(request.url);
           const phone = searchParams.get('phone');
           const workspaceId = searchParams.get('workspace_id');

           if (!phone || !workspaceId) {
             return NextResponse.json(
               { error: 'Missing phone or workspace_id parameter' },
               { status: 400 }
             );
           }

           // Call Convex query
           const metrics = createRequestMetrics();
           const queryStart = performance.now();

           const result = await fetchQuery(
             api.contacts.getContextByPhone,
             { phone, workspace_id: workspaceId }
           );

           const queryTime = Math.round(performance.now() - queryStart);
           logQuerySummary('/api/contacts/by-phone-convex', {
             ...metrics,
             queries: [{ name: 'convex.contacts.getContextByPhone', duration: queryTime }],
           });

           return NextResponse.json(result);
         } catch (error) {
           console.error('[ContactLookupConvex] Error:', error);
           return NextResponse.json(
             { error: 'Internal server error' },
             { status: 500 }
           );
         }
       }
       ```

    5. Export wrapped handler:
       ```
       export const GET = withTiming('/api/contacts/by-phone-convex', getHandler);
       ```

    This maintains identical interface to src/app/api/contacts/by-phone/route.ts:
    - Same query parameters: phone, workspace_id
    - Same response structure: { found, contact, notes, conversation_summary, last_interaction }
    - Same authentication: x-api-key header
    - Same timing instrumentation for fair comparison

    Reference: src/app/api/contacts/by-phone/route.ts for interface
  </action>
  <verify>
    grep -q "getContextByPhone" src/app/api/contacts/by-phone-convex/route.ts
    grep -q "export const GET = withTiming" src/app/api/contacts/by-phone-convex/route.ts
  </verify>
  <done>
    by-phone-convex route exists, calls Convex getContextByPhone, maintains same interface as Supabase version
  </done>
</task>

</tasks>

<verification>
- convex/http/contacts.ts exists with getByPhone HTTP action
- HTTP action verifies CRM_API_KEY
- HTTP action calls getContextByPhone query
- Next.js API route proxies to Convex with timing instrumentation
- Response structure matches Supabase version
</verification>

<success_criteria>
- Convex HTTP action accepts CRM_API_KEY for authentication
- HTTP action accepts phone and workspace_id query params
- Next.js API route proxies to Convex HTTP endpoint
- Endpoint returns same structure as Supabase version
</success_criteria>

<output>
After completion, create `.planning/phases/10-convex-spike/03-04-SUMMARY.md`
</output>
