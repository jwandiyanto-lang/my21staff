---
phase: 03-users-table-webhook
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/users.ts
autonomous: true

must_haves:
  truths:
    - "Users table exists in Convex schema"
    - "Webhook audit table exists for debugging"
    - "User mutations are available for webhook to call"
  artifacts:
    - path: "convex/schema.ts"
      provides: "users and webhookAudit table definitions"
      contains: "users: defineTable"
    - path: "convex/users.ts"
      provides: "User CRUD mutations for webhook"
      exports: ["createUser", "updateUser", "deleteUser", "getUserByClerkId"]
  key_links:
    - from: "convex/users.ts"
      to: "convex/schema.ts"
      via: "schema types"
      pattern: "v\\.id\\(\"users\"\\)"
---

<objective>
Create the users table in Convex schema and user mutations for the Clerk webhook to call.

Purpose: Establish the data layer for storing user information synced from Clerk, enabling efficient user queries without hitting the Clerk API.

Output: Convex schema with users + webhookAudit tables, users.ts with CRUD mutations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-users-table-webhook/03-CONTEXT.md

@convex/schema.ts
@convex/tickets.ts (pattern reference for mutations)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add users and webhookAudit tables to schema</name>
  <files>convex/schema.ts</files>
  <action>
Add two new tables to the Convex schema:

**users table:**
```typescript
users: defineTable({
  clerk_id: v.string(),           // Primary identifier from Clerk
  workspace_id: v.optional(v.id("workspaces")), // Single workspace (optional for initial sync)
  created_at: v.number(),
  updated_at: v.number(),
})
  .index("by_clerk_id", ["clerk_id"])
  .index("by_workspace", ["workspace_id"]),
```

**webhookAudit table:** (for debugging webhook events)
```typescript
webhookAudit: defineTable({
  event_type: v.string(),         // 'user.created', 'user.updated', 'user.deleted'
  clerk_id: v.optional(v.string()),
  payload: v.any(),               // Raw webhook payload (for debugging)
  status: v.string(),             // 'success', 'error'
  error_message: v.optional(v.string()),
  processed_at: v.number(),
})
  .index("by_event_type", ["event_type"])
  .index("by_clerk_id", ["clerk_id"])
  .index("by_processed_at", ["processed_at"]),
```

Place these after the existing ticketStatusHistory table, before the closing of defineSchema.

Note: Following existing convention of snake_case field names (from v3.0 decision).
  </action>
  <verify>Run `npx convex dev --once` and confirm no schema errors</verify>
  <done>Schema includes users and webhookAudit tables with proper indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create users.ts with CRUD mutations</name>
  <files>convex/users.ts</files>
  <action>
Create convex/users.ts with mutations for the Clerk webhook to call:

```typescript
import { v } from "convex/values";
import { mutation, query, internalMutation } from "./_generated/server";

// ============================================
// QUERIES
// ============================================

export const getUserByClerkId = query({
  args: { clerk_id: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerk_id", args.clerk_id))
      .unique();
  },
});

// ============================================
// INTERNAL MUTATIONS (called by webhook)
// ============================================

export const createUser = internalMutation({
  args: {
    clerk_id: v.string(),
    workspace_id: v.optional(v.id("workspaces")),
  },
  handler: async (ctx, args) => {
    const now = Date.now();

    // Check if user already exists (idempotent)
    const existing = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerk_id", args.clerk_id))
      .unique();

    if (existing) {
      console.log(`[Users] User ${args.clerk_id} already exists, skipping create`);
      return existing._id;
    }

    const userId = await ctx.db.insert("users", {
      clerk_id: args.clerk_id,
      workspace_id: args.workspace_id,
      created_at: now,
      updated_at: now,
    });

    console.log(`[Users] Created user ${args.clerk_id}`);
    return userId;
  },
});

export const updateUser = internalMutation({
  args: {
    clerk_id: v.string(),
    workspace_id: v.optional(v.id("workspaces")),
  },
  handler: async (ctx, args) => {
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerk_id", args.clerk_id))
      .unique();

    if (!user) {
      console.log(`[Users] User ${args.clerk_id} not found for update, creating instead`);
      // Create if doesn't exist (handles webhook ordering issues)
      return await ctx.db.insert("users", {
        clerk_id: args.clerk_id,
        workspace_id: args.workspace_id,
        created_at: Date.now(),
        updated_at: Date.now(),
      });
    }

    await ctx.db.patch(user._id, {
      workspace_id: args.workspace_id ?? user.workspace_id,
      updated_at: Date.now(),
    });

    console.log(`[Users] Updated user ${args.clerk_id}`);
    return user._id;
  },
});

export const deleteUser = internalMutation({
  args: { clerk_id: v.string() },
  handler: async (ctx, args) => {
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerk_id", args.clerk_id))
      .unique();

    if (!user) {
      console.log(`[Users] User ${args.clerk_id} not found for deletion`);
      return null;
    }

    await ctx.db.delete(user._id);
    console.log(`[Users] Deleted user ${args.clerk_id}`);
    return user._id;
  },
});

// ============================================
// WEBHOOK AUDIT (called by webhook)
// ============================================

export const logWebhookEvent = internalMutation({
  args: {
    event_type: v.string(),
    clerk_id: v.optional(v.string()),
    payload: v.any(),
    status: v.string(),
    error_message: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("webhookAudit", {
      event_type: args.event_type,
      clerk_id: args.clerk_id,
      payload: args.payload,
      status: args.status,
      error_message: args.error_message,
      processed_at: Date.now(),
    });
  },
});
```

Notes:
- Use internalMutation for webhook-called functions (not exposed in public API)
- Query is public (getUserByClerkId) for app to fetch user data
- Idempotent operations handle webhook retries gracefully
  </action>
  <verify>Run `npx convex dev --once` and confirm functions are generated in convex/_generated/api.d.ts</verify>
  <done>convex/users.ts exists with createUser, updateUser, deleteUser, getUserByClerkId, logWebhookEvent functions</done>
</task>

</tasks>

<verification>
1. `npx convex dev --once` succeeds without errors
2. `convex/_generated/api.d.ts` contains `users` namespace with exported functions
3. Schema shows users and webhookAudit tables
</verification>

<success_criteria>
- Users table in schema with clerk_id index
- WebhookAudit table in schema for debugging
- User mutations ready for webhook to call
- All functions use internalMutation (except getUserByClerkId query)
</success_criteria>

<output>
After completion, create `.planning/phases/03-users-table-webhook/03-01-SUMMARY.md`
</output>
