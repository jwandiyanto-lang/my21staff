---
phase: v3.2-01
plan: "05"
type: execute
wave: 3
depends_on: ["02"]
files_modified:
  - src/app/(dashboard)/[workspace]/database/merge-contacts-dialog.tsx
  - src/app/(dashboard)/[workspace]/database/database-client.tsx
  - src/app/api/contacts/merge/route.ts
  - convex/contacts.ts
autonomous: true

must_haves:
  truths:
    - "Merge button available for duplicate contacts"
    - "Popup shows both profiles side-by-side"
    - "User picks each field (always ask, no auto-selection)"
    - "After merge: delete duplicate, log action in Notes as history"
  artifacts:
    - path: "src/app/(dashboard)/[workspace]/database/merge-contacts-dialog.tsx"
      provides: "Side-by-side merge dialog component"
      contains: "Dialog"
    - path: "src/app/api/contacts/merge/route.ts"
      provides: "Merge contacts API endpoint"
      exports: ["POST"]
    - path: "convex/contacts.ts"
      provides: "mergeContacts mutation"
      contains: "mergeContacts"
  key_links:
    - from: "src/app/(dashboard)/[workspace]/database/merge-contacts-dialog.tsx"
      to: "/api/contacts/merge"
      via: "fetch POST"
      pattern: "fetch.*api/contacts/merge"
    - from: "src/app/api/contacts/merge/route.ts"
      to: "api.contacts.mergeContacts"
      via: "Convex mutation"
      pattern: "convex\\.mutation.*mergeContacts"
---

<objective>
Implement contact merge functionality for handling duplicate leads.

Purpose: Per CONTEXT.md - user needs to merge duplicate contacts with full control over which fields to keep
Output: Merge dialog with side-by-side comparison, field-by-field selection, and merge history in Notes
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v3.2-01-supabase-deletion-database/01-CONTEXT.md
@.planning/phases/v3.2-01-supabase-deletion-database/01-RESEARCH.md
@.planning/phases/v3.2-01-supabase-deletion-database/01-02-SUMMARY.md
@src/app/(dashboard)/[workspace]/database/database-client.tsx
@convex/contacts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create merge contacts dialog component</name>
  <files>src/app/(dashboard)/[workspace]/database/merge-contacts-dialog.tsx</files>
  <action>
Create a new merge dialog component that shows two contacts side-by-side.

**Component structure:**

```typescript
'use client'

import { useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group'
import { Label } from '@/components/ui/label'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { toast } from 'sonner'

interface Contact {
  id: string
  name?: string
  email?: string
  phone?: string
  status?: string
  tags?: string[]
  assigned_to?: string
  lead_score?: number
  metadata?: Record<string, any>
}

interface MergeContactsDialogProps {
  contact1: Contact
  contact2: Contact
  open: boolean
  onOpenChange: (open: boolean) => void
  onMergeComplete?: () => void
}

// Fields that can be merged
const MERGE_FIELDS = [
  { key: 'name', label: 'Name' },
  { key: 'email', label: 'Email' },
  { key: 'phone', label: 'Phone' },
  { key: 'status', label: 'Status' },
  { key: 'assigned_to', label: 'Assigned To' },
  { key: 'lead_score', label: 'Lead Score' },
] as const

export function MergeContactsDialog({
  contact1,
  contact2,
  open,
  onOpenChange,
  onMergeComplete,
}: MergeContactsDialogProps) {
  // Track which contact's value to use for each field
  // Initial state: no pre-selection (user must choose each field)
  const [selections, setSelections] = useState<Record<string, '1' | '2'>>({})

  const queryClient = useQueryClient()

  const mergeMutation = useMutation({
    mutationFn: async (data: { primaryId: string; secondaryId: string; fields: Record<string, any> }) => {
      const res = await fetch('/api/contacts/merge', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      })
      if (!res.ok) throw new Error('Merge failed')
      return res.json()
    },
    onSuccess: () => {
      toast.success('Contacts merged successfully')
      queryClient.invalidateQueries({ queryKey: ['contacts'] })
      onOpenChange(false)
      onMergeComplete?.()
    },
    onError: () => {
      toast.error('Failed to merge contacts')
    },
  })

  const handleMerge = () => {
    // Ensure all fields have selections
    const unselectedFields = MERGE_FIELDS.filter(f => !selections[f.key])
    if (unselectedFields.length > 0) {
      toast.error(`Please select a value for: ${unselectedFields.map(f => f.label).join(', ')}`)
      return
    }

    // Build merged contact data
    const mergedFields: Record<string, any> = {}
    for (const field of MERGE_FIELDS) {
      const source = selections[field.key] === '1' ? contact1 : contact2
      mergedFields[field.key] = source[field.key as keyof Contact]
    }

    // Merge tags (combine both)
    mergedFields.tags = [...new Set([...(contact1.tags || []), ...(contact2.tags || [])])]

    // Merge metadata (combine both, contact1 takes precedence)
    mergedFields.metadata = { ...(contact2.metadata || {}), ...(contact1.metadata || {}) }

    mergeMutation.mutate({
      primaryId: contact1.id,
      secondaryId: contact2.id,
      fields: mergedFields,
    })
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl max-h-[85vh] overflow-auto">
        <DialogHeader>
          <DialogTitle>Merge Contacts</DialogTitle>
          <p className="text-sm text-muted-foreground">
            Select which value to keep for each field. The second contact will be deleted after merge.
          </p>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {MERGE_FIELDS.map((field) => (
            <div key={field.key} className="grid grid-cols-[120px_1fr] gap-4 items-start">
              <Label className="font-medium pt-2">{field.label}</Label>
              <RadioGroup
                value={selections[field.key]}
                onValueChange={(value) => setSelections(prev => ({ ...prev, [field.key]: value as '1' | '2' }))}
                className="grid grid-cols-2 gap-4"
              >
                <div className="flex items-center space-x-2 p-3 border rounded-lg hover:bg-muted/50">
                  <RadioGroupItem value="1" id={`${field.key}-1`} />
                  <Label htmlFor={`${field.key}-1`} className="flex-1 cursor-pointer">
                    {String(contact1[field.key as keyof Contact] || '(empty)')}
                  </Label>
                </div>
                <div className="flex items-center space-x-2 p-3 border rounded-lg hover:bg-muted/50">
                  <RadioGroupItem value="2" id={`${field.key}-2`} />
                  <Label htmlFor={`${field.key}-2`} className="flex-1 cursor-pointer">
                    {String(contact2[field.key as keyof Contact] || '(empty)')}
                  </Label>
                </div>
              </RadioGroup>
            </div>
          ))}

          {/* Tags - auto-combined */}
          <div className="grid grid-cols-[120px_1fr] gap-4 items-start">
            <Label className="font-medium pt-2">Tags</Label>
            <div className="p-3 border rounded-lg bg-muted/30">
              <p className="text-sm text-muted-foreground mb-1">Will combine tags from both:</p>
              <div className="flex flex-wrap gap-1">
                {[...new Set([...(contact1.tags || []), ...(contact2.tags || [])])].map(tag => (
                  <span key={tag} className="px-2 py-0.5 bg-primary/10 rounded text-xs">{tag}</span>
                ))}
              </div>
            </div>
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button onClick={handleMerge} disabled={mergeMutation.isPending}>
            {mergeMutation.isPending ? 'Merging...' : 'Merge Contacts'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

**Key requirements from CONTEXT.md:**
- Side-by-side comparison (both profiles visible)
- User picks EACH field (no auto-selection - user must explicitly choose)
- Tags are combined automatically (shown to user)
- Metadata combined automatically
  </action>
  <verify>
1. File exists at src/app/(dashboard)/[workspace]/database/merge-contacts-dialog.tsx
2. Component uses Dialog from shadcn/ui
3. RadioGroup for field selection
4. No pre-selected values (user must choose each)
  </verify>
  <done>
MergeContactsDialog component created with side-by-side field selection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create merge API endpoint and Convex mutation</name>
  <files>
src/app/api/contacts/merge/route.ts
convex/contacts.ts
  </files>
  <action>
**1. Create the API route:**

```typescript
// src/app/api/contacts/merge/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
import { ConvexHttpClient } from 'convex/browser'
import { api } from 'convex/_generated/api'

const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!)

export async function POST(request: NextRequest) {
  const { userId } = await auth()
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const body = await request.json()
  const { primaryId, secondaryId, fields } = body

  if (!primaryId || !secondaryId || !fields) {
    return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })
  }

  try {
    const result = await convex.mutation(api.contacts.mergeContacts, {
      primaryId: primaryId as any,
      secondaryId: secondaryId as any,
      mergedFields: fields,
      mergedBy: userId,
    })

    return NextResponse.json({ success: true, contact: result })
  } catch (error) {
    console.error('Merge failed:', error)
    return NextResponse.json({ error: 'Merge failed' }, { status: 500 })
  }
}
```

**2. Add mergeContacts mutation to convex/contacts.ts:**

First check existing structure, then add:

```typescript
// Add this mutation to convex/contacts.ts

export const mergeContacts = mutation({
  args: {
    primaryId: v.id('contacts'),
    secondaryId: v.id('contacts'),
    mergedFields: v.object({
      name: v.optional(v.string()),
      email: v.optional(v.string()),
      phone: v.optional(v.string()),
      status: v.optional(v.string()),
      assigned_to: v.optional(v.string()),
      lead_score: v.optional(v.number()),
      tags: v.optional(v.array(v.string())),
      metadata: v.optional(v.any()),
    }),
    mergedBy: v.string(),
  },
  handler: async (ctx, args) => {
    // Get both contacts
    const primary = await ctx.db.get(args.primaryId)
    const secondary = await ctx.db.get(args.secondaryId)

    if (!primary || !secondary) {
      throw new Error('Contact not found')
    }

    // Update primary contact with merged fields
    await ctx.db.patch(args.primaryId, {
      name: args.mergedFields.name,
      email: args.mergedFields.email,
      phone: args.mergedFields.phone,
      status: args.mergedFields.status,
      assigned_to: args.mergedFields.assigned_to,
      lead_score: args.mergedFields.lead_score,
      tags: args.mergedFields.tags,
      metadata: args.mergedFields.metadata,
      updated_at: Date.now(),
    })

    // Create merge history note
    const mergeNote = `Merged with duplicate contact. Previous values from deleted contact:\n` +
      `- Name: ${secondary.name || 'N/A'}\n` +
      `- Email: ${secondary.email || 'N/A'}\n` +
      `- Phone: ${secondary.phone || 'N/A'}\n` +
      `- Status: ${secondary.status || 'N/A'}`

    // Add note to primary contact (check if contactNotes table exists)
    // If contactNotes mutation exists, use it; otherwise add to contact metadata
    try {
      await ctx.db.insert('contactNotes', {
        contact_id: args.primaryId,
        content: mergeNote,
        user_id: args.mergedBy,
        created_at: Date.now(),
        type: 'system',
      })
    } catch {
      // Fallback: add to metadata if notes table doesn't exist
      const existingNotes = (primary.metadata?.notes as string[]) || []
      await ctx.db.patch(args.primaryId, {
        metadata: {
          ...primary.metadata,
          notes: [...existingNotes, mergeNote],
          merged_from: secondary._id,
          merged_at: Date.now(),
        },
      })
    }

    // Delete the secondary (duplicate) contact
    await ctx.db.delete(args.secondaryId)

    // Return updated primary contact
    return await ctx.db.get(args.primaryId)
  },
})
```
  </action>
  <verify>
1. API route exists at src/app/api/contacts/merge/route.ts
2. convex/contacts.ts has mergeContacts mutation
3. `npx convex dev` runs without errors (or `npx convex deploy` if in prod)
4. `npx tsc --noEmit` - no TypeScript errors
  </verify>
  <done>
Merge API endpoint and Convex mutation created. Merge logs history in Notes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add merge button to database client</name>
  <files>src/app/(dashboard)/[workspace]/database/database-client.tsx</files>
  <action>
Update database-client.tsx to include merge functionality:

1. **Import the merge dialog:**
```typescript
import { MergeContactsDialog } from './merge-contacts-dialog'
```

2. **Add state for merge mode:**
```typescript
const [mergeMode, setMergeMode] = useState(false)
const [selectedForMerge, setSelectedForMerge] = useState<Contact[]>([])
const [showMergeDialog, setShowMergeDialog] = useState(false)
```

3. **Add merge button to toolbar (near other action buttons):**
```typescript
{/* In the toolbar/header area */}
<Button
  variant={mergeMode ? "secondary" : "outline"}
  size="sm"
  onClick={() => {
    if (mergeMode) {
      // Cancel merge mode
      setMergeMode(false)
      setSelectedForMerge([])
    } else {
      setMergeMode(true)
    }
  }}
>
  {mergeMode ? 'Cancel Merge' : 'Merge Duplicates'}
</Button>

{mergeMode && selectedForMerge.length === 2 && (
  <Button
    size="sm"
    onClick={() => setShowMergeDialog(true)}
  >
    Merge Selected ({selectedForMerge.length})
  </Button>
)}
```

4. **Add selection handler for merge mode:**
When in merge mode, clicking a row adds/removes from selectedForMerge (max 2):
```typescript
const handleRowClick = (contact: Contact) => {
  if (mergeMode) {
    setSelectedForMerge(prev => {
      const isSelected = prev.some(c => c.id === contact.id)
      if (isSelected) {
        return prev.filter(c => c.id !== contact.id)
      } else if (prev.length < 2) {
        return [...prev, contact]
      }
      return prev
    })
  } else {
    // Normal behavior - open detail dialog
    setSelectedContact(contact)
    setDetailOpen(true)
  }
}
```

5. **Render the merge dialog:**
```typescript
{showMergeDialog && selectedForMerge.length === 2 && (
  <MergeContactsDialog
    contact1={selectedForMerge[0]}
    contact2={selectedForMerge[1]}
    open={showMergeDialog}
    onOpenChange={setShowMergeDialog}
    onMergeComplete={() => {
      setMergeMode(false)
      setSelectedForMerge([])
    }}
  />
)}
```

6. **Visual indication for merge mode:**
- Add highlight/border to selected rows
- Show instruction text when in merge mode: "Select 2 contacts to merge"
  </action>
  <verify>
1. Merge button appears in database toolbar
2. Clicking button enables merge mode
3. Can select exactly 2 contacts in merge mode
4. "Merge Selected" button appears with 2 selected
5. Dialog opens with side-by-side comparison
  </verify>
  <done>
Merge functionality integrated into database client. Users can select and merge duplicate contacts.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. Merge button visible in Contact Database toolbar
3. Can enter merge mode and select 2 contacts
4. Merge dialog shows side-by-side comparison
5. User must select each field (no pre-selection)
6. After merge: one contact deleted, history logged in Notes
</verification>

<success_criteria>
- Merge button available in Contact Database
- Side-by-side popup shows both profiles
- User picks each field (no auto-selection per CONTEXT.md)
- After merge: duplicate deleted, action logged in Notes
- Tags combined from both contacts
- Zero Supabase imports
</success_criteria>

<output>
After completion, create `.planning/phases/v3.2-01-supabase-deletion-database/01-05-SUMMARY.md`
</output>
