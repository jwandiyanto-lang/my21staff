---
phase: 03-sarah-chat-bot
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/sarah.ts
  - convex/schema.ts
autonomous: true

must_haves:
  truths:
    - "Convex stores conversation state for dashboard display"
    - "Sarah conversation data can be queried from Convex"
    - "Lead scores persist in Convex for dashboard analytics"
  artifacts:
    - path: "convex/sarah.ts"
      provides: "Convex functions for Sarah state storage"
      exports: ["getSarahConversation", "upsertSarahState", "getSarahLeads"]
    - path: "convex/schema.ts"
      provides: "Sarah conversation schema (or uses existing ariConversations)"
      contains: "sarahConversations"
  key_links:
    - from: "Kapso Function node"
      to: "convex/sarah.ts"
      via: "Convex HTTP endpoint"
      pattern: "https://.*convex.cloud/api"
---

<objective>
Create Convex schema and mutations for storing Sarah conversation state (called from Kapso Function nodes).

Purpose: This plan sets up the data storage layer. Kapso workflow will call Convex HTTP endpoints to save/retrieve conversation state. This enables the dashboard to display lead data, scores, and conversation history.

Output:
- Convex schema for Sarah conversations
- HTTP endpoints for Kapso to call (upsert state, get state)
- Query functions for dashboard to display leads
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-sarah-chat-bot/03-CONTEXT.md
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create/extend Convex schema for Sarah conversations</name>
  <files>convex/schema.ts</files>
  <action>
Check if ariConversations table exists. If yes, extend it. If no, create sarahConversations table.

**Option A: Extend existing ariConversations**
If ariConversations exists, ensure it has these fields:
```typescript
// Fields needed for Sarah:
state: v.string(), // 'greeting' | 'qualifying' | 'scoring' | 'handoff' | 'completed'
lead_score: v.number(), // 0-100
lead_temperature: v.string(), // 'hot' | 'warm' | 'cold'
language: v.string(), // 'id' | 'en'
extracted_data: v.object({
  name: v.optional(v.string()),
  business_type: v.optional(v.string()),
  team_size: v.optional(v.number()),
  pain_points: v.optional(v.array(v.string())),
  goals: v.optional(v.string()),
}),
message_count: v.number(),
last_message_at: v.number(), // timestamp
```

**Option B: Create sarahConversations table**
If ariConversations doesn't exist or is unsuitable:
```typescript
sarahConversations: defineTable({
  contact_phone: v.string(), // Primary identifier
  workspace_id: v.optional(v.string()),

  // State machine
  state: v.string(),

  // Scoring
  lead_score: v.number(),
  lead_temperature: v.string(),

  // Extracted data
  extracted_data: v.object({
    name: v.optional(v.string()),
    business_type: v.optional(v.string()),
    team_size: v.optional(v.number()),
    pain_points: v.optional(v.array(v.string())),
    goals: v.optional(v.string()),
  }),

  // Metadata
  language: v.string(),
  message_count: v.number(),

  // Timestamps
  created_at: v.number(),
  updated_at: v.number(),
  last_message_at: v.number(),
})
  .index("by_phone", ["contact_phone"])
  .index("by_temperature", ["lead_temperature"])
  .index("by_score", ["lead_score"]),
```

Choose the option that fits the existing schema best. The goal is minimal schema changes.
  </action>
  <verify>
Run `npx convex dev` - schema deploys without errors
Table (ariConversations or sarahConversations) has all required fields
  </verify>
  <done>
Convex schema supports Sarah conversation state storage
Indexes enable efficient queries by phone, temperature, score
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Convex HTTP functions for Kapso to call</name>
  <files>convex/sarah.ts</files>
  <action>
Create HTTP endpoints that Kapso Function nodes can call:

**1. upsertSarahState** - httpAction (POST)
Called by Kapso after each message to save state:

```typescript
import { httpAction } from "./_generated/server";
import { v } from "convex/values";

export const upsertSarahState = httpAction(async (ctx, request) => {
  const body = await request.json();
  const {
    contact_phone,
    state,
    lead_score,
    lead_temperature,
    extracted_data,
    language,
    message_count,
  } = body;

  // Validate required fields
  if (!contact_phone) {
    return new Response(JSON.stringify({ error: "contact_phone required" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // Upsert logic: find existing or create new
  const existing = await ctx.runQuery(internal.sarah.getByPhone, { contact_phone });

  const now = Date.now();
  const data = {
    contact_phone,
    state: state || "greeting",
    lead_score: lead_score || 0,
    lead_temperature: lead_temperature || "cold",
    extracted_data: extracted_data || {},
    language: language || "id",
    message_count: message_count || 0,
    updated_at: now,
    last_message_at: now,
  };

  if (existing) {
    await ctx.runMutation(internal.sarah.update, { id: existing._id, ...data });
  } else {
    await ctx.runMutation(internal.sarah.create, { ...data, created_at: now });
  }

  return new Response(JSON.stringify({ success: true }), {
    status: 200,
    headers: { "Content-Type": "application/json" },
  });
});
```

**2. getSarahState** - httpAction (GET)
Called by Kapso to retrieve current state before processing:

```typescript
export const getSarahState = httpAction(async (ctx, request) => {
  const url = new URL(request.url);
  const contact_phone = url.searchParams.get("contact_phone");

  if (!contact_phone) {
    return new Response(JSON.stringify({ error: "contact_phone required" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  const conversation = await ctx.runQuery(internal.sarah.getByPhone, { contact_phone });

  if (!conversation) {
    // Return default state for new conversation
    return new Response(JSON.stringify({
      state: "greeting",
      lead_score: 0,
      lead_temperature: "cold",
      extracted_data: {},
      language: "id",
      message_count: 0,
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  }

  return new Response(JSON.stringify(conversation), {
    status: 200,
    headers: { "Content-Type": "application/json" },
  });
});
```

**3. Internal queries/mutations** (used by HTTP actions above):

```typescript
export const getByPhone = internalQuery({
  args: { contact_phone: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("sarahConversations") // or ariConversations
      .withIndex("by_phone", (q) => q.eq("contact_phone", args.contact_phone))
      .first();
  },
});

export const create = internalMutation({
  args: { /* all fields */ },
  handler: async (ctx, args) => {
    return await ctx.db.insert("sarahConversations", args);
  },
});

export const update = internalMutation({
  args: { id: v.id("sarahConversations"), /* other fields */ },
  handler: async (ctx, args) => {
    const { id, ...data } = args;
    await ctx.db.patch(id, data);
  },
});
```

**4. Register HTTP routes** in convex/http.ts:

```typescript
import { getSarahState, upsertSarahState } from "./sarah";

http.route({
  path: "/sarah/state",
  method: "GET",
  handler: getSarahState,
});

http.route({
  path: "/sarah/state",
  method: "POST",
  handler: upsertSarahState,
});
```
  </action>
  <verify>
Run `npx convex dev` - no errors
Test GET: `curl https://[deployment].convex.cloud/sarah/state?contact_phone=+62123`
Test POST: `curl -X POST https://[deployment].convex.cloud/sarah/state -d '{"contact_phone":"+62123","state":"greeting"}'`
  </verify>
  <done>
Convex HTTP endpoints ready for Kapso to call
GET /sarah/state retrieves conversation state
POST /sarah/state upserts conversation state
  </done>
</task>

<task type="auto">
  <name>Task 3: Create dashboard query functions</name>
  <files>convex/sarah.ts</files>
  <action>
Add query functions for dashboard to display Sarah leads:

**1. getSarahLeads** - For lead list view:
```typescript
export const getSarahLeads = query({
  args: {
    temperature: v.optional(v.string()), // filter by hot/warm/cold
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    let q = ctx.db.query("sarahConversations");

    if (args.temperature) {
      q = q.withIndex("by_temperature", (q) =>
        q.eq("lead_temperature", args.temperature)
      );
    }

    const results = await q
      .order("desc") // Most recent first
      .take(args.limit || 50);

    return results;
  },
});
```

**2. getSarahStats** - For dashboard analytics:
```typescript
export const getSarahStats = query({
  handler: async (ctx) => {
    const all = await ctx.db.query("sarahConversations").collect();

    const hot = all.filter(c => c.lead_temperature === "hot").length;
    const warm = all.filter(c => c.lead_temperature === "warm").length;
    const cold = all.filter(c => c.lead_temperature === "cold").length;

    const avgScore = all.length > 0
      ? all.reduce((sum, c) => sum + c.lead_score, 0) / all.length
      : 0;

    return {
      total: all.length,
      hot,
      warm,
      cold,
      avgScore: Math.round(avgScore),
    };
  },
});
```

**3. getSarahConversation** - For lead detail view:
```typescript
export const getSarahConversation = query({
  args: { contact_phone: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("sarahConversations")
      .withIndex("by_phone", (q) => q.eq("contact_phone", args.contact_phone))
      .first();
  },
});
```
  </action>
  <verify>
Run `npx convex dev` - no errors
Functions appear in Convex dashboard
Can call getSarahStats from frontend (returns { total, hot, warm, cold, avgScore })
  </verify>
  <done>
Dashboard can query Sarah leads by temperature
Statistics available for analytics display
Individual conversation details queryable
  </done>
</task>

</tasks>

<verification>
- [ ] Convex schema has Sarah conversation table with all fields
- [ ] HTTP endpoint GET /sarah/state returns conversation state
- [ ] HTTP endpoint POST /sarah/state upserts state
- [ ] getSarahLeads returns leads filtered by temperature
- [ ] getSarahStats returns aggregate statistics
- [ ] All functions work with `npx convex dev`
</verification>

<success_criteria>
1. Convex schema stores all Sarah conversation data
2. HTTP endpoints allow Kapso to read/write state
3. Dashboard can display lead list with filters
4. Analytics queries provide aggregated stats
5. No TypeScript errors in Convex deployment
</success_criteria>

<output>
After completion, create `.planning/phases/03-sarah-chat-bot/03-02-SUMMARY.md`
</output>
