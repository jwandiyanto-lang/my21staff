---
phase: 03-sarah-chat-bot
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/sarah/state-machine.ts
  - src/lib/sarah/scoring.ts
  - src/lib/sarah/extraction.ts
  - src/lib/sarah/language.ts
autonomous: true

must_haves:
  truths:
    - "State machine transitions correctly: greeting -> qualifying -> scoring -> handoff/completed"
    - "Data extraction merges new info with existing (never overwrites with null)"
    - "Lead scoring returns 0-100 based on collected data"
    - "Language detection identifies Indonesian vs English messages"
  artifacts:
    - path: "src/lib/sarah/state-machine.ts"
      provides: "State transition logic and next state determination"
      exports: ["determineNextState", "shouldAskQuestion", "getNextQuestion"]
    - path: "src/lib/sarah/scoring.ts"
      provides: "Lead scoring algorithm (0-100)"
      exports: ["calculateLeadScore", "getLeadTemperature"]
    - path: "src/lib/sarah/extraction.ts"
      provides: "Gemini-based data extraction with merge logic"
      exports: ["extractDataFromMessage", "mergeExtractedData"]
    - path: "src/lib/sarah/language.ts"
      provides: "Indonesian/English language detection"
      exports: ["detectLanguage", "getLocalizedResponse"]
  key_links:
    - from: "src/lib/sarah/state-machine.ts"
      to: "src/lib/sarah/scoring.ts"
      via: "calculateLeadScore import"
      pattern: "import.*calculateLeadScore.*from.*scoring"
    - from: "src/lib/sarah/extraction.ts"
      to: "src/lib/gemini/client.ts"
      via: "GeminiClient import"
      pattern: "import.*GeminiClient.*from.*gemini"
---

<objective>
Build Sarah's conversation logic - state machine, data extraction, lead scoring, and language detection.

Purpose: This plan implements the "brain" of Sarah - the logic that determines what to ask next, extracts information from user messages, scores lead quality, and handles language switching. These functions will be called from the Kapso workflow in Plan 03.

Output:
- State machine with 5 states and correct transitions
- Data extraction using Gemini structured output
- Lead scoring algorithm (0-100 points)
- Language detection for Indonesian/English
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-sarah-chat-bot/03-CONTEXT.md
@business_21/03_bots/sarah-detailed-flow.md
@src/lib/gemini/client.ts (from Plan 01)
@src/lib/gemini/types.ts (from Plan 01)
@src/lib/sarah/prompts.ts (from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state machine and question flow</name>
  <files>src/lib/sarah/state-machine.ts</files>
  <action>
Build state machine based on sarah-detailed-flow.md:

1. **determineNextState(currentState: SarahState, context: { collected: QualificationData, leadScore: number })** - Returns next state:
   - `greeting` -> always `qualifying`
   - `qualifying` -> check if all 5 fields collected:
     - All collected -> `scoring`
     - Missing fields -> stay `qualifying`
   - `scoring` -> calculate lead score:
     - score >= 70 (hot) -> `handoff`
     - score < 40 (cold) -> `completed`
     - score 40-69 (warm) -> stay `scoring` (nurture)
   - `handoff`, `completed` -> terminal states (no transition)

2. **shouldAskQuestion(state: SarahState)** - Returns boolean:
   - `qualifying` -> true
   - All other states -> false

3. **getNextQuestion(collected: QualificationData, language: 'id' | 'en')** - Returns question string:
   - Check fields in order: name, business_type, team_size, pain_points, goals
   - Return question for first missing field
   - Use Indonesian or English template based on language
   - If all fields collected, return null

4. **detectHandoffKeywords(message: string)** - Returns boolean:
   - Keywords: "human", "person", "sales", "consultant", "talk to someone", "manusia", "operator"
   - If detected, should trigger immediate handoff regardless of state

5. **detectNotInterested(message: string)** - Returns boolean:
   - Keywords: "not interested", "tidak tertarik", "no thanks", "ga jadi", "nggak dulu"
   - If detected, should transition to completed state
  </action>
  <verify>
Unit test (manual):
- determineNextState('greeting', {collected: {}, leadScore: 0}) returns 'qualifying'
- determineNextState('qualifying', {collected: {name: 'John', ...all fields}, leadScore: 0}) returns 'scoring'
- getNextQuestion({}, 'id') returns Indonesian name question
  </verify>
  <done>
State machine correctly implements greeting -> qualifying -> scoring -> handoff/completed flow
Question flow asks for missing fields in correct order
Handoff and not-interested keywords detected
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lead scoring algorithm</name>
  <files>src/lib/sarah/scoring.ts</files>
  <action>
Implement scoring from sarah-detailed-flow.md:

1. **calculateLeadScore(context: { collected: QualificationData, messageCount?: number })** - Returns 0-100:

   **Basic Data (25 points max):**
   - name present: +5
   - business_type present: +10
   - goals present: +10

   **Team Size (20 points max):**
   - team_size >= 3: +20
   - team_size == 2: +15
   - team_size == 1: +10
   - team_size not set: +0

   **Pain Points (30 points max):**
   - Detect urgency from pain_points array text:
     - HIGH urgency keywords: "overwhelmed", "kewalahan", "miss message", "slow response", "complaint", "lost customer" -> +30
     - MEDIUM urgency: "busy", "sibuk", "need help", "growth", "expanding", "manual" -> +20
     - LOW urgency: "curious", "checking", "maybe", "someday" -> +10
   - If no pain_points: +0

   **Engagement (25 points max):**
   - Responsive (messageCount >= 3): +15
   - Asks questions (future enhancement): +10
   - For now, default to +15 if user has responded at least once

2. **getLeadTemperature(score: number)** - Returns 'hot' | 'warm' | 'cold':
   - score >= 70: 'hot'
   - score >= 40: 'warm'
   - score < 40: 'cold'

3. **getPainPointUrgency(painPoints: string[])** - Returns 'high' | 'medium' | 'low' | 'none':
   - Helper function for urgency detection
   - Join pain points into text, check keywords
  </action>
  <verify>
Unit test (manual):
- calculateLeadScore({collected: {name: 'John', business_type: 'Retail', team_size: 3, pain_points: ['miss message'], goals: 'auto reply'}}) returns ~85 (hot)
- calculateLeadScore({collected: {name: 'Jane'}}) returns ~20 (cold)
- getLeadTemperature(75) returns 'hot'
  </verify>
  <done>
Lead scoring matches the 0-100 algorithm from sarah-detailed-flow.md
Team size, pain points, and engagement all factor into score
Temperature thresholds: 70+ hot, 40-69 warm, <40 cold
  </done>
</task>

<task type="auto">
  <name>Task 3: Create data extraction and language detection</name>
  <files>
    src/lib/sarah/extraction.ts
    src/lib/sarah/language.ts
  </files>
  <action>
**src/lib/sarah/extraction.ts:**

1. **extractDataFromMessage(geminiClient: GeminiClient, userMessage: string, conversationHistory: GeminiChatMessage[], currentData: QualificationData)** - Returns Promise<QualificationData>:
   - Build extraction prompt with:
     - Current data already collected
     - Conversation history (last 10 messages)
     - User's latest message
   - Call geminiClient.generateWithSchema() with EXTRACTION_SCHEMA
   - Return merged data (new fields don't overwrite existing non-null values)

2. **mergeExtractedData(existing: QualificationData, extracted: QualificationData)** - Returns QualificationData:
   - For each field: use extracted value only if existing is null/undefined
   - For pain_points array: concat and dedupe
   - Never overwrite existing data with null

**src/lib/sarah/language.ts:**

3. **detectLanguage(message: string)** - Returns 'id' | 'en':
   - Indonesian patterns: /^halo|^hai|^selamat|^kak|^kakak|^bang/i, /\b(ada|nggak|gak|ya|yah|sih|deh|dong|lah)\b/i
   - English patterns: /^hi|^hello|^hey/i, /\b(yeah|okay|sure|thanks|please)\b/i
   - If Indonesian matches: return 'id'
   - If English matches: return 'en'
   - Default: return 'id' (Indonesian-first)

4. **getLocalizedResponse(key: string, language: 'id' | 'en')** - Returns string:
   - Keys: 'greeting', 'ask_name', 'ask_business', 'ask_team', 'ask_pain', 'ask_goals', 'handoff', 'cold_close'
   - Returns appropriate template from prompts.ts based on language
  </action>
  <verify>
- extractDataFromMessage with "Saya John, jualan baju online" should return {name: 'John', business_type: 'fashion/baju online'}
- mergeExtractedData({name: 'John'}, {name: null, business_type: 'Retail'}) returns {name: 'John', business_type: 'Retail'}
- detectLanguage('Halo, saya tertarik') returns 'id'
- detectLanguage('Hi there!') returns 'en'
  </verify>
  <done>
Gemini extracts data using structured output schema
Merge logic preserves existing data, never overwrites with null
Language detection correctly identifies Indonesian vs English
Localized responses available for both languages
  </done>
</task>

</tasks>

<verification>
- [ ] State machine transitions correctly through all 5 states
- [ ] Lead scoring returns appropriate values (0-100)
- [ ] getLeadTemperature correctly classifies hot/warm/cold
- [ ] Data extraction uses Gemini structured output
- [ ] Merge logic never loses existing data
- [ ] Language detection works for Indonesian and English
- [ ] All functions can be imported and called
</verification>

<success_criteria>
1. State machine implements greeting -> qualifying -> scoring -> handoff/completed flow
2. Question flow asks for fields in order: name, business, team, pain points, goals
3. Lead scoring algorithm produces 0-100 scores matching the formula
4. Data extraction successfully parses user messages into structured fields
5. Language detection correctly identifies Indonesian vs English
</success_criteria>

<output>
After completion, create `.planning/phases/03-sarah-chat-bot/03-02-SUMMARY.md`
</output>
