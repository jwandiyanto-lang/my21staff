---
phase: 03-sarah-chat-bot
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified: []
autonomous: true

must_haves:
  truths:
    - "Kapso workflow 'Sarah Chat Bot' exists and is active"
    - "Agent node uses Gemini 2.5 Flash with Sarah persona"
    - "Function nodes handle state logic and scoring"
    - "Workflow saves state to Convex after each message"
    - "Image messages are handled (not ignored)"
    - "Price questions are deflected to consultant"
  artifacts: []
  key_links:
    - from: "Kapso Inbound Trigger"
      to: "Agent Node (Gemini)"
      via: "Workflow path"
      pattern: "Inbound message -> Agent"
    - from: "Function Node"
      to: "Convex HTTP endpoint"
      via: "HTTP request"
      pattern: "POST /sarah/state"
---

<objective>
Build the Sarah Chat Bot workflow in Kapso using Agent and Function nodes with Gemini 2.5 Flash.

Purpose: This is the CORE plan - building Sarah as a Kapso workflow. Sarah lives IN Kapso (not as a Next.js API). The workflow uses Agent node for AI responses, Function nodes for state logic and scoring, and HTTP calls to Convex for persistence.

Output:
- Kapso workflow "Sarah Chat Bot" with Gemini Agent node
- State management via Function nodes
- Convex integration for state persistence
- Handles text AND image messages
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-sarah-chat-bot/03-CONTEXT.md
@.planning/phases/02-workflow-rules-engine/02-03-SUMMARY.md
@business_21/03_bots/sarah-kapso-prompts.md (from Plan 01)
@.kapso-project.env
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Sarah Chat Bot workflow in Kapso</name>
  <files></files>
  <action>
Use Kapso API to create a new workflow for Sarah (separate from the existing Rules Engine workflow):

**API: Create Workflow**
```bash
curl -X POST https://api.kapso.ai/platform/v1/workflows \
  -H "Authorization: Bearer da99e74e320048a32cc3ff818615bed93a53f39bb62ce073ef8cffa85e778cc6" \
  -H "Content-Type: application/json" \
  -d '{
    "project_id": "1fda0f3d-a913-4a82-bc1f-a07e1cb5213c",
    "name": "Sarah Chat Bot",
    "description": "AI-powered lead qualification with Gemini 2.5 Flash"
  }'
```

Store the workflow_id for next tasks.

**Workflow Structure (to be built):**

```
[Inbound Message Trigger]
         |
         v
[Function: Get State from Convex]
         |
         v
[Function: Check Message Type + Special Keywords]
         |
    ┌────┴────┐
    |         |
    v         v
[Handoff]  [Normal]
  Path       Path
    |         |
    v         v
[Send      [Agent: Sarah (Gemini)]
Handoff         |
Message]        v
          [Function: Extract Data + Score]
                |
                v
          [Function: Determine Next State]
                |
                v
          [Function: Save State to Convex]
                |
                v
          [Send Message Node]
```

This workflow will be called from the existing Rules Engine workflow's "ai_fallback" path.
  </action>
  <verify>
Kapso API returns 200 with workflow_id
Workflow appears in Kapso dashboard
  </verify>
  <done>
Sarah Chat Bot workflow created in Kapso
Workflow ID stored for node configuration
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Agent node with Gemini and Sarah persona</name>
  <files></files>
  <action>
Add Agent node to the Sarah workflow using Kapso API:

**1. Find Gemini model ID in Kapso:**
```bash
curl https://api.kapso.ai/platform/v1/provider_models \
  -H "Authorization: Bearer da99e74e320048a32cc3ff818615bed93a53f39bb62ce073ef8cffa85e778cc6"
```
Look for "gemini-2.5-flash" or "google/gemini-2.5-flash" in the response.

**2. Add Agent Node:**
```bash
curl -X POST https://api.kapso.ai/platform/v1/workflows/{workflow_id}/nodes \
  -H "Authorization: Bearer da99e74e320048a32cc3ff818615bed93a53f39bb62ce073ef8cffa85e778cc6" \
  -H "Content-Type: application/json" \
  -d '{
    "type": "agent",
    "name": "Sarah",
    "config": {
      "provider_model_id": "[GEMINI_MODEL_ID]",
      "system_prompt": "[SARAH_SYSTEM_PROMPT from Plan 01]",
      "temperature": 0.7,
      "max_tokens": 150,
      "api_key_secret": "GEMINI_API_KEY"
    }
  }'
```

**System prompt content (from sarah-kapso-prompts.md):**
```
You are Sarah, a friendly AI assistant for my21staff - a WhatsApp CRM for Indonesian SMEs.

PERSONALITY:
- Warm, helpful, like chatting with a knowledgeable friend
- Indonesian by default (casual: Halo, Hai, Sip, Kakak)
- Switch to English if user messages in English
- Professional but casual - like a capable intern
- Not pushy or salesy - genuinely want to understand and help

MESSAGE RULES:
- Keep responses under 140 characters (WhatsApp best practice)
- Maximum 1-2 emoji per message (sparingly)
- ONE question per message - wait for response before asking next
- Show empathy: "Wah paham banget..." "Betul tuh..."

CURRENT STATE: {{state}}
EXTRACTED DATA: {{extracted_data}}
LANGUAGE: {{language}}

Based on the state, respond appropriately:
- greeting: Welcome with time greeting, ask about their business
- qualifying: Ask for the NEXT missing field (name, business_type, team_size, pain_points, goals)
- scoring: Answer questions helpfully, stay conversational
- handoff: Say "Sip! Konsultan kami akan segera hubungi kakak ya."
- completed: Say goodbye warmly

NEVER give specific prices - say "Nanti konsultan kita yang jelasin ya kak."
```

**3. Configure Agent to handle images:**
Add to system prompt:
```
If the user sends an image/photo:
- Acknowledge it: "Sip, saya terima fotonya."
- If it looks like a product: "Produknya keren! Bisnisnya jualan apa kak?"
- Continue the qualifying flow - don't stop
```

**4. Set max_tokens to 150** to enforce ~140 character responses (with buffer for emoji).
  </action>
  <verify>
Agent node appears in workflow
Test with manual trigger returns Indonesian greeting
Response is under 150 tokens
  </verify>
  <done>
Sarah Agent node configured with Gemini 2.5 Flash
System prompt includes persona, state handling, image handling
API key references Kapso secret
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Function nodes for state logic and Convex integration</name>
  <files></files>
  <action>
Add Function nodes to handle state management, scoring, and Convex persistence:

**Function 1: Get State from Convex**
```javascript
// Node: get_state
// Runs before Agent node to load current conversation state

const phone = trigger.contact.phone;
const convexUrl = "https://[deployment].convex.cloud/sarah/state";

const response = await fetch(`${convexUrl}?contact_phone=${encodeURIComponent(phone)}`);
const state = await response.json();

return {
  state: state.state || "greeting",
  extracted_data: state.extracted_data || {},
  lead_score: state.lead_score || 0,
  lead_temperature: state.lead_temperature || "cold",
  language: state.language || "id",
  message_count: state.message_count || 0,
};
```

**Function 2: Check for Handoff/Price Keywords**
```javascript
// Node: check_keywords
// Detects handoff triggers and price questions

const message = trigger.message.content.toLowerCase();

// Handoff triggers
const handoffKeywords = ["human", "manusia", "person", "sales", "consultant", "talk to someone", "operator"];
const wantsHandoff = handoffKeywords.some(k => message.includes(k));

// Price question detection
const priceKeywords = ["harga", "price", "biaya", "berapa", "cost", "pricing", "fee"];
const askingPrice = priceKeywords.some(k => message.includes(k));

// Not interested detection
const notInterestedKeywords = ["not interested", "tidak tertarik", "no thanks", "ga jadi", "nggak dulu"];
const notInterested = notInterestedKeywords.some(k => message.includes(k));

return {
  wants_handoff: wantsHandoff,
  asking_price: askingPrice,
  not_interested: notInterested,
  is_image: trigger.message.type === "image",
};
```

**Function 3: Extract Data and Calculate Score**
```javascript
// Node: extract_and_score
// Runs AFTER Agent node to extract data from conversation

const message = trigger.message.content;
const currentData = nodes.get_state.extracted_data || {};
const agentResponse = nodes.sarah.response;

// Simple extraction from user message
// (Agent does the heavy lifting, this is backup extraction)
let extracted = { ...currentData };

// Team size extraction
const teamMatch = message.match(/(\d+)\s*(orang|people|person)/i);
if (teamMatch) {
  extracted.team_size = parseInt(teamMatch[1]);
}

// Calculate score
let score = 0;
if (extracted.name) score += 5;
if (extracted.business_type) score += 10;
if (extracted.goals) score += 10;

// Team size scoring
if (extracted.team_size >= 3) score += 20;
else if (extracted.team_size === 2) score += 15;
else if (extracted.team_size === 1) score += 10;

// Pain point urgency
const painText = (extracted.pain_points || []).join(" ").toLowerCase();
const highUrgency = ["overwhelmed", "kewalahan", "miss message", "slow response"];
const medUrgency = ["busy", "sibuk", "need help", "growth"];
if (highUrgency.some(k => painText.includes(k))) score += 30;
else if (medUrgency.some(k => painText.includes(k))) score += 20;
else if (painText.length > 0) score += 10;

// Default engagement
score += 15;

// Temperature
let temperature = "cold";
if (score >= 70) temperature = "hot";
else if (score >= 40) temperature = "warm";

return {
  extracted_data: extracted,
  lead_score: Math.min(score, 100),
  lead_temperature: temperature,
};
```

**Function 4: Determine Next State**
```javascript
// Node: determine_state

const current = nodes.get_state.state;
const keywords = nodes.check_keywords;
const score = nodes.extract_and_score;
const data = score.extracted_data;

// Immediate handoff for keywords
if (keywords.wants_handoff) return { next_state: "handoff" };
if (keywords.not_interested) return { next_state: "completed" };

// State transitions
switch (current) {
  case "greeting":
    return { next_state: "qualifying" };

  case "qualifying":
    // Check if all 5 fields collected
    const hasAll = data.name && data.business_type &&
                   data.team_size !== undefined &&
                   data.pain_points && data.goals;
    return { next_state: hasAll ? "scoring" : "qualifying" };

  case "scoring":
    if (score.lead_score >= 70) return { next_state: "handoff" };
    if (score.lead_score < 40) return { next_state: "completed" };
    return { next_state: "scoring" }; // Warm lead - continue

  default:
    return { next_state: current }; // Terminal states
}
```

**Function 5: Save State to Convex**
```javascript
// Node: save_state
// Runs after Agent responds to persist state

const phone = trigger.contact.phone;
const convexUrl = "https://[deployment].convex.cloud/sarah/state";

await fetch(convexUrl, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    contact_phone: phone,
    state: nodes.determine_state.next_state,
    lead_score: nodes.extract_and_score.lead_score,
    lead_temperature: nodes.extract_and_score.lead_temperature,
    extracted_data: nodes.extract_and_score.extracted_data,
    language: nodes.get_state.language, // Preserve detected language
    message_count: (nodes.get_state.message_count || 0) + 1,
  }),
});

return { saved: true };
```

**Wire the nodes in this order:**
1. Trigger -> get_state -> check_keywords
2. check_keywords (if handoff) -> send_handoff_message
3. check_keywords (else) -> sarah (Agent) -> extract_and_score -> determine_state -> save_state -> send_message
  </action>
  <verify>
All 5 Function nodes appear in workflow
get_state successfully calls Convex endpoint
save_state successfully writes to Convex
  </verify>
  <done>
Function nodes handle state retrieval, keyword detection, scoring, state transitions, and Convex persistence
Workflow wired: trigger -> state -> keywords -> agent -> score -> save -> send
  </done>
</task>

</tasks>

<verification>
- [ ] Workflow "Sarah Chat Bot" exists in Kapso
- [ ] Agent node uses Gemini 2.5 Flash
- [ ] System prompt includes Sarah persona
- [ ] Function nodes wire correctly
- [ ] State is read from Convex before Agent
- [ ] State is saved to Convex after Agent
- [ ] Handoff keywords trigger immediate handoff path
- [ ] Price questions get deflected (in Agent prompt)
- [ ] Image messages are acknowledged (in Agent prompt)
</verification>

<success_criteria>
1. Kapso workflow "Sarah Chat Bot" is active
2. Gemini Agent node responds with Sarah persona
3. State persists in Convex across messages
4. Lead scoring calculates correctly (0-100)
5. Handoff triggers work for keywords
6. Price questions deflected to consultant
7. Image messages acknowledged and flow continues
</success_criteria>

<output>
After completion, create `.planning/phases/03-sarah-chat-bot/03-03-SUMMARY.md`
</output>
