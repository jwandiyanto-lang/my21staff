---
phase: 03-sarah-chat-bot
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/app/api/sarah/process/route.ts
  - src/lib/sarah/handler.ts
  - convex/sarah.ts
autonomous: true

must_haves:
  truths:
    - "Sarah API endpoint receives message and returns response"
    - "Conversation state persists in Convex ariConversations table"
    - "Kapso workflow can call Sarah API and send response back"
  artifacts:
    - path: "src/app/api/sarah/process/route.ts"
      provides: "Next.js API route for Sarah message processing"
      exports: ["POST"]
    - path: "src/lib/sarah/handler.ts"
      provides: "Core Sarah message handler orchestrating all logic"
      exports: ["processSarahMessage"]
    - path: "convex/sarah.ts"
      provides: "Convex mutations for Sarah conversation state"
      exports: ["getSarahConversation", "updateSarahState", "saveSarahMessage"]
  key_links:
    - from: "src/app/api/sarah/process/route.ts"
      to: "src/lib/sarah/handler.ts"
      via: "processSarahMessage import"
      pattern: "import.*processSarahMessage.*from.*handler"
    - from: "src/lib/sarah/handler.ts"
      to: "convex/sarah.ts"
      via: "Convex API call"
      pattern: "api\\.sarah\\."
    - from: "src/lib/sarah/handler.ts"
      to: "src/lib/gemini/client.ts"
      via: "GeminiClient import"
      pattern: "import.*GeminiClient.*from.*gemini"
---

<objective>
Create the Sarah message processing API and Convex state storage for Kapso workflow integration.

Purpose: This plan wires everything together - an API endpoint that Kapso workflows can call, a message handler that orchestrates Gemini/state machine/scoring, and Convex mutations that persist conversation state. After this plan, Sarah is callable from Kapso.

Output:
- Next.js API route: POST /api/sarah/process
- Message handler that coordinates all Sarah logic
- Convex mutations for state persistence
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-sarah-chat-bot/03-CONTEXT.md
@.planning/phases/02-workflow-rules-engine/02-03-SUMMARY.md
@convex/schema.ts
@src/lib/sarah/state-machine.ts (from Plan 02)
@src/lib/sarah/scoring.ts (from Plan 02)
@src/lib/sarah/extraction.ts (from Plan 02)
@src/lib/gemini/client.ts (from Plan 01)
@src/lib/sarah/prompts.ts (from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Convex mutations for Sarah state</name>
  <files>convex/sarah.ts</files>
  <action>
Create Convex functions to manage Sarah conversation state using existing ariConversations table:

1. **getSarahConversation(workspace_id: string, contact_id: string)** - internalQuery:
   - Query ariConversations by workspace_id + contact_id index
   - If not exists, return null (handler will create)
   - Return: { _id, state, lead_score, lead_temperature, context, ai_model }

2. **createSarahConversation(args)** - internalMutation:
   - Insert new ariConversations record:
     - state: 'greeting'
     - lead_score: 0
     - lead_temperature: 'cold'
     - context: { collected: {}, language: 'id', message_count: 0 }
     - ai_model: 'gemini-2.5-flash'
   - Return the new conversation ID

3. **updateSarahState(conversation_id, updates)** - internalMutation:
   - Patch ariConversations with:
     - state (if provided)
     - lead_score (if provided)
     - lead_temperature (if provided)
     - context (merge with existing, don't overwrite)
     - updated_at: Date.now()

4. **saveSarahMessage(conversation_id, workspace_id, role, content)** - internalMutation:
   - Insert into ariMessages:
     - ari_conversation_id: conversation_id
     - workspace_id
     - role: 'user' | 'assistant'
     - content
     - ai_model: 'gemini-2.5-flash' (if role is assistant)
     - created_at: Date.now()

5. **getSarahHistory(conversation_id, limit = 20)** - internalQuery:
   - Query ariMessages by ari_conversation_id, order by created_at desc, take limit
   - Return reversed (oldest first for Gemini context)

Use `internal` functions - these are called from API routes, not directly from client.
  </action>
  <verify>
Run `npx convex dev` - no TypeScript errors
Verify functions are generated in convex/_generated/api.d.ts
  </verify>
  <done>
Convex mutations exist for getting/creating/updating Sarah conversation state
Message history can be retrieved for Gemini context
All functions use ariConversations and ariMessages tables (existing schema)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Sarah message handler</name>
  <files>src/lib/sarah/handler.ts</files>
  <action>
Create the orchestrator that combines all Sarah logic:

**processSarahMessage(args)** - Main handler:

Input:
```typescript
{
  workspace_id: string
  contact_id: string
  contact_phone: string
  user_message: string
  kapso_message_id?: string
}
```

Output:
```typescript
{
  response: string          // Sarah's reply to send
  state: SarahState         // Current state after processing
  lead_score: number        // Current lead score
  lead_temperature: string  // 'hot' | 'warm' | 'cold'
  extracted_data: QualificationData
  should_handoff: boolean   // True if handoff detected
  handoff_reason?: string   // 'hot_lead' | 'user_requested' | 'data_complete'
}
```

Flow:
1. Get or create Sarah conversation from Convex
2. Save user message to ariMessages
3. Get conversation history (last 20 messages)
4. Detect language from user message
5. Check for handoff keywords -> immediate handoff if detected
6. Check for not-interested keywords -> close if detected
7. Extract data from message using Gemini
8. Merge extracted data with existing
9. Calculate lead score
10. Determine next state
11. Generate Sarah's response using Gemini chat with:
    - System prompt (SARAH_SYSTEM_PROMPT)
    - State-specific instructions
    - Conversation history
    - Current extracted data (so Sarah knows what to ask next)
    - Language preference
12. Save Sarah's response to ariMessages
13. Update conversation state in Convex
14. Return response for Kapso to send

**Important:** Enforce 140-char limit on response. If Gemini returns longer, truncate at sentence boundary.
  </action>
  <verify>
TypeScript compiles without errors
Function signature matches expected input/output
All imports from Plan 01 and Plan 02 work correctly
  </verify>
  <done>
Sarah handler orchestrates: state lookup -> message save -> extraction -> scoring -> response generation -> state update
Returns structured response that Kapso can use
Respects 140-char message limit
  </done>
</task>

<task type="auto">
  <name>Task 3: Create API endpoint for Kapso integration</name>
  <files>src/app/api/sarah/process/route.ts</files>
  <action>
Create Next.js API route that Kapso workflow can call:

**POST /api/sarah/process**

Request body:
```typescript
{
  workspace_id: string
  contact_id: string
  contact_phone: string
  message: string
  message_id?: string
}
```

Response:
```typescript
{
  success: boolean
  response: string           // Sarah's message to send
  state: string
  lead_score: number
  should_handoff: boolean
  error?: string
}
```

Implementation:
1. Parse request body
2. Validate required fields (workspace_id, contact_id, contact_phone, message)
3. Call processSarahMessage()
4. Return JSON response

Error handling:
- Missing fields: 400 with error message
- Processing error: 500 with error message
- Always return JSON (even for errors)

Security note: This endpoint should be called from Kapso workflow (server-side). In production, add API key verification. For now, just log requests.

**Also create /api/sarah/health** - GET endpoint for testing:
- Returns { status: 'ok', version: '1.0', model: 'gemini-2.5-flash' }
  </action>
  <verify>
Start dev server: `npm run dev`
Test health: `curl http://localhost:3000/api/sarah/health` returns JSON
Test process: `curl -X POST http://localhost:3000/api/sarah/process -H "Content-Type: application/json" -d '{"workspace_id":"test","contact_id":"test","contact_phone":"+62123","message":"Halo"}'`
  </verify>
  <done>
POST /api/sarah/process endpoint accepts messages and returns Sarah's response
GET /api/sarah/health confirms API is running
Response format ready for Kapso workflow to parse
  </done>
</task>

</tasks>

<verification>
- [ ] Convex dev runs without errors
- [ ] All Sarah Convex functions generated
- [ ] API endpoint responds to health check
- [ ] API endpoint processes test message
- [ ] Response includes all expected fields (response, state, lead_score, should_handoff)
- [ ] ariConversations record created for new conversation
- [ ] ariMessages contains user message and Sarah's response
</verification>

<success_criteria>
1. Convex mutations work with existing ariConversations/ariMessages tables
2. Sarah handler orchestrates all logic into a single function
3. API endpoint callable from external systems (Kapso)
4. Conversation state persists across messages
5. Response format matches what Kapso workflow needs
</success_criteria>

<output>
After completion, create `.planning/phases/03-sarah-chat-bot/03-03-SUMMARY.md`
</output>
