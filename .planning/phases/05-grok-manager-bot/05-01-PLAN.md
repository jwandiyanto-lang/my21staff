---
phase: 05-grok-manager-bot
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/brainSummaries.ts
  - convex/brainInsights.ts
  - convex/brainActions.ts
autonomous: true

must_haves:
  truths:
    - "Brain summaries can be stored and retrieved by workspace"
    - "Action recommendations can be queried for dashboard"
    - "Conversation insights can be stored with pattern data"
  artifacts:
    - path: "convex/schema.ts"
      provides: "brainSummaries, brainInsights, brainActions tables"
      contains: "brainSummaries"
    - path: "convex/brainSummaries.ts"
      provides: "Summary CRUD operations"
      exports: ["createSummary", "getLatestSummary", "getSummariesByWorkspace"]
    - path: "convex/brainInsights.ts"
      provides: "Pattern/insight storage"
      exports: ["createInsight", "getInsightsByWorkspace", "bulkCreateInsights"]
    - path: "convex/brainActions.ts"
      provides: "Action recommendation queries"
      exports: ["createActionRecommendation", "getActionsByWorkspace", "getActionsByPriority"]
  key_links:
    - from: "convex/brainSummaries.ts"
      to: "convex/schema.ts"
      via: "schema table definition"
      pattern: "brainSummaries"
---

<objective>
Create Convex schema and core data layer for Brain analytics: summaries, insights, and action recommendations.

Purpose: Build the data foundation that stores Brain's analysis outputs for dashboard display (Phase 6) and retrieval.

Output: Three new Convex tables (brainSummaries, brainInsights, brainActions) with CRUD operations.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-grok-manager-bot/05-CONTEXT.md
@.planning/phases/05-grok-manager-bot/05-RESEARCH.md
@convex/schema.ts
@convex/brainConfig.ts
@convex/leads.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Brain analytics tables to schema</name>
  <files>convex/schema.ts</files>
  <action>
Add three new tables to convex/schema.ts:

1. **brainSummaries** - Daily/on-demand summaries:
```typescript
brainSummaries: defineTable({
  workspace_id: v.id("workspaces"),
  summary_text: v.string(),          // Conversational summary text
  summary_type: v.string(),          // 'daily' | 'manual' | 'scheduled'
  trigger: v.string(),               // 'cron' | 'command' | 'api'
  triggered_by: v.optional(v.string()), // Phone number if !summary command

  // Metrics snapshot (configurable from brainConfig)
  metrics: v.object({
    newLeadsCount: v.number(),
    hotLeadsCount: v.number(),
    warmLeadsCount: v.number(),
    coldLeadsCount: v.number(),
    responseRate: v.optional(v.number()),
    avgScore: v.optional(v.number()),
    topQuestions: v.optional(v.array(v.string())),
    rejectionReasons: v.optional(v.array(v.string())),
  }),

  // Token usage tracking
  tokens_used: v.optional(v.number()),
  cost_usd: v.optional(v.number()),

  created_at: v.number(),
})
  .index("by_workspace", ["workspace_id"])
  .index("by_workspace_type", ["workspace_id", "summary_type"])
  .index("by_created", ["created_at"]),

2. **brainInsights** - Pattern detection results:
brainInsights: defineTable({
  workspace_id: v.id("workspaces"),
  insight_type: v.string(),          // 'trending_topic' | 'objection_pattern' | 'interest_signal' | 'rejection_analysis'
  pattern: v.string(),               // The detected pattern
  frequency: v.number(),             // How often it appeared
  examples: v.array(v.string()),     // Sample quotes/instances
  recommendation: v.optional(v.string()), // AI recommendation
  suggested_faqs: v.optional(v.array(v.object({
    question: v.string(),
    suggested_answer: v.string(),
  }))),                              // MGR-06: FAQ suggestions for trending topics/objections
  confidence: v.string(),            // 'high' | 'medium' | 'low'
  time_range: v.string(),            // 'today' | 'week' | 'month'
  created_at: v.number(),
})
  .index("by_workspace", ["workspace_id"])
  .index("by_workspace_type", ["workspace_id", "insight_type"])
  .index("by_created", ["created_at"]),

3. **brainActions** - Action recommendations:
brainActions: defineTable({
  workspace_id: v.id("workspaces"),
  contact_id: v.id("contacts"),

  // Action details
  action_type: v.string(),           // 'follow_up' | 'response_template' | 'handoff_ready' | 'opportunity_alert'
  priority: v.number(),              // 0-100 weighted score
  urgency: v.string(),               // 'immediate' | 'today' | 'this_week'
  reason: v.string(),                // Why this action is recommended

  // Optional template for response_template type
  suggested_message: v.optional(v.string()),

  // Status tracking
  status: v.string(),                // 'pending' | 'actioned' | 'dismissed'
  actioned_at: v.optional(v.number()),
  actioned_by: v.optional(v.string()),

  created_at: v.number(),
  expires_at: v.optional(v.number()), // Actions expire after 24h by default
})
  .index("by_workspace", ["workspace_id"])
  .index("by_workspace_status", ["workspace_id", "status"])
  .index("by_contact", ["contact_id"])
  .index("by_priority", ["workspace_id", "priority"]),
```

Place these after the existing brainConfig table definition.
  </action>
  <verify>Run `npx convex dev` - schema should deploy without errors</verify>
  <done>Three new tables (brainSummaries, brainInsights, brainActions) exist in schema with proper indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create brainSummaries.ts with CRUD operations</name>
  <files>convex/brainSummaries.ts</files>
  <action>
Create new file convex/brainSummaries.ts with:

1. **internalMutation: createSummary** - Create a new summary record
   - Args: workspace_id, summary_text, summary_type, trigger, triggered_by?, metrics, tokens_used?, cost_usd?
   - Insert into brainSummaries table
   - Return the created summary ID

2. **query: getLatestSummary** - Get most recent summary for workspace
   - Args: workspace_id
   - Query brainSummaries by workspace, order desc, take 1
   - Return summary or null

3. **query: getSummariesByWorkspace** - Get summaries with optional type filter
   - Args: workspace_id, summary_type? (optional), limit? (default 10)
   - If summary_type provided, use by_workspace_type index
   - Order by created_at desc
   - Return array of summaries

4. **internalQuery: getRecentSummaries** - For internal use in summary generation
   - Args: workspace_id, days (default 1)
   - Get summaries from last N days
   - Used to prevent duplicate daily summaries

Follow patterns from convex/leads.ts for query structure.
Import v from 'convex/values', use internalMutation/query from './_generated/server'.
  </action>
  <verify>Run `npx convex dev` - file should compile without TypeScript errors</verify>
  <done>brainSummaries.ts exports createSummary, getLatestSummary, getSummariesByWorkspace, getRecentSummaries</done>
</task>

<task type="auto">
  <name>Task 3: Create brainInsights.ts and brainActions.ts</name>
  <files>convex/brainInsights.ts, convex/brainActions.ts</files>
  <action>
**Create convex/brainInsights.ts:**

```typescript
import { internalMutation, query } from "./_generated/server";
import { v } from "convex/values";

/**
 * internalMutation: createInsight - Store detected pattern
 */
export const createInsight = internalMutation({
  args: {
    workspace_id: v.id("workspaces"),
    insight_type: v.string(),
    pattern: v.string(),
    frequency: v.number(),
    examples: v.array(v.string()),
    recommendation: v.optional(v.string()),
    suggested_faqs: v.optional(v.array(v.object({
      question: v.string(),
      suggested_answer: v.string(),
    }))),
    confidence: v.string(),
    time_range: v.string(),
  },
  handler: async (ctx, args) => {
    const insightId = await ctx.db.insert("brainInsights", {
      ...args,
      created_at: Date.now(),
    });
    return insightId;
  },
});

/**
 * query: getInsightsByWorkspace - Get insights with optional type filter
 */
export const getInsightsByWorkspace = query({
  args: {
    workspaceId: v.id("workspaces"),
    insightType: v.optional(v.string()),
    timeRange: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const { workspaceId, insightType, timeRange, limit = 20 } = args;

    let results = await ctx.db
      .query("brainInsights")
      .withIndex("by_workspace", (q) => q.eq("workspace_id", workspaceId))
      .order("desc")
      .take(limit * 3); // Over-fetch for filtering

    if (insightType) {
      results = results.filter((r) => r.insight_type === insightType);
    }
    if (timeRange) {
      results = results.filter((r) => r.time_range === timeRange);
    }

    return results.slice(0, limit);
  },
});

/**
 * internalMutation: bulkCreateInsights - Create multiple insights at once
 * Used after pattern analysis completes
 */
export const bulkCreateInsights = internalMutation({
  args: {
    insights: v.array(v.object({
      workspace_id: v.id("workspaces"),
      insight_type: v.string(),
      pattern: v.string(),
      frequency: v.number(),
      examples: v.array(v.string()),
      recommendation: v.optional(v.string()),
      suggested_faqs: v.optional(v.array(v.object({
        question: v.string(),
        suggested_answer: v.string(),
      }))),
      confidence: v.string(),
      time_range: v.string(),
    })),
  },
  handler: async (ctx, args) => {
    const ids: string[] = [];
    for (const insight of args.insights) {
      const id = await ctx.db.insert("brainInsights", {
        ...insight,
        created_at: Date.now(),
      });
      ids.push(id);
    }
    console.log(`[Brain] Bulk created ${ids.length} insights`);
    return { count: ids.length, ids };
  },
});
```

**Create convex/brainActions.ts:**

```typescript
import { mutation, internalMutation, query } from "./_generated/server";
import { v } from "convex/values";

/**
 * internalMutation: createActionRecommendation - Store action item
 */
export const createActionRecommendation = internalMutation({
  args: {
    workspace_id: v.id("workspaces"),
    contact_id: v.id("contacts"),
    action_type: v.string(),
    priority: v.number(),
    urgency: v.string(),
    reason: v.string(),
    suggested_message: v.optional(v.string()),
    expires_at: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const actionId = await ctx.db.insert("brainActions", {
      ...args,
      status: "pending",
      created_at: Date.now(),
      expires_at: args.expires_at || Date.now() + 24 * 60 * 60 * 1000, // 24h default
    });
    return actionId;
  },
});

/**
 * query: getActionsByWorkspace - Get pending actions
 */
export const getActionsByWorkspace = query({
  args: {
    workspaceId: v.id("workspaces"),
    status: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const { workspaceId, status = "pending", limit = 20 } = args;

    const actions = await ctx.db
      .query("brainActions")
      .withIndex("by_workspace_status", (q) =>
        q.eq("workspace_id", workspaceId).eq("status", status)
      )
      .order("desc")
      .take(limit);

    // Sort by priority (highest first)
    return actions.sort((a, b) => b.priority - a.priority);
  },
});

/**
 * query: getActionsByPriority - Get top priority actions
 */
export const getActionsByPriority = query({
  args: {
    workspaceId: v.id("workspaces"),
    urgency: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const { workspaceId, urgency } = args;

    let actions = await ctx.db
      .query("brainActions")
      .withIndex("by_workspace_status", (q) =>
        q.eq("workspace_id", workspaceId).eq("status", "pending")
      )
      .collect();

    if (urgency) {
      actions = actions.filter((a) => a.urgency === urgency);
    }

    // Sort by priority (highest first)
    return actions.sort((a, b) => b.priority - a.priority);
  },
});

/**
 * mutation: markActionActioned - Update action status
 */
export const markActionActioned = mutation({
  args: {
    actionId: v.id("brainActions"),
    actionedBy: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.actionId, {
      status: "actioned",
      actioned_at: Date.now(),
      actioned_by: args.actionedBy,
    });
    return { success: true };
  },
});

/**
 * mutation: dismissAction - Dismiss an action
 */
export const dismissAction = mutation({
  args: {
    actionId: v.id("brainActions"),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.actionId, {
      status: "dismissed",
    });
    return { success: true };
  },
});

/**
 * internalMutation: cleanupExpiredActions - Remove old actions
 * Called by cron job every 6 hours
 */
export const cleanupExpiredActions = internalMutation({
  handler: async (ctx) => {
    const now = Date.now();

    // Find expired pending actions
    const expiredActions = await ctx.db
      .query("brainActions")
      .filter((q) =>
        q.and(
          q.eq(q.field("status"), "pending"),
          q.lt(q.field("expires_at"), now)
        )
      )
      .collect();

    // Mark as expired (or delete - marking is safer for audit)
    for (const action of expiredActions) {
      await ctx.db.patch(action._id, { status: "dismissed" });
    }

    console.log(`[Brain] Cleaned up ${expiredActions.length} expired actions`);
    return { cleanedUp: expiredActions.length };
  },
});
```
  </action>
  <verify>Run `npx convex dev` - both files should compile without errors</verify>
  <done>brainInsights.ts and brainActions.ts export all CRUD operations as specified</done>
</task>

</tasks>

<verification>
1. Run `npx convex dev` - all files compile
2. Check Convex dashboard - three new tables visible
3. Verify indexes are created for efficient queries
</verification>

<success_criteria>
- Schema deploys with brainSummaries, brainInsights, brainActions tables
- brainInsights table includes suggested_faqs field for MGR-06 compliance
- Each table has workspace_id index for multi-tenant queries
- CRUD operations follow existing patterns (leads.ts, sarah.ts)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-grok-manager-bot/05-01-SUMMARY.md`
</output>
