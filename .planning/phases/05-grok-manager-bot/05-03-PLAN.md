---
phase: 05-grok-manager-bot
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - convex/brainAnalysis.ts
autonomous: true

must_haves:
  truths:
    - "Brain generates action recommendations for qualified leads"
    - "Actions are prioritized by weighted algorithm (score + timing + urgency)"
    - "Response templates are personalized using lead context"
  artifacts:
    - path: "convex/brainAnalysis.ts"
      provides: "Action generation logic"
      exports: ["generateActionRecommendations"]
  key_links:
    - from: "convex/brainAnalysis.ts"
      to: "convex/leads.ts"
      via: "queries lead data"
      pattern: "leads.getLeadsNeedingFollowUp"
    - from: "convex/brainAnalysis.ts"
      to: "convex/brainActions.ts"
      via: "stores recommendations"
      pattern: "brainActions.createActionRecommendation"
---

<objective>
Implement action recommendation engine: follow-up priorities, response templates, handoff alerts, and opportunity detection.

Purpose: Generate prioritized, actionable recommendations that help business owners know exactly who to contact and what to say.

Output: Working action generation that creates prioritized recommendations with personalized templates.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/05-grok-manager-bot/05-CONTEXT.md
@.planning/phases/05-grok-manager-bot/05-RESEARCH.md
@convex/leads.ts
@business_21/03_bots/E-handoff-to-human.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add action recommendation types and scoring algorithm</name>
  <files>convex/brainAnalysis.ts</files>
  <action>
Add action recommendation logic to convex/brainAnalysis.ts:

**1. Type definitions:**
```typescript
interface ActionRecommendation {
  contactId: string;
  contactName: string;
  contactPhone: string;
  actionType: 'follow_up' | 'response_template' | 'handoff_ready' | 'opportunity_alert';
  priority: number;  // 0-100
  urgency: 'immediate' | 'today' | 'this_week';
  reason: string;
  suggestedMessage?: string;
}

interface ScoringWeights {
  leadScore: number;      // Weight for lead temperature (default: 0.40)
  timeSinceContact: number; // Weight for days since last contact (default: 0.30)
  engagementDecay: number;  // Weight for score trending down (default: 0.20)
  urgencySignals: number;   // Weight for explicit urgency (default: 0.10)
}
```

**2. Priority calculation function (from RESEARCH.md):**
```typescript
function calculateActionPriority(lead: ContactLead, weights: ScoringWeights = {
  leadScore: 0.40,
  timeSinceContact: 0.30,
  engagementDecay: 0.20,
  urgencySignals: 0.10,
}): number {
  const daysSinceContact = lead.lastContactAt
    ? Math.floor((Date.now() - lead.lastContactAt) / (24 * 60 * 60 * 1000))
    : 14; // Default to 14 days if never contacted

  const normalized = {
    leadScore: (lead.leadScore || 0) / 100,
    timeSinceContact: Math.min(daysSinceContact / 14, 1), // Cap at 14 days
    engagementDecay: 0, // TODO: Track previous scores for trending
    urgencySignals: hasUrgencySignal(lead) ? 1 : 0,
  };

  return Math.round(
    normalized.leadScore * weights.leadScore * 100 +
    normalized.timeSinceContact * weights.timeSinceContact * 100 +
    normalized.engagementDecay * weights.engagementDecay * 100 +
    normalized.urgencySignals * weights.urgencySignals * 100
  );
}
```

**3. Urgency signal detection:**
```typescript
function hasUrgencySignal(lead: ContactLead): boolean {
  // Check notes for urgency keywords
  const notes = lead.notes?.map(n => n.content).join(' ') || '';
  const signals = [
    /budget|anggaran|biaya/i,
    /urgent|segera|cepat|asap/i,
    /competitor|saingan|bandingkan/i,
    /ready|siap|mau/i,
  ];
  return signals.some(pattern => pattern.test(notes));
}

function detectOpportunityType(lead: ContactLead): string | null {
  const notes = lead.notes?.map(n => n.content).join(' ') || '';

  if (/budget|anggaran|biaya/i.test(notes)) return 'Budget discussion detected';
  if (/competitor|saingan|bandingkan/i.test(notes)) return 'Competitor comparison mentioned';
  if (/urgent|segera|cepat/i.test(notes)) return 'Urgency signal detected';
  if (/demo|coba|trial/i.test(notes)) return 'Demo request detected';

  return null;
}
```

**4. Urgency level determination:**
```typescript
function determineUrgency(priority: number, lead: ContactLead): 'immediate' | 'today' | 'this_week' {
  if (priority >= 80) return 'immediate';
  if (priority >= 60) return 'today';
  if (lead.leadTemperature === 'hot') return 'today';
  return 'this_week';
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Scoring algorithm implemented with configurable weights and urgency detection</done>
</task>

<task type="auto">
  <name>Task 2: Implement generateActionRecommendations action</name>
  <files>convex/brainAnalysis.ts</files>
  <action>
Add the main action generation function:

**internalAction: generateActionRecommendations**
```typescript
export const generateActionRecommendations = internalAction({
  args: {
    workspaceId: v.id("workspaces"),
  },
  handler: async (ctx, args): Promise<ActionRecommendation[]> => {
    console.log(`[Brain] Generating action recommendations for workspace ${args.workspaceId}`);

    // 1. Get qualified leads needing follow-up
    const leadsNeedingFollowUp = await ctx.runQuery(internal.leads.getLeadsNeedingFollowUp, {
      workspaceId: args.workspaceId,
      daysSinceContact: 7,
    });

    // 2. Get all qualified and hot leads for other action types
    const qualifiedLeads = await ctx.runQuery(internal.leads.getLeadsByStatus, {
      workspaceId: args.workspaceId,
      status: 'qualified',
      limit: 50,
    });

    const recommendations: ActionRecommendation[] = [];

    // 3. Generate follow-up recommendations
    for (const lead of leadsNeedingFollowUp) {
      const priority = calculateActionPriority(lead);
      recommendations.push({
        contactId: lead._id,
        contactName: lead.name,
        contactPhone: lead.phone,
        actionType: 'follow_up',
        priority,
        urgency: determineUrgency(priority, lead),
        reason: `Qualified lead, ${lead.daysSinceContact || '7+'} days since last contact`,
      });
    }

    // 4. Generate handoff-ready recommendations for hot leads
    for (const lead of qualifiedLeads) {
      if (lead.leadTemperature === 'hot' && (lead.leadScore || 0) >= 70) {
        recommendations.push({
          contactId: lead._id,
          contactName: lead.name,
          contactPhone: lead.phone,
          actionType: 'handoff_ready',
          priority: 95,
          urgency: 'immediate',
          reason: `Hot lead (score: ${lead.leadScore}), ready for human contact`,
        });
      }
    }

    // 5. Generate opportunity alerts
    for (const lead of qualifiedLeads) {
      const opportunity = detectOpportunityType(lead);
      if (opportunity) {
        recommendations.push({
          contactId: lead._id,
          contactName: lead.name,
          contactPhone: lead.phone,
          actionType: 'opportunity_alert',
          priority: 90,
          urgency: 'immediate',
          reason: opportunity,
        });
      }
    }

    // 6. Sort by priority (highest first) and deduplicate by contact
    const seen = new Set<string>();
    const deduped = recommendations
      .sort((a, b) => b.priority - a.priority)
      .filter(r => {
        if (seen.has(r.contactId)) return false;
        seen.add(r.contactId);
        return true;
      });

    // 7. Store recommendations in database
    for (const rec of deduped.slice(0, 20)) { // Limit to top 20
      await ctx.runMutation(internal.brainActions.createActionRecommendation, {
        workspace_id: args.workspaceId,
        contact_id: rec.contactId as Id<"contacts">,
        action_type: rec.actionType,
        priority: rec.priority,
        urgency: rec.urgency,
        reason: rec.reason,
        suggested_message: rec.suggestedMessage,
      });
    }

    console.log(`[Brain] Generated ${deduped.length} action recommendations`);
    return deduped;
  },
});
```

Note: Add necessary imports at top of file:
```typescript
import { Id } from "./_generated/dataModel";
import { internal } from "./_generated/api";
```
  </action>
  <verify>Run `npx convex dev` - action compiles and can be triggered from dashboard</verify>
  <done>generateActionRecommendations creates prioritized actions for follow-ups, handoffs, and opportunities</done>
</task>

<task type="auto">
  <name>Task 3: Add personalized response template generation</name>
  <files>convex/brainAnalysis.ts</files>
  <action>
Add Grok-powered template generation for response_template actions:

**1. Template generation prompt:**
```typescript
const TEMPLATE_SYSTEM_PROMPT = `You are Brain, writing personalized WhatsApp follow-up messages for Indonesian SME leads.

RULES:
- Keep it under 200 characters (WhatsApp friendly)
- Use the lead's name
- Reference their specific pain point or business type
- Be warm and conversational, not salesy
- Write in the same language as the conversation (ID or EN)

Example outputs:
- "Halo Ahmad! Masih ingat pembicaraan kita soal otomasi WhatsApp? Ada waktu diskusi lebih lanjut?"
- "Hi Sarah! Just following up on our chat about CRM automation. Ready to see a demo?"`;
```

**2. Helper function to generate template:**
```typescript
async function generatePersonalizedTemplate(
  lead: ContactLead,
  language: 'id' | 'en'
): Promise<string> {
  const prompt = `Generate a follow-up message for:
Name: ${lead.name || 'there'}
Business: ${lead.businessType || 'unknown'}
Pain points: ${lead.painPoints?.join(', ') || 'general automation needs'}
Last contact: ${lead.daysSinceContact || 7} days ago
Language: ${language === 'id' ? 'Indonesian (Bahasa Indonesia)' : 'English'}

Write ONE short, personalized follow-up message.`;

  try {
    const result = await callGrokAPI(TEMPLATE_SYSTEM_PROMPT, prompt);
    return result.content.trim();
  } catch (error) {
    // Fallback to generic template
    return language === 'id'
      ? `Halo ${lead.name || 'there'}! Ada waktu untuk lanjut diskusi soal kebutuhan bisnis Anda?`
      : `Hi ${lead.name || 'there'}! Do you have time to continue our discussion about your business needs?`;
  }
}
```

**3. Update generateActionRecommendations to include templates for follow-ups:**

After generating follow_up recommendations, add template generation:
```typescript
// Generate personalized templates for top follow-ups (limit to 5 to control API costs)
const followUps = recommendations.filter(r => r.actionType === 'follow_up').slice(0, 5);
for (const rec of followUps) {
  const lead = leadsNeedingFollowUp.find(l => l._id === rec.contactId);
  if (lead) {
    rec.suggestedMessage = await generatePersonalizedTemplate(
      lead,
      (lead.sarahLanguage as 'id' | 'en') || 'id'
    );
  }
}
```
  </action>
  <verify>Run `npx convex dev` - template generation compiles, test with mock data</verify>
  <done>Follow-up actions include personalized WhatsApp message templates generated by Grok</done>
</task>

</tasks>

<verification>
1. Run `npx convex dev` - all code compiles
2. Manually trigger generateActionRecommendations from Convex dashboard
3. Check brainActions table - should have new recommendations
4. Verify priority sorting (highest priority first)
5. Verify template generation produces readable messages
</verification>

<success_criteria>
- Action recommendations generated for follow-ups, handoffs, opportunities
- Priority calculated using weighted algorithm (score + timing + urgency)
- Templates personalized with lead name, business, pain points
- Actions stored in brainActions table with correct urgency levels
- Deduplication ensures one action per contact
</success_criteria>

<output>
After completion, create `.planning/phases/05-grok-manager-bot/05-03-SUMMARY.md`
</output>
