---
phase: 05-grok-manager-bot
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - convex/brainAnalysis.ts
autonomous: true

must_haves:
  truths:
    - "Brain detects trending topics from conversations"
    - "Brain identifies objection patterns"
    - "Brain analyzes rejection reasons"
    - "Brain suggests FAQ additions for detected topics and objections (MGR-06)"
  artifacts:
    - path: "convex/brainAnalysis.ts"
      provides: "Conversation pattern analysis"
      exports: ["analyzeConversationPatterns", "getContactsWithNotes"]
  key_links:
    - from: "convex/brainAnalysis.ts"
      to: "convex/contacts"
      via: "reads notes for pattern analysis"
      pattern: "ctx.db.query.*contacts"
    - from: "convex/brainAnalysis.ts"
      to: "convex/brainInsights.ts"
      via: "stores detected patterns"
      pattern: "brainInsights.bulkCreateInsights"
---

<objective>
Implement conversation pattern analysis: trending topics, objection detection, rejection analysis, and FAQ recommendations.

Purpose: Help business owners understand what leads are asking about, what objections arise, why leads go cold, and get actionable FAQ suggestions.

Output: Working pattern analysis that detects topics, objections, rejection reasons, and generates FAQ recommendations using Grok.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/05-grok-manager-bot/05-CONTEXT.md
@.planning/phases/05-grok-manager-bot/05-RESEARCH.md
@convex/contacts.ts
@convex/sarah.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pattern analysis prompts, types, and helper query</name>
  <files>convex/brainAnalysis.ts</files>
  <action>
Add pattern analysis constants, types, AND the helper query to convex/brainAnalysis.ts. The query must be defined BEFORE the action that uses it:

**1. System prompt for pattern analysis (updated for MGR-06 FAQ suggestions):**
```typescript
const PATTERN_ANALYSIS_SYSTEM_PROMPT = `You are Brain, analyzing conversation patterns for an Indonesian SME CRM.

Your job is to identify:
1. TRENDING TOPICS - What do leads ask about most?
2. OBJECTION PATTERNS - Common concerns (pricing, timing, technical)
3. INTEREST SIGNALS - Buying intent indicators
4. REJECTION REASONS - Why leads went cold

For TRENDING TOPICS and OBJECTION PATTERNS, also generate FAQ SUGGESTIONS.

OUTPUT FORMAT (JSON only, no markdown):
{
  "trending_topics": [
    {
      "topic": "...",
      "frequency": N,
      "examples": ["...", "..."],
      "suggested_faqs": [
        { "question": "...", "suggested_answer": "..." }
      ]
    }
  ],
  "objections": [
    {
      "objection": "...",
      "frequency": N,
      "examples": ["...", "..."],
      "suggested_faqs": [
        { "question": "...", "suggested_answer": "..." }
      ]
    }
  ],
  "interest_signals": [
    { "signal": "...", "frequency": N, "examples": ["...", "..."] }
  ],
  "rejection_reasons": [
    { "reason": "...", "frequency": N, "examples": ["...", "..."] }
  ]
}

RULES:
- Only report patterns if you see 3+ examples
- Include actual quotes as examples (max 3 per pattern)
- frequency is the count of occurrences
- For trending_topics and objections, ALWAYS include suggested_faqs with 1-2 draft FAQ entries
- FAQ answers should be helpful, concise, and in Indonesian or English based on the examples
- If not enough data, return empty arrays with a "data_insufficient" flag`;
```

**2. Insight type for structured output (updated for MGR-06):**
```typescript
interface PatternAnalysisResult {
  trending_topics: Array<{
    topic: string;
    frequency: number;
    examples: string[];
    suggested_faqs?: Array<{
      question: string;
      suggested_answer: string;
    }>;
  }>;
  objections: Array<{
    objection: string;
    frequency: number;
    examples: string[];
    suggested_faqs?: Array<{
      question: string;
      suggested_answer: string;
    }>;
  }>;
  interest_signals: Array<{
    signal: string;
    frequency: number;
    examples: string[];
  }>;
  rejection_reasons: Array<{
    reason: string;
    frequency: number;
    examples: string[];
  }>;
  data_insufficient?: boolean;
}
```

**3. Time range helper:**
```typescript
function getTimeRangeCutoff(timeRange: 'today' | 'week' | 'month'): number {
  const now = Date.now();
  switch (timeRange) {
    case 'today':
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      return today.getTime();
    case 'week':
      return now - 7 * 24 * 60 * 60 * 1000;
    case 'month':
      return now - 30 * 24 * 60 * 60 * 1000;
    default:
      return now - 7 * 24 * 60 * 60 * 1000;
  }
}
```

**4. Helper query for contacts with notes (MUST be defined before analyzeConversationPatterns):**
```typescript
export const getContactsWithNotes = internalQuery({
  args: {
    workspaceId: v.id("workspaces"),
    since: v.number(),
  },
  handler: async (ctx, args) => {
    const contacts = await ctx.db
      .query("contacts")
      .withIndex("by_workspace", (q) => q.eq("workspace_id", args.workspaceId))
      .filter((q) => q.gte(q.field("lastActivityAt"), args.since))
      .collect();

    return contacts.map(c => ({
      _id: c._id,
      name: c.name,
      notes: c.notes,
      painPoints: c.painPoints,
      leadStatus: c.leadStatus,
      leadTemperature: c.leadTemperature,
    }));
  },
});
```

IMPORTANT: This query MUST be defined before the analyzeConversationPatterns action that uses it.
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Pattern analysis types, prompts, and getContactsWithNotes query defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement analyzeConversationPatterns action</name>
  <files>convex/brainAnalysis.ts</files>
  <action>
Add the main pattern analysis function. This task depends on Task 1 which defines getContactsWithNotes:

**internalAction: analyzeConversationPatterns**
```typescript
export const analyzeConversationPatterns = internalAction({
  args: {
    workspaceId: v.id("workspaces"),
    timeRange: v.union(v.literal("today"), v.literal("week"), v.literal("month")),
  },
  handler: async (ctx, args): Promise<PatternAnalysisResult | null> => {
    console.log(`[Brain] Analyzing conversation patterns for ${args.timeRange}`);

    const cutoff = getTimeRangeCutoff(args.timeRange);

    // 1. Get contacts with recent activity
    // Note: getContactsWithNotes is defined in Task 1 above this action
    const contacts = await ctx.runQuery(internal.brainAnalysis.getContactsWithNotes, {
      workspaceId: args.workspaceId,
      since: cutoff,
    });

    if (contacts.length === 0) {
      console.log("[Brain] No contacts with notes in time range");
      return { trending_topics: [], objections: [], interest_signals: [], rejection_reasons: [], data_insufficient: true };
    }

    // 2. Extract all notes/conversation snippets
    const allNotes: string[] = [];
    for (const contact of contacts) {
      if (contact.notes && contact.notes.length > 0) {
        for (const note of contact.notes) {
          // Only include notes from the time range
          if (note.addedAt >= cutoff) {
            allNotes.push(note.content);
          }
        }
      }
      // Also include pain points if extracted
      if (contact.painPoints) {
        allNotes.push(...contact.painPoints);
      }
    }

    if (allNotes.length < 10) {
      console.log(`[Brain] Only ${allNotes.length} notes found - insufficient data`);
      return { trending_topics: [], objections: [], interest_signals: [], rejection_reasons: [], data_insufficient: true };
    }

    // 3. Limit notes to first 100 to control token usage
    const limitedNotes = allNotes.slice(0, 100);

    // 4. Build analysis prompt
    const prompt = `Analyze these ${limitedNotes.length} conversation excerpts from the last ${args.timeRange}:

${limitedNotes.map((n, i) => `${i + 1}. "${n}"`).join('\n')}

Identify patterns following the output format in your instructions.
IMPORTANT: For trending_topics and objections, include suggested_faqs with draft FAQ content.`;

    // 5. Call Grok for analysis
    try {
      const result = await callGrokAPI(PATTERN_ANALYSIS_SYSTEM_PROMPT, prompt);

      // Parse JSON response
      let analysis: PatternAnalysisResult;
      try {
        const jsonMatch = result.content.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          analysis = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error("No JSON found in response");
        }
      } catch (parseError) {
        console.error("[Brain] Failed to parse pattern analysis:", result.content);
        return { trending_topics: [], objections: [], interest_signals: [], rejection_reasons: [], data_insufficient: true };
      }

      // 6. Store insights in database
      await storePatternInsights(ctx, args.workspaceId, analysis, args.timeRange);

      console.log(`[Brain] Pattern analysis complete: ${analysis.trending_topics.length} topics, ${analysis.objections.length} objections`);
      return analysis;

    } catch (error) {
      console.error("[Brain] Pattern analysis failed:", error);
      return null;
    }
  },
});
```
  </action>
  <verify>Run `npx convex dev` - action compiles and can process contacts</verify>
  <done>analyzeConversationPatterns extracts notes, calls Grok, and returns structured patterns</done>
</task>

<task type="auto">
  <name>Task 3: Add insight storage with FAQ suggestions (MGR-06)</name>
  <files>convex/brainAnalysis.ts</files>
  <action>
Add helper function to store pattern insights including suggested FAQs:

**Store pattern insights helper (not exported):**
```typescript
async function storePatternInsights(
  ctx: any, // ActionCtx
  workspaceId: Id<"workspaces">,
  analysis: PatternAnalysisResult,
  timeRange: string
): Promise<void> {
  const insights: Array<{
    workspace_id: Id<"workspaces">;
    insight_type: string;
    pattern: string;
    frequency: number;
    examples: string[];
    recommendation?: string;
    suggested_faqs?: Array<{ question: string; suggested_answer: string }>;
    confidence: string;
    time_range: string;
  }> = [];

  // Map trending topics to insights (with FAQ suggestions - MGR-06)
  for (const topic of analysis.trending_topics) {
    insights.push({
      workspace_id: workspaceId,
      insight_type: 'trending_topic',
      pattern: topic.topic,
      frequency: topic.frequency,
      examples: topic.examples.slice(0, 3),
      recommendation: `Consider adding FAQ about "${topic.topic}"`,
      suggested_faqs: topic.suggested_faqs || [], // MGR-06: Include FAQ suggestions
      confidence: topic.frequency >= 5 ? 'high' : topic.frequency >= 3 ? 'medium' : 'low',
      time_range: timeRange,
    });
  }

  // Map objections to insights (with FAQ suggestions - MGR-06)
  for (const objection of analysis.objections) {
    insights.push({
      workspace_id: workspaceId,
      insight_type: 'objection_pattern',
      pattern: objection.objection,
      frequency: objection.frequency,
      examples: objection.examples.slice(0, 3),
      recommendation: `Prepare response for "${objection.objection}" objection`,
      suggested_faqs: objection.suggested_faqs || [], // MGR-06: Include FAQ suggestions
      confidence: objection.frequency >= 5 ? 'high' : objection.frequency >= 3 ? 'medium' : 'low',
      time_range: timeRange,
    });
  }

  // Map interest signals to insights
  for (const signal of analysis.interest_signals) {
    insights.push({
      workspace_id: workspaceId,
      insight_type: 'interest_signal',
      pattern: signal.signal,
      frequency: signal.frequency,
      examples: signal.examples.slice(0, 3),
      confidence: signal.frequency >= 5 ? 'high' : 'medium',
      time_range: timeRange,
    });
  }

  // Map rejection reasons to insights
  for (const rejection of analysis.rejection_reasons) {
    insights.push({
      workspace_id: workspaceId,
      insight_type: 'rejection_analysis',
      pattern: rejection.reason,
      frequency: rejection.frequency,
      examples: rejection.examples.slice(0, 3),
      recommendation: `Address "${rejection.reason}" in onboarding or Sarah responses`,
      confidence: rejection.frequency >= 3 ? 'high' : 'medium',
      time_range: timeRange,
    });
  }

  // Bulk create insights if any found
  if (insights.length > 0) {
    await ctx.runMutation(internal.brainInsights.bulkCreateInsights, { insights });
    console.log(`[Brain] Stored ${insights.length} insights (with FAQ suggestions for topics/objections)`);
  }
}
```

**Add recommendation text generator:**
```typescript
function generateTopicRecommendation(topic: string): string {
  const keywords = topic.toLowerCase();
  if (keywords.includes('price') || keywords.includes('harga') || keywords.includes('biaya')) {
    return 'Consider adding a pricing FAQ or update Sarah to handle pricing questions better';
  }
  if (keywords.includes('demo') || keywords.includes('trial') || keywords.includes('coba')) {
    return 'Many leads want demos - consider automated demo scheduling';
  }
  if (keywords.includes('competitor') || keywords.includes('vs') || keywords.includes('bandingkan')) {
    return 'Prepare competitive comparison content';
  }
  return `Add FAQ or Sarah response for "${topic}"`;
}
```
  </action>
  <verify>Run `npx convex dev` - insights are stored correctly in brainInsights table with suggested_faqs</verify>
  <done>Pattern analysis results stored as individual insights with confidence levels, recommendations, and FAQ suggestions</done>
</task>

</tasks>

<verification>
1. Run `npx convex dev` - all code compiles
2. Manually trigger analyzeConversationPatterns from Convex dashboard
3. Check brainInsights table - should have new pattern records with suggested_faqs field
4. Verify confidence levels are calculated correctly
5. Verify FAQ suggestions are generated for trending_topics and objections (MGR-06)
</verification>

<success_criteria>
- Pattern analysis extracts notes from contacts within time range
- Grok identifies trending topics, objections, interest signals, rejection reasons
- Insights stored in brainInsights table with proper categorization
- Confidence levels based on frequency (3+ = medium, 5+ = high)
- Recommendations generated for actionable insights
- MGR-06: suggested_faqs field populated for trending_topics and objection_patterns
- Token limit (100 notes max) controls API costs
- getContactsWithNotes query defined BEFORE analyzeConversationPatterns action
</success_criteria>

<output>
After completion, create `.planning/phases/05-grok-manager-bot/05-04-SUMMARY.md`
</output>
