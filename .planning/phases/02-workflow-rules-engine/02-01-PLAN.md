# Plan 02-01: Workflow Rules Engine Core

---
phase: 02-workflow-rules-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/conversations.ts
  - src/lib/workflow/types.ts
  - src/lib/workflow/keyword-triggers.ts
  - src/lib/workflow/rules-engine.ts
autonomous: true

must_haves:
  truths:
    - "Keyword triggers are detected before AI processes messages"
    - "New leads vs returning leads are identified correctly"
    - "FAQ keywords match template responses"
    - "Unmatched messages pass through to AI fallback"
  artifacts:
    - path: "convex/conversations.ts"
      provides: "Internal query for lead type detection"
      exports: ["getByContactInternal"]
    - path: "src/lib/workflow/types.ts"
      provides: "Workflow type definitions"
      exports: ["WorkflowRule", "WorkflowConfig", "RuleMatch", "LeadType"]
    - path: "src/lib/workflow/keyword-triggers.ts"
      provides: "Keyword trigger matching logic"
      exports: ["matchKeywordTrigger", "KeywordTrigger"]
    - path: "src/lib/workflow/rules-engine.ts"
      provides: "Main workflow orchestrator"
      exports: ["processWithRules", "RulesResult"]
  key_links:
    - from: "src/lib/workflow/rules-engine.ts"
      to: "convex/conversations.ts"
      via: "import api.conversations.getByContactInternal"
      pattern: "getByContactInternal"
    - from: "src/lib/workflow/rules-engine.ts"
      to: "src/lib/workflow/keyword-triggers.ts"
      via: "import matchKeywordTrigger"
      pattern: "matchKeywordTrigger"
---

<objective>
Build the core workflow rules engine that processes messages BEFORE the AI processor.

Purpose: Enable rule-based automation (keyword triggers, lead routing, FAQ responses) to handle predictable cases efficiently, leaving AI for complex/conversational messages.

Output:
- Convex internal query for lead type detection (PREREQUISITE)
- Workflow type definitions
- Keyword trigger matching (handoff, manager bot)
- Lead type detection (new vs returning)
- Template response lookup for FAQs
- Clear pass-through to AI for unmatched messages
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-workflow-rules-engine/02-CONTEXT.md

Relevant existing code:
@src/lib/ari/processor.ts (current AI processor - rules engine will run before this)
@src/lib/kapso/client.ts (Kapso API client for sending responses)
@convex/conversations.ts (existing conversations module - add internal query here)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getByContactInternal query to Convex conversations</name>
  <files>convex/conversations.ts</files>
  <action>
Add an internal query `getByContactInternal` to `convex/conversations.ts` that the rules engine can use for lead type detection. This query does NOT require auth (internal use by webhook/rules engine).

Add this query after the existing `getByContactId` query (around line 350):

```typescript
/**
 * Internal query to get conversation by workspace + contact.
 *
 * Used by rules engine for lead type detection.
 * No auth check - internal use only (webhook/API routes handle auth).
 *
 * @param workspace_id - The workspace ID
 * @param contact_id - The contact ID
 * @returns The conversation with last_message_at, or null if not found
 */
export const getByContactInternal = query({
  args: {
    workspace_id: v.string(),
    contact_id: v.string(),
  },
  handler: async (ctx, args) => {
    // Query by contact_id using the existing index
    const conversation = await ctx.db
      .query('conversations')
      .withIndex('by_contact', (q) => q.eq('contact_id', args.contact_id as any))
      .first();

    // Verify workspace matches (security check)
    if (conversation && (conversation as any).workspace_id !== args.workspace_id) {
      return null;
    }

    return conversation;
  },
});
```

This query:
- Takes workspace_id + contact_id as strings (not v.id) for flexibility with HTTP client
- Uses existing `by_contact` index for efficient lookup
- Verifies workspace_id matches for security
- Returns the conversation document with `last_message_at` for lead type detection
- No auth check since webhook routes handle authorization
  </action>
  <verify>
Run: `npx convex dev --once` to ensure the query compiles and deploys.
Check: `grep "getByContactInternal" convex/conversations.ts` returns the function.
  </verify>
  <done>getByContactInternal query exists in convex/conversations.ts and is deployed.</done>
</task>

<task type="auto">
  <name>Task 2: Create workflow type definitions</name>
  <files>src/lib/workflow/types.ts</files>
  <action>
Create TypeScript types for the workflow rules system:

```typescript
// Lead type detection
export type LeadType = 'new' | 'returning';

// Keyword trigger types
export type TriggerAction = 'handoff' | 'manager_bot' | 'faq_response' | 'pass_through';

export interface KeywordTrigger {
  id: string;
  keywords: string[];           // List of keywords to match
  action: TriggerAction;
  response_template?: string;   // For FAQ responses
  case_sensitive: boolean;
  match_mode: 'exact' | 'contains' | 'starts_with';
  enabled: boolean;
}

// FAQ template
export interface FAQTemplate {
  id: string;
  trigger_keywords: string[];
  response: string;
  enabled: boolean;
}

// Rule match result
export interface RuleMatch {
  matched: boolean;
  rule_id: string | null;
  action: TriggerAction;
  response?: string;
  metadata?: Record<string, unknown>;
}

// Workflow configuration (stored in database, configurable via Settings UI)
export interface WorkflowConfig {
  workspace_id: string;
  keyword_triggers: KeywordTrigger[];
  faq_templates: FAQTemplate[];
  lead_routing: {
    new_lead_greeting: string;
    returning_lead_greeting: string;
    detection_window_hours: number;  // Default: 24
  };
  ai_fallback_enabled: boolean;
}

// Rules processing result
export interface RulesResult {
  handled: boolean;              // true = rules handled it, false = pass to AI
  action: TriggerAction;
  response?: string;             // Response to send (if handled)
  lead_type: LeadType;           // new or returning
  matched_rule?: string;         // Which rule matched
  should_handoff?: boolean;      // Trigger handoff flow
  should_trigger_manager?: boolean; // Trigger Grok manager bot
}

// Default configuration (placeholder values - configured in Phase 2.5)
export const DEFAULT_WORKFLOW_CONFIG: Omit<WorkflowConfig, 'workspace_id'> = {
  keyword_triggers: [
    {
      id: 'handoff-trigger',
      keywords: ['human', 'agent', 'speak to person', 'real person'],
      action: 'handoff',
      case_sensitive: false,
      match_mode: 'contains',
      enabled: true,
    },
    {
      id: 'manager-trigger',
      keywords: ['!summary', '!report', '!analysis'],
      action: 'manager_bot',
      case_sensitive: false,
      match_mode: 'starts_with',
      enabled: true,
    },
  ],
  faq_templates: [
    {
      id: 'pricing-faq',
      trigger_keywords: ['harga', 'price', 'pricing', 'biaya', 'cost', 'berapa'],
      response: '[Placeholder: Pricing info - configure in Settings]',
      enabled: true,
    },
    {
      id: 'services-faq',
      trigger_keywords: ['layanan', 'services', 'service', 'apa saja'],
      response: '[Placeholder: Services info - configure in Settings]',
      enabled: true,
    },
    {
      id: 'hours-faq',
      trigger_keywords: ['jam', 'hours', 'buka', 'open', 'tutup', 'close'],
      response: '[Placeholder: Business hours - configure in Settings]',
      enabled: true,
    },
  ],
  lead_routing: {
    new_lead_greeting: '[Placeholder: New lead greeting - configure in Settings]',
    returning_lead_greeting: '[Placeholder: Welcome back message - configure in Settings]',
    detection_window_hours: 24,
  },
  ai_fallback_enabled: true,
};
```

Key design decisions:
- All values are placeholders (configured in Phase 2.5 Settings UI)
- Keyword triggers support multiple match modes
- FAQ templates are separate from keyword triggers for clarity
- Lead routing has configurable detection window
  </action>
  <verify>
Run: `npx tsc --noEmit src/lib/workflow/types.ts`
No TypeScript errors should occur.
  </verify>
  <done>Type definitions exist with all workflow rule types exported.</done>
</task>

<task type="auto">
  <name>Task 3: Create keyword trigger matching logic</name>
  <files>src/lib/workflow/keyword-triggers.ts</files>
  <action>
Create the keyword trigger matching function:

```typescript
import type { KeywordTrigger, RuleMatch, FAQTemplate } from './types';

/**
 * Normalize text for matching (lowercase, trim whitespace)
 */
function normalizeText(text: string, caseSensitive: boolean): string {
  const trimmed = text.trim();
  return caseSensitive ? trimmed : trimmed.toLowerCase();
}

/**
 * Check if message matches a keyword based on match mode
 */
function matchesKeyword(
  message: string,
  keyword: string,
  matchMode: 'exact' | 'contains' | 'starts_with',
  caseSensitive: boolean
): boolean {
  const normalizedMessage = normalizeText(message, caseSensitive);
  const normalizedKeyword = normalizeText(keyword, caseSensitive);

  switch (matchMode) {
    case 'exact':
      return normalizedMessage === normalizedKeyword;
    case 'contains':
      return normalizedMessage.includes(normalizedKeyword);
    case 'starts_with':
      return normalizedMessage.startsWith(normalizedKeyword);
    default:
      return false;
  }
}

/**
 * Match message against keyword triggers
 * Returns the first matching trigger, or null if no match
 */
export function matchKeywordTrigger(
  message: string,
  triggers: KeywordTrigger[]
): RuleMatch {
  for (const trigger of triggers) {
    if (!trigger.enabled) continue;

    for (const keyword of trigger.keywords) {
      if (matchesKeyword(message, keyword, trigger.match_mode, trigger.case_sensitive)) {
        return {
          matched: true,
          rule_id: trigger.id,
          action: trigger.action,
          response: trigger.response_template,
          metadata: { matched_keyword: keyword },
        };
      }
    }
  }

  return {
    matched: false,
    rule_id: null,
    action: 'pass_through',
  };
}

/**
 * Match message against FAQ templates
 * Returns matching FAQ response or null
 */
export function matchFAQTemplate(
  message: string,
  templates: FAQTemplate[]
): RuleMatch {
  const normalizedMessage = message.toLowerCase().trim();

  for (const template of templates) {
    if (!template.enabled) continue;

    for (const keyword of template.trigger_keywords) {
      if (normalizedMessage.includes(keyword.toLowerCase())) {
        return {
          matched: true,
          rule_id: template.id,
          action: 'faq_response',
          response: template.response,
          metadata: { matched_keyword: keyword },
        };
      }
    }
  }

  return {
    matched: false,
    rule_id: null,
    action: 'pass_through',
  };
}

/**
 * Check if message is a command (starts with ! or /)
 */
export function isCommand(message: string): boolean {
  const trimmed = message.trim();
  return trimmed.startsWith('!') || trimmed.startsWith('/');
}
```

Design notes:
- Separate functions for keyword triggers and FAQ templates
- Supports case-insensitive matching by default
- Returns structured RuleMatch for consistent handling
- Commands (!summary) are detected separately
  </action>
  <verify>
Run: `npx tsc --noEmit src/lib/workflow/keyword-triggers.ts`
No TypeScript errors should occur.
  </verify>
  <done>Keyword trigger matching functions exist and handle all match modes.</done>
</task>

<task type="auto">
  <name>Task 4: Create main rules engine orchestrator</name>
  <files>src/lib/workflow/rules-engine.ts</files>
  <action>
Create the main workflow rules engine that orchestrates all rule checks:

```typescript
import { ConvexHttpClient } from 'convex/browser';
import { api } from '@/../convex/_generated/api';
import type {
  WorkflowConfig,
  RulesResult,
  LeadType,
  TriggerAction,
} from './types';
import { DEFAULT_WORKFLOW_CONFIG } from './types';
import { matchKeywordTrigger, matchFAQTemplate, isCommand } from './keyword-triggers';

const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

/**
 * Parameters for rules engine processing
 */
export interface ProcessRulesParams {
  workspaceId: string;
  contactId: string;
  contactPhone: string;
  message: string;
}

/**
 * Detect if contact is new or returning based on conversation history
 * Uses thread-based detection with configurable time window
 */
async function detectLeadType(
  workspaceId: string,
  contactId: string,
  detectionWindowHours: number
): Promise<LeadType> {
  try {
    // Check for existing conversation with recent messages
    const conversation = await convex.query(api.conversations.getByContactInternal, {
      workspace_id: workspaceId,
      contact_id: contactId,
    });

    if (!conversation) {
      return 'new';
    }

    // Check if last message was within detection window
    const lastMessageTime = conversation.last_message_at;
    if (!lastMessageTime) {
      return 'new';
    }

    const windowMs = detectionWindowHours * 60 * 60 * 1000;
    const timeSinceLastMessage = Date.now() - lastMessageTime;

    return timeSinceLastMessage < windowMs ? 'returning' : 'new';
  } catch (error) {
    console.error('[RulesEngine] Failed to detect lead type:', error);
    return 'new'; // Default to new on error
  }
}

/**
 * Get workflow configuration for workspace
 * Falls back to defaults if not configured
 */
async function getWorkflowConfig(workspaceId: string): Promise<WorkflowConfig> {
  try {
    // TODO: Query from database once Settings UI (Phase 2.5) stores config
    // For now, return defaults
    // const config = await convex.query(api.workflows.getConfig, { workspace_id: workspaceId });
    // if (config) return config;

    return {
      workspace_id: workspaceId,
      ...DEFAULT_WORKFLOW_CONFIG,
    };
  } catch (error) {
    console.error('[RulesEngine] Failed to get config:', error);
    return {
      workspace_id: workspaceId,
      ...DEFAULT_WORKFLOW_CONFIG,
    };
  }
}

/**
 * Main rules engine processor
 *
 * Processing order:
 * 1. Detect lead type (new vs returning)
 * 2. Check keyword triggers (handoff, manager bot)
 * 3. Check FAQ templates
 * 4. If no match, pass through to AI
 *
 * @returns RulesResult indicating whether rules handled the message
 */
export async function processWithRules(
  params: ProcessRulesParams
): Promise<RulesResult> {
  const { workspaceId, contactId, message } = params;
  const startTime = Date.now();

  console.log(`[RulesEngine] Processing message for contact ${contactId}`);

  // 1. Get workflow configuration
  const config = await getWorkflowConfig(workspaceId);

  // 2. Detect lead type
  const leadType = await detectLeadType(
    workspaceId,
    contactId,
    config.lead_routing.detection_window_hours
  );
  console.log(`[RulesEngine] Lead type: ${leadType}`);

  // 3. Check keyword triggers (highest priority)
  const triggerMatch = matchKeywordTrigger(message, config.keyword_triggers);

  if (triggerMatch.matched) {
    console.log(`[RulesEngine] Keyword trigger matched: ${triggerMatch.rule_id}`);

    const duration = Date.now() - startTime;
    console.log(`[RulesEngine] Completed in ${duration}ms (keyword trigger)`);

    return {
      handled: true,
      action: triggerMatch.action,
      response: triggerMatch.response,
      lead_type: leadType,
      matched_rule: triggerMatch.rule_id || undefined,
      should_handoff: triggerMatch.action === 'handoff',
      should_trigger_manager: triggerMatch.action === 'manager_bot',
    };
  }

  // 4. Check FAQ templates (second priority)
  const faqMatch = matchFAQTemplate(message, config.faq_templates);

  if (faqMatch.matched) {
    console.log(`[RulesEngine] FAQ template matched: ${faqMatch.rule_id}`);

    const duration = Date.now() - startTime;
    console.log(`[RulesEngine] Completed in ${duration}ms (FAQ template)`);

    return {
      handled: true,
      action: 'faq_response',
      response: faqMatch.response,
      lead_type: leadType,
      matched_rule: faqMatch.rule_id || undefined,
    };
  }

  // 5. No match - pass through to AI
  const duration = Date.now() - startTime;
  console.log(`[RulesEngine] No rule match, passing to AI (${duration}ms)`);

  if (!config.ai_fallback_enabled) {
    // AI fallback disabled - return generic response
    return {
      handled: true,
      action: 'pass_through',
      response: 'Pesan Anda telah diterima. Tim kami akan segera merespons.',
      lead_type: leadType,
    };
  }

  return {
    handled: false,
    action: 'pass_through',
    lead_type: leadType,
  };
}

/**
 * Check if rules engine is enabled for a workspace
 */
export async function isRulesEngineEnabled(workspaceId: string): Promise<boolean> {
  // Always enabled for now - could be workspace setting later
  return true;
}

// Re-export types for convenience
export type { RulesResult, LeadType, TriggerAction };
```

Key design decisions:
- Rules engine runs BEFORE AI processor
- Processing order: keyword triggers -> FAQ templates -> AI fallback
- Lead type detection uses conversation history via getByContactInternal
- Configuration is workspace-specific (placeholder defaults for now)
- Clear logging for debugging
  </action>
  <verify>
Run: `npx tsc --noEmit src/lib/workflow/rules-engine.ts`
No TypeScript errors should occur.
  </verify>
  <done>Rules engine orchestrator exists with all processing logic.</done>
</task>

</tasks>

<verification>
1. All files compile without TypeScript errors: `npm run type-check`
2. Convex query deployed: `grep "getByContactInternal" convex/conversations.ts`
3. Rules engine exports are accessible: `grep -l "processWithRules" src/lib/workflow/*.ts`
4. Type definitions are complete: `grep -l "WorkflowConfig" src/lib/workflow/*.ts`
</verification>

<success_criteria>
- [ ] `convex/conversations.ts` has getByContactInternal query
- [ ] `src/lib/workflow/types.ts` exists with all type definitions
- [ ] `src/lib/workflow/keyword-triggers.ts` exists with matching functions
- [ ] `src/lib/workflow/rules-engine.ts` exists with main processor
- [ ] All files compile without errors
- [ ] Rules engine exports `processWithRules` function
- [ ] Keyword triggers support handoff and manager bot actions
- [ ] FAQ templates support multiple keywords per template
- [ ] Lead type detection distinguishes new vs returning leads
</success_criteria>

<output>
After completion, create `.planning/phases/02-workflow-rules-engine/02-01-SUMMARY.md`
</output>
