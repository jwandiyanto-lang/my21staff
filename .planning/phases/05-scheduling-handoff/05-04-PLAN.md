---
phase: 05-scheduling-handoff
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/ari/handoff.ts
  - src/app/api/appointments/notify/route.ts
  - src/app/api/cron/appointment-reminders/route.ts
  - src/components/inbox/appointment-card.tsx
autonomous: true

must_haves:
  truths:
    - "AI summary added to contact notes after booking"
    - "Lead status updates to hot_lead after booking"
    - "Tag added to contact based on consultation type"
    - "Consultant receives CRM notification for new booking"
    - "Meeting link reminder sent 1 hour before appointment"
  artifacts:
    - path: "src/lib/ari/handoff.ts"
      provides: "Handoff logic with summary generation"
      exports: ["generateConversationSummary", "executeHandoff"]
      min_lines: 60
    - path: "src/app/api/cron/appointment-reminders/route.ts"
      provides: "Cron endpoint for meeting reminders"
      exports: ["GET"]
  key_links:
    - from: "src/lib/ari/handoff.ts"
      to: "contacts table"
      via: "Supabase update"
      pattern: "supabase.*contacts.*update"
---

<objective>
Implement handoff automation and appointment notifications.

Purpose: After a lead books an appointment, prepare consultant with context (AI summary, score, tags) and ensure meeting link is delivered at the right time (1 hour before).

Output: Handoff module, notification API, reminder cron endpoint, and appointment display component.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-scheduling-handoff/05-CONTEXT.md
@.planning/phases/03-lead-scoring-routing/03-04-SUMMARY.md
@src/lib/ari/types.ts
@src/lib/ari/processor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create handoff module with summary generation</name>
  <files>src/lib/ari/handoff.ts</files>
  <action>
Create handoff module that generates AI conversation summary and updates contact.

```typescript
/**
 * ARI Handoff Module
 *
 * Handles the transition from ARI conversation to human consultant.
 * Generates conversation summary, updates contact status and tags,
 * and notifies the assigned consultant.
 */

import type { SupabaseClient } from '@supabase/supabase-js';
import type { ARIMessage, ARIConversation, LeadTemperature, ScoreBreakdown } from './types';

// ===========================================
// Type Definitions
// ===========================================

export interface HandoffParams {
  workspaceId: string;
  contactId: string;
  ariConversationId: string;
  appointmentId?: string;
  consultationType: 'consultation' | 'community' | 'cold_followup';
  consultantId?: string;
}

export interface HandoffResult {
  success: boolean;
  summary?: string;
  error?: string;
}

// ===========================================
// Summary Generation
// ===========================================

/**
 * Generate a concise summary of the ARI conversation
 *
 * Creates a 3-5 sentence summary highlighting:
 * - Lead's main interest/goal
 * - Key qualifications (budget, timeline, documents)
 * - Readiness level and concerns
 *
 * @param messages - ARI conversation messages
 * @param context - ARI conversation context
 * @returns Summary string
 */
export function generateConversationSummary(
  messages: ARIMessage[],
  context: {
    lead_data?: Record<string, unknown>;
    score_breakdown?: ScoreBreakdown;
    lead_temperature?: LeadTemperature;
    form_answers?: Record<string, string>;
  }
): string {
  const parts: string[] = [];

  // Lead temperature and score
  if (context.lead_temperature && context.score_breakdown) {
    const temp = context.lead_temperature;
    const score = context.score_breakdown.total;
    parts.push(`Lead Score: ${score}/100 (${temp === 'hot' ? 'Hot' : temp === 'warm' ? 'Warm' : 'Cold'} lead)`);
  }

  // Form data summary
  const formData = context.form_answers || (context.lead_data as Record<string, string>) || {};
  const highlights: string[] = [];

  if (formData.country || formData.destination_country) {
    highlights.push(`Negara tujuan: ${formData.country || formData.destination_country}`);
  }
  if (formData.budget || formData.budget_range) {
    highlights.push(`Budget: ${formData.budget || formData.budget_range}`);
  }
  if (formData.timeline) {
    highlights.push(`Timeline: ${formData.timeline}`);
  }
  if (formData.english_level) {
    highlights.push(`English: ${formData.english_level}`);
  }

  if (highlights.length > 0) {
    parts.push('Key info: ' + highlights.join(', '));
  }

  // Extract key topics from messages
  const userMessages = messages
    .filter(m => m.role === 'user')
    .map(m => m.content.toLowerCase());

  const topicKeywords = {
    'universitas': 'Tanya universitas',
    'biaya': 'Tanya biaya',
    'beasiswa': 'Tertarik beasiswa',
    'visa': 'Tanya visa',
    'ielts': 'Perlu bantuan IELTS',
    'dokumen': 'Tanya dokumen',
  };

  const mentionedTopics: string[] = [];
  for (const [keyword, label] of Object.entries(topicKeywords)) {
    if (userMessages.some(msg => msg.includes(keyword))) {
      mentionedTopics.push(label);
    }
  }

  if (mentionedTopics.length > 0) {
    parts.push('Topik dibahas: ' + mentionedTopics.slice(0, 3).join(', '));
  }

  // Conversation length indicator
  const msgCount = messages.length;
  if (msgCount > 20) {
    parts.push('Percakapan panjang - lead sangat engaged');
  } else if (msgCount > 10) {
    parts.push('Percakapan aktif');
  }

  // Default if nothing extracted
  if (parts.length === 0) {
    return 'Lead dari WhatsApp via ARI. Lihat conversation history untuk detail.';
  }

  return parts.join('. ') + '.';
}

/**
 * Get consultation type tag name
 */
export function getConsultationTag(consultationType: 'consultation' | 'community' | 'cold_followup'): string {
  switch (consultationType) {
    case 'consultation':
      return '1on1';
    case 'community':
      return 'Community';
    case 'cold_followup':
      return 'Follow-up';
    default:
      return '1on1';
  }
}

// ===========================================
// Handoff Execution
// ===========================================

/**
 * Execute full handoff process
 *
 * 1. Generate conversation summary
 * 2. Update contact notes with summary
 * 3. Update lead status to hot_lead
 * 4. Add consultation type tag
 * 5. Set due date if appointment exists
 * 6. Create notification for consultant
 */
export async function executeHandoff(
  supabase: SupabaseClient,
  params: HandoffParams
): Promise<HandoffResult> {
  const {
    workspaceId,
    contactId,
    ariConversationId,
    appointmentId,
    consultationType,
    consultantId,
  } = params;

  try {
    // 1. Get ARI conversation with messages
    const { data: ariConv, error: convError } = await supabase
      .from('ari_conversations')
      .select('*, ari_messages(*)')
      .eq('id', ariConversationId)
      .single();

    if (convError || !ariConv) {
      console.error('[Handoff] Failed to get conversation:', convError);
      return { success: false, error: 'Conversation not found' };
    }

    // 2. Get contact for existing notes
    const { data: contact } = await supabase
      .from('contacts')
      .select('notes, tags, metadata')
      .eq('id', contactId)
      .single();

    // 3. Generate summary
    const summary = generateConversationSummary(
      ariConv.ari_messages || [],
      {
        lead_data: ariConv.context?.lead_data,
        score_breakdown: ariConv.context?.score_breakdown,
        lead_temperature: ariConv.lead_temperature,
        form_answers: ariConv.context?.form_answers,
      }
    );

    // 4. Build updated notes
    const timestamp = new Date().toLocaleString('id-ID', {
      dateStyle: 'short',
      timeStyle: 'short',
    });
    const existingNotes = contact?.notes || '';
    const newNotes = existingNotes
      ? `${existingNotes}\n\n---\n[ARI Summary - ${timestamp}]\n${summary}`
      : `[ARI Summary - ${timestamp}]\n${summary}`;

    // 5. Build updated tags
    const existingTags = contact?.tags || [];
    const consultationTag = getConsultationTag(consultationType);
    const newTags = existingTags.includes(consultationTag)
      ? existingTags
      : [...existingTags, consultationTag];

    // 6. Get appointment date for due_date
    let dueDate: string | null = null;
    if (appointmentId) {
      const { data: appointment } = await supabase
        .from('ari_appointments')
        .select('scheduled_at')
        .eq('id', appointmentId)
        .single();

      if (appointment) {
        dueDate = appointment.scheduled_at.split('T')[0]; // YYYY-MM-DD
      }
    }

    // 7. Update contact
    const updateData: Record<string, unknown> = {
      notes: newNotes,
      tags: newTags,
      lead_status: 'hot_lead',
      updated_at: new Date().toISOString(),
    };

    if (dueDate) {
      updateData.due_date = dueDate;
    }

    const { error: updateError } = await supabase
      .from('contacts')
      .update(updateData)
      .eq('id', contactId);

    if (updateError) {
      console.error('[Handoff] Failed to update contact:', updateError);
      return { success: false, error: 'Failed to update contact' };
    }

    // 8. Create notification for consultant (if assigned)
    if (consultantId) {
      await createConsultantNotification(supabase, {
        workspaceId,
        consultantId,
        contactId,
        appointmentId,
        summary,
      });
    }

    console.log(`[Handoff] Completed for contact ${contactId}`);
    return { success: true, summary };

  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    console.error('[Handoff] Error:', error);
    return { success: false, error: message };
  }
}

// ===========================================
// Consultant Notification
// ===========================================

interface NotificationParams {
  workspaceId: string;
  consultantId: string;
  contactId: string;
  appointmentId?: string;
  summary: string;
}

/**
 * Create in-app notification for consultant
 *
 * Uses workspace_notifications table (or creates if not exists).
 * Falls back to storing in a notifications array in workspace_members.settings.
 */
async function createConsultantNotification(
  supabase: SupabaseClient,
  params: NotificationParams
): Promise<void> {
  const { workspaceId, consultantId, contactId, appointmentId, summary } = params;

  // Get contact name for notification
  const { data: contact } = await supabase
    .from('contacts')
    .select('name')
    .eq('id', contactId)
    .single();

  const contactName = contact?.name || 'New lead';

  // Try to create notification in workspace_members settings
  // This is a simple approach - store notifications in JSONB array
  const { data: member } = await supabase
    .from('workspace_members')
    .select('settings')
    .eq('workspace_id', workspaceId)
    .eq('user_id', consultantId)
    .single();

  const settings = (member?.settings || {}) as Record<string, unknown>;
  const notifications = (settings.notifications || []) as Array<Record<string, unknown>>;

  // Add new notification
  notifications.unshift({
    id: crypto.randomUUID(),
    type: 'appointment_booked',
    title: `Konsultasi baru: ${contactName}`,
    message: summary.slice(0, 100) + (summary.length > 100 ? '...' : ''),
    contactId,
    appointmentId,
    read: false,
    createdAt: new Date().toISOString(),
  });

  // Keep only last 50 notifications
  const trimmedNotifications = notifications.slice(0, 50);

  await supabase
    .from('workspace_members')
    .update({
      settings: { ...settings, notifications: trimmedNotifications },
    })
    .eq('workspace_id', workspaceId)
    .eq('user_id', consultantId);

  console.log(`[Handoff] Created notification for consultant ${consultantId}`);
}
```

This stores notifications in workspace_members.settings JSONB for simplicity - no new table needed.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Handoff module generates summary and updates contact</done>
</task>

<task type="auto">
  <name>Task 2: Create appointment reminder cron endpoint</name>
  <files>src/app/api/cron/appointment-reminders/route.ts</files>
  <action>
Create cron endpoint that sends meeting link reminders 1 hour before appointments.

```typescript
/**
 * Appointment Reminders Cron
 *
 * Called by Vercel Cron every 15 minutes to send meeting link
 * reminders for appointments starting in ~1 hour.
 *
 * Cron schedule: "0,15,30,45 * * * *" (every 15 min)
 */

import { NextResponse } from 'next/server';
import { createApiAdminClient } from '@/lib/supabase/server';
import { sendMessage, type KapsoCredentials } from '@/lib/kapso/client';
import { safeDecrypt } from '@/lib/crypto';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';
export const maxDuration = 30;

// Vercel cron config
export const config = {
  schedule: '0,15,30,45 * * * *', // Every 15 minutes
};

export async function GET(request: Request) {
  // Verify cron secret if configured
  const authHeader = request.headers.get('authorization');
  const cronSecret = process.env.CRON_SECRET;

  if (cronSecret && authHeader !== `Bearer ${cronSecret}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const supabase = createApiAdminClient();

  // Find appointments starting in 45-75 minutes that haven't had reminder sent
  const now = new Date();
  const windowStart = new Date(now.getTime() + 45 * 60 * 1000); // 45 min from now
  const windowEnd = new Date(now.getTime() + 75 * 60 * 1000);   // 75 min from now

  const { data: appointments, error } = await supabase
    .from('ari_appointments')
    .select(`
      id,
      workspace_id,
      ari_conversation_id,
      scheduled_at,
      duration_minutes,
      meeting_link,
      status,
      ari_conversations!inner (
        contact_id,
        contacts!inner (
          phone
        )
      ),
      workspaces!inner (
        meta_access_token,
        kapso_phone_id
      )
    `)
    .gte('scheduled_at', windowStart.toISOString())
    .lte('scheduled_at', windowEnd.toISOString())
    .is('reminder_sent_at', null)
    .in('status', ['scheduled', 'confirmed']);

  if (error) {
    console.error('[Cron] Failed to fetch appointments:', error);
    return NextResponse.json({ error: 'Database error' }, { status: 500 });
  }

  console.log(`[Cron] Found ${appointments?.length || 0} appointments needing reminders`);

  let sent = 0;
  let failed = 0;

  for (const apt of appointments || []) {
    try {
      // Extract nested data
      const contact = (apt.ari_conversations as any)?.contacts;
      const workspace = apt.workspaces as any;

      if (!contact?.phone || !workspace?.meta_access_token) {
        console.log(`[Cron] Skipping ${apt.id} - missing phone or credentials`);
        continue;
      }

      // Build reminder message
      const aptTime = new Date(apt.scheduled_at);
      const timeStr = aptTime.toLocaleTimeString('id-ID', {
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'Asia/Jakarta',
      });

      let message = `Reminder: Konsultasi kamu dimulai dalam 1 jam!\n\n`;
      message += `Waktu: ${timeStr} WIB\n`;
      message += `Durasi: ${apt.duration_minutes} menit\n`;

      if (apt.meeting_link) {
        message += `\nLink meeting: ${apt.meeting_link}`;
      } else {
        message += `\nKonsultan akan menghubungi kamu sebentar lagi.`;
      }

      // Send via Kapso
      const credentials: KapsoCredentials = {
        apiKey: safeDecrypt(workspace.meta_access_token),
        phoneId: workspace.kapso_phone_id,
      };

      await sendMessage(credentials, contact.phone, message);

      // Mark reminder as sent
      await supabase
        .from('ari_appointments')
        .update({
          reminder_sent_at: new Date().toISOString(),
          status: 'confirmed', // Upgrade from scheduled to confirmed
        })
        .eq('id', apt.id);

      sent++;
      console.log(`[Cron] Sent reminder for appointment ${apt.id}`);

    } catch (err) {
      console.error(`[Cron] Failed to send reminder for ${apt.id}:`, err);
      failed++;
    }
  }

  return NextResponse.json({
    success: true,
    sent,
    failed,
    total: appointments?.length || 0,
  });
}
```

Add to vercel.json cron config (create file if doesn't exist or update existing):
```json
{
  "crons": [
    {
      "path": "/api/cron/appointment-reminders",
      "schedule": "0,15,30,45 * * * *"
    }
  ]
}
```
  </action>
  <verify>
Build passes.
Test locally: `curl http://localhost:3000/api/cron/appointment-reminders`
Should return { success: true, sent: 0, failed: 0, total: 0 }
  </verify>
  <done>Cron sends meeting reminders 1 hour before appointments</done>
</task>

<task type="auto">
  <name>Task 3: Create appointment card component for inbox sidebar</name>
  <files>src/components/inbox/appointment-card.tsx</files>
  <action>
Create component to display upcoming appointment in the inbox contact sidebar.

```tsx
'use client'

import { useState, useEffect } from 'react'
import { Calendar, Clock, User, Video, CheckCircle, XCircle } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { cn } from '@/lib/utils'
import { toast } from 'sonner'

interface Appointment {
  id: string
  scheduled_at: string
  duration_minutes: number
  meeting_link: string | null
  status: 'scheduled' | 'confirmed' | 'completed' | 'cancelled' | 'no_show'
  consultant_id: string | null
  consultant_name?: string
}

interface AppointmentCardProps {
  workspaceId: string
  contactId: string
}

export function AppointmentCard({ workspaceId, contactId }: AppointmentCardProps) {
  const [appointment, setAppointment] = useState<Appointment | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    fetchAppointment()
  }, [contactId])

  async function fetchAppointment() {
    try {
      // Fetch via API or direct Supabase call
      const res = await fetch(
        `/api/contacts/${contactId}/appointment?workspace_id=${workspaceId}`
      )
      if (res.ok) {
        const data = await res.json()
        setAppointment(data.appointment)
      }
    } catch (error) {
      console.error('Failed to fetch appointment:', error)
    } finally {
      setIsLoading(false)
    }
  }

  async function handleStatusUpdate(newStatus: 'completed' | 'no_show' | 'cancelled') {
    if (!appointment) return

    try {
      const res = await fetch(`/api/appointments/${appointment.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status: newStatus }),
      })

      if (!res.ok) throw new Error('Failed to update')

      setAppointment({ ...appointment, status: newStatus })
      toast.success(
        newStatus === 'completed' ? 'Marked as completed' :
        newStatus === 'no_show' ? 'Marked as no-show' :
        'Appointment cancelled'
      )
    } catch (error) {
      toast.error('Gagal mengubah status')
    }
  }

  if (isLoading) {
    return (
      <div className="animate-pulse bg-muted rounded-lg h-24" />
    )
  }

  if (!appointment) {
    return null // No appointment to display
  }

  const aptDate = new Date(appointment.scheduled_at)
  const isPast = aptDate < new Date()
  const isUpcoming = !isPast && appointment.status === 'scheduled' || appointment.status === 'confirmed'

  const statusColors: Record<string, string> = {
    scheduled: 'bg-blue-500/10 text-blue-600',
    confirmed: 'bg-green-500/10 text-green-600',
    completed: 'bg-gray-500/10 text-gray-600',
    cancelled: 'bg-red-500/10 text-red-600',
    no_show: 'bg-orange-500/10 text-orange-600',
  }

  const statusLabels: Record<string, string> = {
    scheduled: 'Terjadwal',
    confirmed: 'Dikonfirmasi',
    completed: 'Selesai',
    cancelled: 'Dibatalkan',
    no_show: 'No Show',
  }

  return (
    <div className="bg-card rounded-lg border border-border overflow-hidden">
      {/* Header */}
      <div className="px-4 py-3 bg-muted/50 border-b border-border flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Calendar className="w-4 h-4 text-muted-foreground" />
          <span className="text-sm font-medium">Konsultasi</span>
        </div>
        <span className={cn(
          'text-xs font-medium px-2 py-1 rounded-full',
          statusColors[appointment.status]
        )}>
          {statusLabels[appointment.status]}
        </span>
      </div>

      {/* Content */}
      <div className="p-4 space-y-3">
        {/* Date and Time */}
        <div className="flex items-start gap-3">
          <Clock className="w-4 h-4 text-muted-foreground mt-0.5" />
          <div>
            <p className="text-sm font-medium">
              {aptDate.toLocaleDateString('id-ID', {
                weekday: 'long',
                day: 'numeric',
                month: 'long',
              })}
            </p>
            <p className="text-xs text-muted-foreground">
              {aptDate.toLocaleTimeString('id-ID', {
                hour: '2-digit',
                minute: '2-digit',
              })} WIB â€¢ {appointment.duration_minutes} menit
            </p>
          </div>
        </div>

        {/* Consultant */}
        {appointment.consultant_name && (
          <div className="flex items-center gap-3">
            <User className="w-4 h-4 text-muted-foreground" />
            <span className="text-sm">{appointment.consultant_name}</span>
          </div>
        )}

        {/* Meeting Link */}
        {appointment.meeting_link && isUpcoming && (
          <a
            href={appointment.meeting_link}
            target="_blank"
            rel="noopener noreferrer"
            className="flex items-center gap-2 text-sm text-primary hover:underline"
          >
            <Video className="w-4 h-4" />
            Join Meeting
          </a>
        )}

        {/* Action Buttons (for past appointments) */}
        {isPast && appointment.status !== 'completed' && appointment.status !== 'no_show' && appointment.status !== 'cancelled' && (
          <div className="flex gap-2 pt-2 border-t border-border">
            <Button
              size="sm"
              variant="outline"
              className="flex-1 text-green-600 hover:text-green-700"
              onClick={() => handleStatusUpdate('completed')}
            >
              <CheckCircle className="w-3 h-3 mr-1" />
              Selesai
            </Button>
            <Button
              size="sm"
              variant="outline"
              className="flex-1 text-orange-600 hover:text-orange-700"
              onClick={() => handleStatusUpdate('no_show')}
            >
              <XCircle className="w-3 h-3 mr-1" />
              No Show
            </Button>
          </div>
        )}
      </div>
    </div>
  )
}
```

This component will be added to the inbox sidebar by updating info-sidebar.tsx (if needed - can be done in integration or left for later polish).
  </action>
  <verify>
Component renders without errors.
TypeScript compiles cleanly.
  </verify>
  <done>Appointment card displays upcoming consultation with status actions</done>
</task>

</tasks>

<verification>
- [ ] handoff.ts generates meaningful summaries
- [ ] Contact notes updated with ARI summary
- [ ] Contact lead_status set to hot_lead
- [ ] Contact tags include consultation type
- [ ] Cron endpoint returns valid JSON
- [ ] Reminder message includes time and meeting link
- [ ] AppointmentCard displays appointment info
- [ ] Status buttons work for past appointments
</verification>

<success_criteria>
- Handoff adds AI summary to contact notes
- Lead status and tags updated correctly
- Meeting reminder cron ready for deployment
- Appointment visible in inbox sidebar
</success_criteria>

<output>
After completion, create `.planning/phases/05-scheduling-handoff/05-04-SUMMARY.md`
</output>
