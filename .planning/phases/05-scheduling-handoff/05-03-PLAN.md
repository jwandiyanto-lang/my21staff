---
phase: 05-scheduling-handoff
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/ari/scheduling.ts
  - src/lib/ari/state-machine.ts
  - src/lib/ari/context-builder.ts
  - src/lib/ari/processor.ts
autonomous: true

must_haves:
  truths:
    - "ARI asks day preference for booking"
    - "ARI shows available times for selected day"
    - "ARI confirms booking with repeat-back"
    - "Booking creates ari_appointments record"
    - "Slot availability respects existing bookings"
  artifacts:
    - path: "src/lib/ari/scheduling.ts"
      provides: "Slot availability calculation and booking logic"
      exports: ["getAvailableSlots", "bookAppointment", "formatSlotsForDay"]
      min_lines: 80
  key_links:
    - from: "src/lib/ari/processor.ts"
      to: "src/lib/ari/scheduling.ts"
      via: "import and function calls"
      pattern: "import.*scheduling"
    - from: "src/lib/ari/scheduling.ts"
      to: "ari_appointments table"
      via: "Supabase insert"
      pattern: "supabase.*ari_appointments.*insert"
---

<objective>
Implement ARI's booking conversation flow.

Purpose: Enable ARI to guide hot leads through scheduling a consultation. The flow is: (1) Ask day preference, (2) Show available times, (3) Confirm with repeat-back, (4) Create appointment.

Note: Since Payment Integration (Phase 4) was skipped, booking happens directly after scoring for hot leads without payment gate.

Output: Scheduling logic module, updated state machine, context builder instructions, and processor integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-scheduling-handoff/05-CONTEXT.md
@.planning/phases/03-lead-scoring-routing/03-04-SUMMARY.md
@src/lib/ari/types.ts
@src/lib/ari/state-machine.ts
@src/lib/ari/context-builder.ts
@src/lib/ari/processor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scheduling module with slot availability logic</name>
  <files>src/lib/ari/scheduling.ts</files>
  <action>
Create new scheduling module that handles slot availability and booking.

```typescript
/**
 * ARI Scheduling Module
 *
 * Handles slot availability calculation and appointment booking.
 * Converts weekly patterns (consultant_slots) into actual available
 * times for specific dates, respecting existing bookings.
 */

import type { SupabaseClient } from '@supabase/supabase-js';
import type { ConsultantSlot, AvailableSlot, ARIAppointment } from './types';

// ===========================================
// Indonesian Day Names
// ===========================================

const INDONESIAN_DAYS = [
  'Minggu',
  'Senin',
  'Selasa',
  'Rabu',
  'Kamis',
  'Jumat',
  'Sabtu',
];

/**
 * Parse Indonesian day name to day_of_week number
 */
export function parseIndonesianDay(text: string): number | null {
  const normalized = text.toLowerCase().trim();
  const index = INDONESIAN_DAYS.findIndex(d => d.toLowerCase() === normalized);
  return index >= 0 ? index : null;
}

/**
 * Get Indonesian day name from day_of_week number
 */
export function getIndonesianDayName(dayOfWeek: number): string {
  return INDONESIAN_DAYS[dayOfWeek] || 'Unknown';
}

// ===========================================
// Slot Availability Functions
// ===========================================

/**
 * Get available slots for a workspace within the booking window
 *
 * @param supabase - Supabase client
 * @param workspaceId - Workspace ID
 * @param daysAhead - How many days ahead to look (default from slot config)
 * @returns Array of available slots
 */
export async function getAvailableSlots(
  supabase: SupabaseClient,
  workspaceId: string,
  daysAhead: number = 14
): Promise<AvailableSlot[]> {
  // Get active slot patterns
  const { data: slotPatterns, error: slotsError } = await supabase
    .from('consultant_slots')
    .select('*')
    .eq('workspace_id', workspaceId)
    .eq('is_active', true);

  if (slotsError || !slotPatterns?.length) {
    console.log('[Scheduling] No active slots found');
    return [];
  }

  // Get existing appointments in the window
  const now = new Date();
  const windowEnd = new Date();
  windowEnd.setDate(windowEnd.getDate() + daysAhead);

  const { data: existingAppointments } = await supabase
    .from('ari_appointments')
    .select('scheduled_at, status')
    .eq('workspace_id', workspaceId)
    .gte('scheduled_at', now.toISOString())
    .lte('scheduled_at', windowEnd.toISOString())
    .not('status', 'in', '("cancelled","no_show")');

  // Build set of booked times for quick lookup
  const bookedTimes = new Set(
    (existingAppointments || []).map(a => a.scheduled_at)
  );

  // Generate available slots for each day in window
  const availableSlots: AvailableSlot[] = [];

  for (let d = 1; d <= daysAhead; d++) {
    const date = new Date();
    date.setDate(date.getDate() + d);
    date.setHours(0, 0, 0, 0);

    const dayOfWeek = date.getDay();
    const dateStr = date.toISOString().split('T')[0];

    // Find slot patterns for this day
    const daySlots = slotPatterns.filter(
      (s: ConsultantSlot) => s.day_of_week === dayOfWeek
    );

    for (const slot of daySlots) {
      // Parse start/end times
      const [startHour, startMin] = (slot.start_time as string).split(':').map(Number);
      const [endHour, endMin] = (slot.end_time as string).split(':').map(Number);

      // Create appointment datetime (in WIB timezone for Indonesia)
      const appointmentTime = new Date(date);
      appointmentTime.setHours(startHour, startMin, 0, 0);

      // Check if already booked
      const isBooked = bookedTimes.has(appointmentTime.toISOString());

      // Only add if in future and not booked
      if (appointmentTime > now && !isBooked) {
        availableSlots.push({
          date: dateStr,
          day_of_week: dayOfWeek,
          start_time: slot.start_time as string,
          end_time: slot.end_time as string,
          duration_minutes: slot.duration_minutes,
          consultant_id: slot.consultant_id,
          slot_id: slot.id,
          booked: false,
        });
      }
    }
  }

  // Sort by date and time
  availableSlots.sort((a, b) => {
    if (a.date !== b.date) return a.date.localeCompare(b.date);
    return a.start_time.localeCompare(b.start_time);
  });

  return availableSlots;
}

/**
 * Get available slots for a specific day of week
 */
export async function getSlotsForDay(
  supabase: SupabaseClient,
  workspaceId: string,
  dayOfWeek: number,
  daysAhead: number = 14
): Promise<AvailableSlot[]> {
  const allSlots = await getAvailableSlots(supabase, workspaceId, daysAhead);
  return allSlots.filter(s => s.day_of_week === dayOfWeek);
}

/**
 * Format available slots for a day into Indonesian message
 *
 * @example
 * "Untuk hari Senin ada slot:
 * 1. 20 Jan - 09:00 (60 menit)
 * 2. 20 Jan - 10:00 (60 menit)
 * 3. 27 Jan - 09:00 (60 menit)
 *
 * Pilih nomor atau ketik tanggal dan jam yang cocok."
 */
export function formatSlotsForDay(slots: AvailableSlot[]): string {
  if (slots.length === 0) {
    return 'Maaf, tidak ada slot tersedia untuk hari itu. Coba hari lain ya.';
  }

  const dayName = getIndonesianDayName(slots[0].day_of_week);
  const lines = [`Untuk hari ${dayName} ada slot:`];

  slots.slice(0, 5).forEach((slot, i) => {
    const date = new Date(slot.date);
    const dateStr = date.toLocaleDateString('id-ID', { day: 'numeric', month: 'short' });
    const time = slot.start_time.slice(0, 5);
    lines.push(`${i + 1}. ${dateStr} - ${time} (${slot.duration_minutes} menit)`);
  });

  if (slots.length > 5) {
    lines.push(`...dan ${slots.length - 5} slot lainnya.`);
  }

  lines.push('');
  lines.push('Pilih nomor atau ketik tanggal dan jam yang cocok.');

  return lines.join('\n');
}

/**
 * Format all available days into a summary
 */
export function formatAvailableDays(slots: AvailableSlot[]): string {
  // Group by day of week
  const byDay = new Map<number, number>();
  slots.forEach(s => {
    byDay.set(s.day_of_week, (byDay.get(s.day_of_week) || 0) + 1);
  });

  if (byDay.size === 0) {
    return 'Maaf, tidak ada jadwal konsultasi yang tersedia saat ini.';
  }

  const lines = ['Jadwal konsultasi yang tersedia:'];
  Array.from(byDay.entries())
    .sort((a, b) => a[0] - b[0])
    .forEach(([day, count]) => {
      lines.push(`- ${getIndonesianDayName(day)} (${count} slot)`);
    });

  lines.push('');
  lines.push('Hari apa yang cocok untuk kamu?');

  return lines.join('\n');
}

// ===========================================
// Booking Functions
// ===========================================

/**
 * Book an appointment for a contact
 */
export async function bookAppointment(
  supabase: SupabaseClient,
  params: {
    workspaceId: string;
    ariConversationId: string;
    slot: AvailableSlot;
    consultantId?: string | null;
    notes?: string;
  }
): Promise<ARIAppointment | null> {
  const { workspaceId, ariConversationId, slot, consultantId, notes } = params;

  // Build scheduled_at timestamp
  const [hour, min] = slot.start_time.split(':').map(Number);
  const scheduledAt = new Date(slot.date);
  scheduledAt.setHours(hour, min, 0, 0);

  // Insert appointment
  const { data: appointment, error } = await supabase
    .from('ari_appointments')
    .insert({
      workspace_id: workspaceId,
      ari_conversation_id: ariConversationId,
      consultant_id: consultantId || slot.consultant_id || null,
      scheduled_at: scheduledAt.toISOString(),
      duration_minutes: slot.duration_minutes,
      status: 'scheduled',
      notes: notes || null,
    })
    .select()
    .single();

  if (error) {
    console.error('[Scheduling] Failed to book appointment:', error);
    return null;
  }

  console.log(`[Scheduling] Booked appointment ${appointment.id} for ${scheduledAt.toISOString()}`);
  return appointment as ARIAppointment;
}

/**
 * Format appointment confirmation message
 */
export function formatBookingConfirmation(
  slot: AvailableSlot,
  consultantName?: string
): string {
  const date = new Date(slot.date);
  const dateStr = date.toLocaleDateString('id-ID', {
    weekday: 'long',
    day: 'numeric',
    month: 'long',
    year: 'numeric',
  });
  const time = slot.start_time.slice(0, 5);

  let msg = `Oke, saya booking konsultasi untuk kamu:\n\n`;
  msg += `Tanggal: ${dateStr}\n`;
  msg += `Jam: ${time} WIB\n`;
  msg += `Durasi: ${slot.duration_minutes} menit\n`;
  if (consultantName) {
    msg += `Konsultan: ${consultantName}\n`;
  }
  msg += `\nLink meeting akan dikirim 1 jam sebelum jadwal. Sampai ketemu!`;

  return msg;
}

// ===========================================
// Slot Selection Parsing
// ===========================================

/**
 * Parse user's slot selection from message
 *
 * Handles:
 * - Number selection: "1", "2", "nomor 1"
 * - Date/time: "20 Januari jam 9", "besok pagi"
 *
 * Returns slot index (0-based) or null if can't parse
 */
export function parseSlotSelection(
  message: string,
  availableSlots: AvailableSlot[]
): number | null {
  const normalized = message.toLowerCase().trim();

  // Try number selection first
  const numMatch = normalized.match(/^(\d+)$|nomor\s*(\d+)|pilih\s*(\d+)/);
  if (numMatch) {
    const num = parseInt(numMatch[1] || numMatch[2] || numMatch[3]);
    if (num >= 1 && num <= availableSlots.length) {
      return num - 1; // Convert to 0-based index
    }
  }

  // Try to match by time keywords for first available slot
  if (/pagi|morning/.test(normalized)) {
    const morningSlot = availableSlots.findIndex(s => {
      const hour = parseInt(s.start_time.split(':')[0]);
      return hour >= 6 && hour < 12;
    });
    if (morningSlot >= 0) return morningSlot;
  }

  if (/siang|afternoon/.test(normalized)) {
    const afternoonSlot = availableSlots.findIndex(s => {
      const hour = parseInt(s.start_time.split(':')[0]);
      return hour >= 12 && hour < 17;
    });
    if (afternoonSlot >= 0) return afternoonSlot;
  }

  if (/sore|evening/.test(normalized)) {
    const eveningSlot = availableSlots.findIndex(s => {
      const hour = parseInt(s.start_time.split(':')[0]);
      return hour >= 17;
    });
    if (eveningSlot >= 0) return eveningSlot;
  }

  return null;
}
```

This module handles the scheduling logic without the AI conversation part - that's handled by processor and context-builder.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Scheduling module exports slot availability and booking functions</done>
</task>

<task type="auto">
  <name>Task 2: Update state machine for scheduling flow</name>
  <files>src/lib/ari/state-machine.ts</files>
  <action>
Update state machine to handle the booking -> scheduling flow.

1. Update STATE_TRANSITIONS to allow direct booking->scheduling (no payment gate):
```typescript
export const STATE_TRANSITIONS: Record<ARIState, ARIState[]> = {
  greeting: ['qualifying'],
  qualifying: ['scoring', 'qualifying'],
  scoring: ['booking', 'handoff'],
  booking: ['scheduling', 'handoff'], // REMOVED: payment step, direct to scheduling
  payment: ['scheduling', 'payment', 'handoff'], // Keep for future use
  scheduling: ['handoff', 'scheduling'],
  handoff: ['completed'],
  completed: [],
};
```

2. Update getNextState for booking state to go directly to scheduling:
```typescript
case 'booking':
  // Hot lead accepted booking offer, move to scheduling
  // Note: Payment integration skipped in v2.2, going direct to scheduling
  return 'scheduling';
```

3. Add scheduling sub-states to ARIContext type tracking (in types.ts):
```typescript
// In ARIContext interface, add:
/** Scheduling flow sub-state */
scheduling_step?: 'asking_day' | 'showing_slots' | 'confirming' | 'booked';
/** Selected day for scheduling */
selected_day?: number;
/** Available slots for selected day */
available_slots?: Array<{
  date: string;
  start_time: string;
  duration_minutes: number;
  slot_id: string;
}>;
/** Selected slot index (0-based) */
selected_slot_index?: number;
```

Add these fields to types.ts ARIContext interface.
  </action>
  <verify>
TypeScript compiles without errors.
State transitions allow booking -> scheduling.
  </verify>
  <done>State machine allows direct booking to scheduling transition</done>
</task>

<task type="auto">
  <name>Task 3: Update context builder and processor for scheduling</name>
  <files>
    src/lib/ari/context-builder.ts
    src/lib/ari/processor.ts
  </files>
  <action>
Update context builder with scheduling-specific instructions and processor with scheduling logic.

**In context-builder.ts:**

Add scheduling state instructions to STATE_INSTRUCTIONS:
```typescript
scheduling: `Bantu lead booking jadwal konsultasi. Ikuti flow:
1. Jika belum pilih hari -> tanya hari yang cocok
2. Jika sudah pilih hari -> tunjukkan slot tersedia
3. Jika sudah pilih slot -> konfirmasi dengan repeat-back
Gunakan bahasa santai dan bantu jika mereka bingung.`,
```

Add scheduling context section in buildSystemPrompt (after scoring context section):
```typescript
// 5g. Scheduling context
if (ctx.conversation.state === 'scheduling') {
  const schedCtx = ctx.conversation.context as any;

  if (schedCtx.scheduling_step === 'asking_day') {
    // Get available days summary from context
    const availableDays = schedCtx.available_days_summary;
    if (availableDays) {
      parts.push('\n## JADWAL TERSEDIA');
      parts.push(availableDays);
      parts.push('\nTanyakan hari apa yang cocok untuk mereka.');
    }
  }

  if (schedCtx.scheduling_step === 'showing_slots') {
    const slotsSummary = schedCtx.slots_summary;
    if (slotsSummary) {
      parts.push('\n## SLOT TERSEDIA');
      parts.push(slotsSummary);
      parts.push('\nTunjukkan pilihan di atas dan minta mereka pilih nomor.');
    }
  }

  if (schedCtx.scheduling_step === 'confirming') {
    const selectedSlot = schedCtx.selected_slot;
    if (selectedSlot) {
      parts.push('\n## KONFIRMASI BOOKING');
      parts.push(`Mereka memilih: ${selectedSlot.date} jam ${selectedSlot.start_time}`);
      parts.push('Konfirmasi ulang: "Oke, jadi [hari] tanggal [X] jam [Y] ya?"');
      parts.push('Tunggu konfirmasi "ya/oke/betul" sebelum finalisasi.');
    }
  }
}
```

**In processor.ts:**

1. Import scheduling functions at top:
```typescript
import {
  getAvailableSlots,
  getSlotsForDay,
  formatAvailableDays,
  formatSlotsForDay,
  parseIndonesianDay,
  parseSlotSelection,
  bookAppointment,
  formatBookingConfirmation,
} from './scheduling';
```

2. Add scheduling logic in processWithARI, after the routing execution section and before state update:

```typescript
// 12f. Handle scheduling state transitions
if (conversation.state === 'scheduling' || nextState === 'scheduling') {
  const schedCtx = conversationContext as any;

  // First time entering scheduling - show available days
  if (!schedCtx.scheduling_step || schedCtx.scheduling_step === 'asking_day') {
    // Check for day preference in user message
    const dayPref = parseIndonesianDay(userMessage);

    if (dayPref !== null) {
      // User specified a day - get slots for that day
      const daySlots = await getSlotsForDay(supabase, workspaceId, dayPref);

      if (daySlots.length > 0) {
        schedCtx.scheduling_step = 'showing_slots';
        schedCtx.selected_day = dayPref;
        schedCtx.available_slots = daySlots.slice(0, 5).map(s => ({
          date: s.date,
          start_time: s.start_time,
          duration_minutes: s.duration_minutes,
          slot_id: s.slot_id,
        }));
        schedCtx.slots_summary = formatSlotsForDay(daySlots);

        // Update conversation context
        await supabase
          .from('ari_conversations')
          .update({ context: schedCtx })
          .eq('id', conversation.id);
      } else {
        // No slots for that day
        const allSlots = await getAvailableSlots(supabase, workspaceId);
        schedCtx.available_days_summary = formatAvailableDays(allSlots);
      }
    } else if (!schedCtx.available_days_summary) {
      // First time - load available days
      const allSlots = await getAvailableSlots(supabase, workspaceId);
      schedCtx.scheduling_step = 'asking_day';
      schedCtx.available_days_summary = formatAvailableDays(allSlots);

      await supabase
        .from('ari_conversations')
        .update({ context: schedCtx })
        .eq('id', conversation.id);
    }
  }

  // User is selecting from shown slots
  if (schedCtx.scheduling_step === 'showing_slots' && schedCtx.available_slots) {
    const selection = parseSlotSelection(userMessage, schedCtx.available_slots);

    if (selection !== null) {
      schedCtx.scheduling_step = 'confirming';
      schedCtx.selected_slot_index = selection;
      schedCtx.selected_slot = schedCtx.available_slots[selection];

      await supabase
        .from('ari_conversations')
        .update({ context: schedCtx })
        .eq('id', conversation.id);
    }
  }

  // User is confirming selection
  if (schedCtx.scheduling_step === 'confirming' && schedCtx.selected_slot) {
    const isConfirm = /^(ya|oke|ok|yes|betul|benar|setuju|deal)/i.test(userMessage.trim());

    if (isConfirm) {
      // Book the appointment
      const slot = schedCtx.selected_slot;
      const appointment = await bookAppointment(supabase, {
        workspaceId,
        ariConversationId: conversation.id,
        slot: {
          date: slot.date,
          day_of_week: schedCtx.selected_day,
          start_time: slot.start_time,
          end_time: '', // Not needed for booking
          duration_minutes: slot.duration_minutes,
          consultant_id: null,
          slot_id: slot.slot_id,
          booked: false,
        },
        notes: `Booked via ARI. Lead score: ${calculatedScore}`,
      });

      if (appointment) {
        schedCtx.scheduling_step = 'booked';
        schedCtx.appointment_id = appointment.id;

        // Update to handoff state
        await supabase
          .from('ari_conversations')
          .update({
            state: 'handoff',
            context: schedCtx,
            handoff_at: new Date().toISOString(),
            handoff_reason: 'appointment_booked',
          })
          .eq('id', conversation.id);

        // Send confirmation message
        const confirmMsg = formatBookingConfirmation(slot);
        await sendMessage(kapsoCredentials, contactPhone, confirmMsg);

        await logMessage(supabase, {
          ariConversationId: conversation.id,
          workspaceId,
          role: 'assistant',
          content: confirmMsg,
        });

        return {
          success: true,
          response: confirmMsg,
          newState: 'handoff',
        };
      }
    }
  }
}
```

Update PromptContext in context-builder.ts if needed to handle scheduling context properly.
  </action>
  <verify>
Build passes: `npm run build`
Test flow manually:
1. Hot lead reaches booking state
2. ARI shows available days
3. User picks day, ARI shows times
4. User picks time, ARI confirms
5. User says "ya", appointment created
  </verify>
  <done>
ARI guides booking flow:
- Shows available days
- Shows slots for selected day
- Confirms selection
- Books appointment on confirmation
  </done>
</task>

</tasks>

<verification>
- [ ] scheduling.ts exports all required functions
- [ ] State machine allows booking -> scheduling
- [ ] Context builder includes scheduling instructions
- [ ] Processor handles scheduling sub-states
- [ ] Day preference parsing works (Senin, Selasa, etc.)
- [ ] Slot selection parsing works (1, 2, "nomor 1")
- [ ] Booking creates ari_appointments record
- [ ] Confirmation message sent via Kapso
</verification>

<success_criteria>
- ARI can guide a hot lead through booking flow
- Appointments are created in database
- Flow is natural in Indonesian language
- No payment gate (direct booking for hot leads)
</success_criteria>

<output>
After completion, create `.planning/phases/05-scheduling-handoff/05-03-SUMMARY.md`
</output>
