---
phase: 05-scheduling-handoff
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/37_consultant_slots.sql
  - src/lib/ari/types.ts
  - src/app/api/workspaces/[id]/slots/route.ts
  - src/app/api/workspaces/[id]/slots/[slotId]/route.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create weekly availability patterns for consultants"
    - "Slots have configurable duration (30/60/90 min)"
    - "Slots have configurable booking window (days ahead)"
    - "Slots can be enabled/disabled without deletion"
  artifacts:
    - path: "supabase/migrations/37_consultant_slots.sql"
      provides: "Consultant slots table with weekly patterns"
      contains: "consultant_slots"
    - path: "src/app/api/workspaces/[id]/slots/route.ts"
      provides: "CRUD API for consultant slots"
      exports: ["GET", "POST"]
    - path: "src/app/api/workspaces/[id]/slots/[slotId]/route.ts"
      provides: "Individual slot operations"
      exports: ["PATCH", "DELETE"]
  key_links:
    - from: "src/app/api/workspaces/[id]/slots/route.ts"
      to: "consultant_slots table"
      via: "Supabase client query"
      pattern: "supabase.*consultant_slots"
---

<objective>
Create the database schema and API for consultant slot management.

Purpose: Enable admins to define weekly availability patterns that ARI can use for booking consultations. Slots follow a weekly recurring pattern (e.g., "Every Monday 10:00-11:00") rather than individual calendar entries.

Output: Migration file for consultant_slots table, TypeScript types, and CRUD API routes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-scheduling-handoff/05-CONTEXT.md
@supabase/migrations/34_ari_tables.sql
@src/lib/ari/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create consultant_slots database table</name>
  <files>supabase/migrations/37_consultant_slots.sql</files>
  <action>
Create migration file for consultant slots with weekly pattern support:

```sql
-- CONSULTANT_SLOTS - Weekly availability patterns for booking
CREATE TABLE consultant_slots (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  consultant_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,

  -- Weekly pattern (0=Sunday, 1=Monday, ..., 6=Saturday)
  day_of_week INTEGER NOT NULL CHECK (day_of_week >= 0 AND day_of_week <= 6),
  start_time TIME NOT NULL,
  end_time TIME NOT NULL,

  -- Configuration
  duration_minutes INTEGER DEFAULT 60 CHECK (duration_minutes > 0),
  booking_window_days INTEGER DEFAULT 14 CHECK (booking_window_days > 0),
  max_bookings_per_slot INTEGER DEFAULT 1,

  -- Status
  is_active BOOLEAN DEFAULT true,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT valid_time_range CHECK (end_time > start_time),
  UNIQUE(workspace_id, consultant_id, day_of_week, start_time)
);

-- RLS
ALTER TABLE consultant_slots ENABLE ROW LEVEL SECURITY;

-- Policies (same pattern as ari_config)
CREATE POLICY "Users can view slots in their workspaces" ON consultant_slots
  FOR SELECT USING (
    workspace_id IN (
      SELECT id FROM workspaces WHERE owner_id = (SELECT auth.uid())
      UNION
      SELECT workspace_id FROM workspace_members WHERE user_id = (SELECT auth.uid())
    )
  );

CREATE POLICY "Users can insert slots in their workspaces" ON consultant_slots
  FOR INSERT WITH CHECK (
    workspace_id IN (
      SELECT id FROM workspaces WHERE owner_id = (SELECT auth.uid())
      UNION
      SELECT workspace_id FROM workspace_members WHERE user_id = (SELECT auth.uid())
    )
  );

CREATE POLICY "Users can update slots in their workspaces" ON consultant_slots
  FOR UPDATE USING (
    workspace_id IN (
      SELECT id FROM workspaces WHERE owner_id = (SELECT auth.uid())
      UNION
      SELECT workspace_id FROM workspace_members WHERE user_id = (SELECT auth.uid())
    )
  );

CREATE POLICY "Users can delete slots in their workspaces" ON consultant_slots
  FOR DELETE USING (
    workspace_id IN (
      SELECT id FROM workspaces WHERE owner_id = (SELECT auth.uid())
      UNION
      SELECT workspace_id FROM workspace_members WHERE user_id = (SELECT auth.uid())
    )
  );

-- Indexes
CREATE INDEX idx_consultant_slots_workspace ON consultant_slots(workspace_id);
CREATE INDEX idx_consultant_slots_consultant ON consultant_slots(consultant_id) WHERE consultant_id IS NOT NULL;
CREATE INDEX idx_consultant_slots_active ON consultant_slots(workspace_id, is_active) WHERE is_active = true;
CREATE INDEX idx_consultant_slots_day ON consultant_slots(workspace_id, day_of_week, is_active);

-- Updated_at trigger
CREATE TRIGGER update_consultant_slots_updated_at
  BEFORE UPDATE ON consultant_slots
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
```

Why this design:
- Weekly patterns (day_of_week + time) are simpler than managing individual calendar entries
- consultant_id is nullable to allow workspace-wide slots (any consultant can take)
- booking_window_days limits how far ahead leads can book
- is_active allows soft-disable without losing configuration
  </action>
  <verify>
Run migration: `npx supabase db push`
Check table exists: `npx supabase db dump --local | grep consultant_slots`
  </verify>
  <done>consultant_slots table exists with RLS policies and indexes</done>
</task>

<task type="auto">
  <name>Task 2: Add ConsultantSlot types</name>
  <files>src/lib/ari/types.ts</files>
  <action>
Add TypeScript types for consultant slots at the end of the types file:

```typescript
// ===========================================
// Consultant Slot Types (for scheduling)
// ===========================================

/** Weekly availability slot for consultations */
export interface ConsultantSlot {
  id: string;
  workspace_id: string;
  consultant_id: string | null;
  day_of_week: number; // 0=Sunday, 6=Saturday
  start_time: string; // HH:MM:SS format
  end_time: string;
  duration_minutes: number;
  booking_window_days: number;
  max_bookings_per_slot: number;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export type ConsultantSlotInsert = Omit<ConsultantSlot, 'id' | 'created_at' | 'updated_at'>;
export type ConsultantSlotUpdate = Partial<Omit<ConsultantSlot, 'id' | 'workspace_id' | 'created_at' | 'updated_at'>>;

/** Available time slot for a specific date (computed from ConsultantSlot) */
export interface AvailableSlot {
  date: string; // YYYY-MM-DD
  day_of_week: number;
  start_time: string;
  end_time: string;
  duration_minutes: number;
  consultant_id: string | null;
  slot_id: string; // Reference to ConsultantSlot
  booked: boolean;
}
```

AvailableSlot is a computed type - it represents an actual bookable slot on a specific date, derived from the weekly pattern.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>ConsultantSlot and AvailableSlot types available for use</done>
</task>

<task type="auto">
  <name>Task 3: Create slots CRUD API</name>
  <files>
    src/app/api/workspaces/[id]/slots/route.ts
    src/app/api/workspaces/[id]/slots/[slotId]/route.ts
  </files>
  <action>
Create API routes for slot management.

**src/app/api/workspaces/[id]/slots/route.ts:**

```typescript
/**
 * Consultant Slots API
 * GET - List all slots for workspace
 * POST - Create new slot
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import type { ConsultantSlotInsert } from '@/lib/ari/types';

interface RouteParams {
  params: Promise<{ id: string }>;
}

// GET /api/workspaces/[id]/slots
export async function GET(request: NextRequest, { params }: RouteParams) {
  const { id: workspaceId } = await params;
  const supabase = await createClient();

  // Verify user has access to workspace
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Get slots with consultant profile info
  const { data: slots, error } = await supabase
    .from('consultant_slots')
    .select(`
      *,
      consultant:consultant_id (
        id,
        email,
        full_name
      )
    `)
    .eq('workspace_id', workspaceId)
    .order('day_of_week', { ascending: true })
    .order('start_time', { ascending: true });

  if (error) {
    console.error('Failed to fetch slots:', error);
    return NextResponse.json({ error: 'Failed to fetch slots' }, { status: 500 });
  }

  return NextResponse.json({ slots });
}

// POST /api/workspaces/[id]/slots
export async function POST(request: NextRequest, { params }: RouteParams) {
  const { id: workspaceId } = await params;
  const supabase = await createClient();

  // Verify user has access
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const body = await request.json();

  // Validate required fields
  if (body.day_of_week === undefined || !body.start_time || !body.end_time) {
    return NextResponse.json(
      { error: 'day_of_week, start_time, and end_time are required' },
      { status: 400 }
    );
  }

  const slotData: ConsultantSlotInsert = {
    workspace_id: workspaceId,
    consultant_id: body.consultant_id || null,
    day_of_week: body.day_of_week,
    start_time: body.start_time,
    end_time: body.end_time,
    duration_minutes: body.duration_minutes || 60,
    booking_window_days: body.booking_window_days || 14,
    max_bookings_per_slot: body.max_bookings_per_slot || 1,
    is_active: body.is_active ?? true,
  };

  const { data: slot, error } = await supabase
    .from('consultant_slots')
    .insert(slotData)
    .select()
    .single();

  if (error) {
    // Handle unique constraint violation
    if (error.code === '23505') {
      return NextResponse.json(
        { error: 'Slot already exists for this day and time' },
        { status: 409 }
      );
    }
    console.error('Failed to create slot:', error);
    return NextResponse.json({ error: 'Failed to create slot' }, { status: 500 });
  }

  return NextResponse.json({ slot }, { status: 201 });
}
```

**src/app/api/workspaces/[id]/slots/[slotId]/route.ts:**

```typescript
/**
 * Individual Slot API
 * PATCH - Update slot
 * DELETE - Delete slot
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import type { ConsultantSlotUpdate } from '@/lib/ari/types';

interface RouteParams {
  params: Promise<{ id: string; slotId: string }>;
}

// PATCH /api/workspaces/[id]/slots/[slotId]
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  const { id: workspaceId, slotId } = await params;
  const supabase = await createClient();

  // Verify user has access
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const body = await request.json();

  // Build update object with only provided fields
  const updateData: ConsultantSlotUpdate = {};
  if (body.consultant_id !== undefined) updateData.consultant_id = body.consultant_id;
  if (body.day_of_week !== undefined) updateData.day_of_week = body.day_of_week;
  if (body.start_time !== undefined) updateData.start_time = body.start_time;
  if (body.end_time !== undefined) updateData.end_time = body.end_time;
  if (body.duration_minutes !== undefined) updateData.duration_minutes = body.duration_minutes;
  if (body.booking_window_days !== undefined) updateData.booking_window_days = body.booking_window_days;
  if (body.max_bookings_per_slot !== undefined) updateData.max_bookings_per_slot = body.max_bookings_per_slot;
  if (body.is_active !== undefined) updateData.is_active = body.is_active;

  const { data: slot, error } = await supabase
    .from('consultant_slots')
    .update(updateData)
    .eq('id', slotId)
    .eq('workspace_id', workspaceId)
    .select()
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return NextResponse.json({ error: 'Slot not found' }, { status: 404 });
    }
    console.error('Failed to update slot:', error);
    return NextResponse.json({ error: 'Failed to update slot' }, { status: 500 });
  }

  return NextResponse.json({ slot });
}

// DELETE /api/workspaces/[id]/slots/[slotId]
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  const { id: workspaceId, slotId } = await params;
  const supabase = await createClient();

  // Verify user has access
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { error } = await supabase
    .from('consultant_slots')
    .delete()
    .eq('id', slotId)
    .eq('workspace_id', workspaceId);

  if (error) {
    console.error('Failed to delete slot:', error);
    return NextResponse.json({ error: 'Failed to delete slot' }, { status: 500 });
  }

  return NextResponse.json({ success: true });
}
```
  </action>
  <verify>
Build passes: `npm run build`
Test API with curl:
- `curl -X GET http://localhost:3000/api/workspaces/{workspace_id}/slots`
  </verify>
  <done>
CRUD API endpoints work:
- GET returns all slots for workspace
- POST creates new slot with validation
- PATCH updates slot fields
- DELETE removes slot
  </done>
</task>

</tasks>

<verification>
- [ ] Migration runs without errors
- [ ] TypeScript compiles cleanly
- [ ] GET /api/workspaces/[id]/slots returns empty array for new workspace
- [ ] POST creates slot and returns 201
- [ ] PATCH updates slot fields
- [ ] DELETE removes slot
- [ ] RLS prevents cross-workspace access
</verification>

<success_criteria>
- consultant_slots table exists with proper constraints
- Types available in src/lib/ari/types.ts
- API routes handle all CRUD operations
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-scheduling-handoff/05-01-SUMMARY.md`
</output>
