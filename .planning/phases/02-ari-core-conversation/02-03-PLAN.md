---
phase: 02-ari-core-conversation
plan: 03
type: execute
wave: 3
depends_on: [02-02]
files_modified:
  - src/lib/ari/processor.ts
  - src/app/api/webhook/kapso/route.ts
  - src/lib/ari/index.ts
autonomous: true

must_haves:
  truths:
    - "Incoming WhatsApp message triggers ARI processing"
    - "ARI matches phone number to CRM contact"
    - "ARI creates/retrieves conversation state from database"
    - "ARI generates and sends response via Kapso"
    - "Messages are logged to ari_messages table"
  artifacts:
    - path: "src/lib/ari/processor.ts"
      provides: "Main ARI message processing"
      exports: ["processWithARI"]
    - path: "src/app/api/webhook/kapso/route.ts"
      provides: "Webhook integration"
      contains: "processWithARI"
  key_links:
    - from: "src/app/api/webhook/kapso/route.ts"
      to: "src/lib/ari/processor.ts"
      via: "processWithARI call"
      pattern: "processWithARI"
    - from: "src/lib/ari/processor.ts"
      to: "ari_conversations table"
      via: "supabase query"
      pattern: "from\\('ari_conversations'\\)"
---

# 02-03-PLAN: ARI Webhook Integration and Message Processing

## Goal

Wire ARI into the Kapso webhook to process incoming messages with AI and send responses.

## Context

**From 02-02-PLAN:** State machine and context builder are ready

**Existing code:**
- Webhook at src/app/api/webhook/kapso/route.ts already handles incoming messages
- Kapso client at src/lib/kapso/client.ts has sendMessage function
- Phone normalization at src/lib/phone/normalize.ts
- createApiAdminClient for service-role database access

**Key integration points:**
1. After message is saved in processWorkspaceMessages()
2. Check if contact has ARI enabled (workspace has ari_config)
3. Process with ARI asynchronously (don't block webhook response)
4. Send AI response via Kapso

**Research findings:**
- Return 200 immediately, process AI async
- Limit context to last 10 messages
- Log all messages to ari_messages for tracking

## Tasks

<task id="1">
<title>Create ARI message processor</title>
<action>
1. Create `src/lib/ari/processor.ts`:

2. Import dependencies:
   - createApiAdminClient from supabase/server
   - Types from ./types
   - buildSystemPrompt, buildMessageHistory, extractFormAnswers from ./context-builder
   - selectModel, generateResponse from ./ai-router
   - canTransition, getNextState from ./state-machine
   - sendMessage from kapso/client (for sending responses)

3. Implement `getOrCreateARIConversation(supabase, workspaceId, contactId)`:
   - Query ari_conversations WHERE workspace_id AND contact_id
   - If exists, return it
   - If not, INSERT with state='greeting', context={}
   - Return the conversation record

4. Implement `getARIConfig(supabase, workspaceId)`:
   - Query ari_config WHERE workspace_id
   - Return config or default values (bot_name='ARI', greeting_style='professional', etc.)

5. Implement main function `processWithARI(params)`:
   ```typescript
   interface ProcessParams {
     workspaceId: string;
     contactId: string;
     contactPhone: string;
     userMessage: string;
     kapsoCredentials: { apiKey: string; phoneId: string };
   }
   ```

   Steps:
   a. Create supabase admin client
   b. Get or create ARI conversation
   c. Get contact with form data: SELECT * FROM contacts WHERE id = contactId
   d. Get ARI config for workspace
   e. Get recent ari_messages (last 10) for this conversation
   f. Extract form answers from contact.metadata
   g. Build system prompt using context builder
   h. Select AI model using contact.id
   i. Call generateResponse with system prompt + message history + user message
   j. Log user message to ari_messages (role='user')
   k. Log AI response to ari_messages (role='assistant', include ai_model, tokens, response_time)
   l. Determine next state using state machine
   m. Update ari_conversations if state changed
   n. Send AI response via Kapso sendMessage
   o. Return { success: true, response: aiReply }

6. Handle errors gracefully:
   - If AI fails, use fallback: "Maaf, ada gangguan teknis. Bentar ya."
   - Log errors but don't throw (webhook must not fail)
   - Still log the failed attempt to ari_messages
</action>
<verify>
- File exists at src/lib/ari/processor.ts
- processWithARI is exported
- Function handles missing config gracefully (uses defaults)
- Errors are caught and logged, not thrown
</verify>
</task>

<task id="2">
<title>Integrate ARI into webhook handler</title>
<action>
1. Modify `src/app/api/webhook/kapso/route.ts`:

2. Add imports at top (after existing imports, around line 1-20):
   ```typescript
   import { processWithARI } from '@/lib/ari/processor'
   import { decrypt } from '@/lib/crypto'
   ```

3. Create helper function `getKapsoCredentials(supabase, workspaceId)` (add after line 130, before processWebhookAsync):
   - Query workspaces table for kapso_api_key, kapso_phone_id
   - Decrypt API key using decrypt() from lib/crypto
   - Return { apiKey, phoneId } or null if not configured

4. In `processWorkspaceMessages()` function (starts at line 203), add ARI processing AFTER the conversation updates loop ends (around line 340, after "// Update each conversation" block):
   ```typescript
   // === ARI PROCESSING (async, non-blocking) ===
   // Process with ARI for each new message
   for (const messageData of newMessages) {
     const contact = contactMap.get(messageData.phone)
     if (!contact) continue

     // Check if workspace has ARI enabled (has ari_config)
     const { data: ariConfig } = await supabase
       .from('ari_config')
       .select('id')
       .eq('workspace_id', workspaceId)
       .single()

     if (!ariConfig) continue // No ARI for this workspace

     // Get Kapso credentials
     const credentials = await getKapsoCredentials(supabase, workspaceId)
     if (!credentials) continue

     // Get message content
     const messageContent = messageData.message.text?.body || ''
     if (!messageContent) continue // Skip non-text messages for now

     // Process with ARI (async, don't block webhook)
     processWithARI({
       workspaceId,
       contactId: contact.id,
       contactPhone: messageData.phone,
       userMessage: messageContent,
       kapsoCredentials: credentials,
     }).catch(err => {
       console.error('[Webhook] ARI processing error:', err)
     })
   }
   ```

5. Important: The ARI processing is NOT awaited - webhook returns 200 immediately while AI processes in background.
</action>
<verify>
- grep confirms processWithARI().catch pattern without await: `grep -E "processWithARI\(" src/app/api/webhook/kapso/route.ts | grep -v "await processWithARI"`
- ARI only processes for workspaces with ari_config
- Non-text messages are skipped gracefully
- Errors in ARI don't affect webhook response
</verify>
</task>

<task id="3">
<title>Update exports and add workspace ARI check</title>
<action>
1. Update `src/lib/ari/index.ts` to export:
   - processWithARI from processor.ts

2. Add helper function in processor.ts for checking ARI status:
   ```typescript
   export async function isARIEnabledForWorkspace(
     supabase: SupabaseClient,
     workspaceId: string
   ): Promise<boolean> {
     const { data } = await supabase
       .from('ari_config')
       .select('id')
       .eq('workspace_id', workspaceId)
       .single()
     return !!data
   }
   ```

3. Add function to manually trigger ARI for a contact (useful for testing):
   ```typescript
   export async function triggerARIGreeting(
     workspaceId: string,
     contactId: string,
     contactPhone: string
   ): Promise<{ success: boolean; error?: string }> {
     // Implementation similar to processWithARI but starts fresh greeting
     // Useful for testing without actual WhatsApp message
   }
   ```

4. Ensure all async operations use try-catch
</action>
<verify>
- processWithARI exported from @/lib/ari
- isARIEnabledForWorkspace returns boolean
- triggerARIGreeting allows manual testing
</verify>
</task>

## Verification

- [ ] Webhook still processes messages normally
- [ ] ARI config check prevents processing for non-ARI workspaces
- [ ] User message logged to ari_messages
- [ ] AI response logged to ari_messages with model info
- [ ] Response sent via Kapso sendMessage
- [ ] Conversation state updated in ari_conversations

## Success Criteria

- Incoming WhatsApp triggers ARI processing
- Phone matching works to find CRM contact
- AI generates contextual response
- Response sent back via WhatsApp
- All messages logged for conversation history

## Requirements Addressed

- **ARI-01**: Phone number matching to pull CRM data
- **ARI-02**: Greet by name (using form data in prompt)
- **ARI-06**: Maintain context (messages logged, history passed to AI)
