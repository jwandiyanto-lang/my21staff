---
phase: 19-performance-security
plan: 02
type: execute
wave: 2
depends_on: [19-01]
files_modified:
  - src/lib/rate-limit.ts
  - src/app/api/auth/login/route.ts
  - src/app/api/auth/signup/route.ts
  - src/app/api/messages/send/route.ts
  - src/app/api/messages/send-media/route.ts
  - src/app/api/webinars/register/route.ts
autonomous: true

must_haves:
  truths:
    - "Auth endpoints limited to 5 requests per minute per IP"
    - "Message endpoints limited to 30 requests per minute per user"
    - "Public form endpoints limited to 10 requests per minute per IP"
    - "Rate limit exceeded returns 429 with Retry-After header"
  artifacts:
    - path: "src/lib/rate-limit.ts"
      provides: "In-memory rate limiting with sliding window"
      exports: ["rateLimit", "rateLimitByUser"]
    - path: "src/app/api/messages/send/route.ts"
      provides: "Rate-limited message sending"
      contains: "rateLimitByUser"
  key_links:
    - from: "src/app/api/auth/login/route.ts"
      to: "src/lib/rate-limit.ts"
      via: "import rateLimit"
      pattern: "rateLimit"
    - from: "src/app/api/messages/send/route.ts"
      to: "src/lib/rate-limit.ts"
      via: "import rateLimitByUser"
      pattern: "rateLimitByUser"
---

<objective>
Implement rate limiting on critical API endpoints

Purpose: Prevent brute force attacks on auth, spam on messaging, and abuse of public forms
Output: All high-risk endpoints protected with appropriate rate limits
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-performance-security/19-RESEARCH.md

@src/app/api/messages/send/route.ts
@src/app/api/webhook/kapso/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiting utility</name>
  <files>src/lib/rate-limit.ts</files>
  <action>
    Create `src/lib/rate-limit.ts` with a simple in-memory sliding window rate limiter.

    Note: In-memory is acceptable for a single-instance Vercel deployment. For multi-region, Upstash Redis would be needed, but that's overkill for current scale.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server'

    interface RateLimitStore {
      [key: string]: {
        count: number
        resetTime: number
      }
    }

    const store: RateLimitStore = {}

    // Clean expired entries every 5 minutes
    setInterval(() => {
      const now = Date.now()
      for (const key of Object.keys(store)) {
        if (store[key].resetTime < now) {
          delete store[key]
        }
      }
    }, 5 * 60 * 1000)

    function getClientIp(request: NextRequest): string {
      return (
        request.headers.get('x-forwarded-for')?.split(',')[0].trim() ||
        request.headers.get('x-real-ip') ||
        'unknown'
      )
    }

    /**
     * Rate limit by IP address (for public/auth endpoints)
     */
    export function rateLimit(
      request: NextRequest,
      options: { limit: number; windowMs: number }
    ): NextResponse | null {
      const ip = getClientIp(request)
      const key = `ip:${ip}:${request.nextUrl.pathname}`
      const now = Date.now()

      if (!store[key] || store[key].resetTime < now) {
        store[key] = { count: 1, resetTime: now + options.windowMs }
        return null
      }

      store[key].count++

      if (store[key].count > options.limit) {
        const retryAfter = Math.ceil((store[key].resetTime - now) / 1000)
        return NextResponse.json(
          { error: 'Too many requests. Please try again later.' },
          {
            status: 429,
            headers: { 'Retry-After': String(retryAfter) }
          }
        )
      }

      return null
    }

    /**
     * Rate limit by user ID (for authenticated endpoints)
     */
    export function rateLimitByUser(
      userId: string,
      endpoint: string,
      options: { limit: number; windowMs: number }
    ): NextResponse | null {
      const key = `user:${userId}:${endpoint}`
      const now = Date.now()

      if (!store[key] || store[key].resetTime < now) {
        store[key] = { count: 1, resetTime: now + options.windowMs }
        return null
      }

      store[key].count++

      if (store[key].count > options.limit) {
        const retryAfter = Math.ceil((store[key].resetTime - now) / 1000)
        return NextResponse.json(
          { error: 'Rate limit exceeded. Please slow down.' },
          {
            status: 429,
            headers: { 'Retry-After': String(retryAfter) }
          }
        )
      }

      return null
    }
    ```
  </action>
  <verify>File exists at src/lib/rate-limit.ts and exports rateLimit, rateLimitByUser</verify>
  <done>Rate limiting utility created with IP-based and user-based limiters</done>
</task>

<task type="auto">
  <name>Task 2: Add rate limits to auth and public endpoints</name>
  <files>src/app/api/webinars/register/route.ts</files>
  <action>
    Note: The codebase uses Supabase Auth directly (not custom auth routes). So we focus on public form endpoints.

    **For /api/webinars/register/route.ts:**

    Add at the top of the POST handler:
    ```typescript
    import { rateLimit } from '@/lib/rate-limit'

    export async function POST(request: NextRequest) {
      // Rate limit: 10 requests per minute per IP
      const rateLimitResponse = rateLimit(request, { limit: 10, windowMs: 60 * 1000 })
      if (rateLimitResponse) return rateLimitResponse

      // ... existing code
    }
    ```

    If there are other public form endpoints (like contact forms), apply the same pattern.

    Check for other public endpoints:
    - /api/articles/* - typically GET only, low risk
    - /api/webinars/* - registration is the main concern
  </action>
  <verify>
    grep "rateLimit" src/app/api/webinars/register/route.ts
  </verify>
  <done>Public form endpoints protected with IP-based rate limiting</done>
</task>

<task type="auto">
  <name>Task 3: Add rate limits to messaging endpoints</name>
  <files>src/app/api/messages/send/route.ts, src/app/api/messages/send-media/route.ts</files>
  <action>
    **For /api/messages/send/route.ts:**

    Add after the user authentication check (after getting user.id):
    ```typescript
    import { rateLimitByUser } from '@/lib/rate-limit'

    // After auth check:
    // Rate limit: 30 messages per minute per user
    const rateLimitResponse = rateLimitByUser(user.id, 'messages/send', { limit: 30, windowMs: 60 * 1000 })
    if (rateLimitResponse) return rateLimitResponse
    ```

    **For /api/messages/send-media/route.ts:**

    Same pattern, but with a tighter limit (media uploads are more expensive):
    ```typescript
    // Rate limit: 10 media messages per minute per user
    const rateLimitResponse = rateLimitByUser(user.id, 'messages/send-media', { limit: 10, windowMs: 60 * 1000 })
    if (rateLimitResponse) return rateLimitResponse
    ```

    Note: The webhook endpoint (/api/webhook/kapso) should NOT be rate limited as it receives from Kapso/Meta and needs to process all incoming messages.
  </action>
  <verify>
    grep "rateLimitByUser" src/app/api/messages/send/route.ts
    grep "rateLimitByUser" src/app/api/messages/send-media/route.ts
  </verify>
  <done>Messaging endpoints protected with user-based rate limiting</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Rate limit utility exists: `ls src/lib/rate-limit.ts`
3. All protected endpoints import and use rate limiting:
   - grep "rateLimit" src/app/api/webinars/register/route.ts
   - grep "rateLimitByUser" src/app/api/messages/send/route.ts
</verification>

<success_criteria>
- Rate limiting utility created with sliding window algorithm
- Public form endpoints limited to 10 req/min per IP
- Message endpoints limited to 30 req/min per user (text) or 10 req/min (media)
- All rate limit responses include 429 status and Retry-After header
</success_criteria>

<output>
After completion, create `.planning/phases/19-performance-security/19-02-SUMMARY.md`
</output>
