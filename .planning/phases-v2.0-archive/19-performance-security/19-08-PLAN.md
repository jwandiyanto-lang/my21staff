---
phase: 19-performance-security
plan: 08
type: execute
wave: 3
depends_on: []
files_modified:
  - src/lib/crypto.ts
  - src/app/api/workspaces/[id]/settings/route.ts
autonomous: true

must_haves:
  truths:
    - "Kapso API key is encrypted before storing in database"
    - "API key is decrypted when needed for API calls"
    - "Encryption key is stored in environment variable"
  artifacts:
    - path: "src/lib/crypto.ts"
      provides: "Encryption/decryption helpers"
    - path: "src/app/api/workspaces/[id]/settings/route.ts"
      provides: "Encrypted API key storage"
      contains: "encrypt"
---

<objective>
Encrypt Kapso API keys at rest in database

Purpose: Protect API keys if database is compromised
Output: API keys stored encrypted, decrypted only when needed
</objective>

<context>
Currently kapso_api_key is stored in plain text in workspaces.settings JSONB column.
If someone gets database access, they can read all API keys.

Solution: Use AES-256-GCM encryption with a key stored in environment variable.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create encryption helpers</name>
  <files>src/lib/crypto.ts</files>
  <action>
    Create encryption/decryption helpers using Node.js crypto module.

    ```typescript
    import crypto from 'crypto'

    const ALGORITHM = 'aes-256-gcm'
    const IV_LENGTH = 16
    const AUTH_TAG_LENGTH = 16

    function getEncryptionKey(): Buffer {
      const key = process.env.ENCRYPTION_KEY
      if (!key) {
        throw new Error('ENCRYPTION_KEY environment variable not set')
      }
      // Key should be 32 bytes (256 bits) - hash it to ensure correct length
      return crypto.createHash('sha256').update(key).digest()
    }

    export function encrypt(text: string): string {
      const key = getEncryptionKey()
      const iv = crypto.randomBytes(IV_LENGTH)
      const cipher = crypto.createCipheriv(ALGORITHM, key, iv)

      let encrypted = cipher.update(text, 'utf8', 'hex')
      encrypted += cipher.final('hex')

      const authTag = cipher.getAuthTag()

      // Return iv:authTag:encrypted (all hex encoded)
      return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`
    }

    export function decrypt(encryptedText: string): string {
      const key = getEncryptionKey()
      const [ivHex, authTagHex, encrypted] = encryptedText.split(':')

      if (!ivHex || !authTagHex || !encrypted) {
        throw new Error('Invalid encrypted text format')
      }

      const iv = Buffer.from(ivHex, 'hex')
      const authTag = Buffer.from(authTagHex, 'hex')
      const decipher = crypto.createDecipheriv(ALGORITHM, key, iv)
      decipher.setAuthTag(authTag)

      let decrypted = decipher.update(encrypted, 'hex', 'utf8')
      decrypted += decipher.final('utf8')

      return decrypted
    }

    // Check if a string looks like our encrypted format
    export function isEncrypted(text: string): boolean {
      const parts = text.split(':')
      return parts.length === 3 && parts[0].length === IV_LENGTH * 2
    }
    ```
  </action>
</task>

<task type="auto">
  <name>Task 2: Encrypt API key when saving settings</name>
  <files>src/app/api/workspaces/[id]/settings/route.ts</files>
  <action>
    Update the PATCH handler to encrypt kapso_api_key before storing.

    1. Import encrypt from crypto helpers
    2. Before saving, encrypt the API key if provided
    3. Store encrypted value in database

    Add import:
    ```typescript
    import { encrypt } from '@/lib/crypto'
    ```

    In the PATCH handler, before updating:
    ```typescript
    // Encrypt API key if provided
    if (kapso_api_key) {
      try {
        settings.kapso_api_key = encrypt(kapso_api_key)
      } catch (error) {
        console.error('Encryption error:', error)
        return NextResponse.json(
          { error: 'Failed to secure API key' },
          { status: 500 }
        )
      }
    }
    ```

    Note: Keep encryption optional - if ENCRYPTION_KEY not set, fall back to plain storage with warning.
  </action>
</task>

<task type="auto">
  <name>Task 3: Decrypt API key when reading for API calls</name>
  <files>src/app/api/messages/send/route.ts</files>
  <action>
    Update message sending to decrypt the API key before use.

    1. Import decrypt and isEncrypted from crypto helpers
    2. When reading kapso_api_key from settings, decrypt if encrypted

    Add import:
    ```typescript
    import { decrypt, isEncrypted } from '@/lib/crypto'
    ```

    When getting API key:
    ```typescript
    let apiKey = settings?.kapso_api_key
    if (apiKey && isEncrypted(apiKey)) {
      try {
        apiKey = decrypt(apiKey)
      } catch (error) {
        console.error('Decryption error:', error)
        return NextResponse.json(
          { error: 'Failed to access API credentials' },
          { status: 500 }
        )
      }
    }
    ```

    Also update src/app/api/messages/send-media/route.ts with same pattern.
  </action>
</task>

</tasks>

<verification>
1. File exists: src/lib/crypto.ts
2. grep "encrypt" src/app/api/workspaces/[id]/settings/route.ts
3. grep "decrypt" src/app/api/messages/send/route.ts
4. npm run build passes
</verification>

<notes>
After deploying:
1. Generate a strong encryption key: openssl rand -hex 32
2. Add to environment: ENCRYPTION_KEY=<generated-key>
3. Existing plain-text keys will continue working (isEncrypted check)
4. New keys will be encrypted automatically
5. Consider a migration script to encrypt existing keys
</notes>
