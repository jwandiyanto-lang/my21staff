---
phase: 04-support-ticketing
plan: 05
type: execute
wave: 4
depends_on: ["04-04"]
files_modified:
  - src/emails/ticket-created.tsx
  - src/emails/ticket-updated.tsx
  - src/emails/ticket-closed.tsx
  - src/lib/tickets/email.ts
  - src/app/api/tickets/[id]/transition/route.ts
  - src/app/api/tickets/[id]/comments/route.ts
  - supabase/migrations/27_ticket_auto_close.sql
autonomous: true

must_haves:
  truths:
    - "Email templates exist for ticket created, updated, and closed"
    - "notifyParticipants flag triggers email sending"
    - "Auto-close email includes reopen link with token"
    - "pg_cron job runs daily to close old implementation tickets"
    - "Reopen link in email works without login"
  artifacts:
    - path: "src/emails/ticket-created.tsx"
      provides: "Ticket creation notification"
      min_lines: 30
    - path: "src/emails/ticket-closed.tsx"
      provides: "Auto-close with reopen link"
      min_lines: 40
    - path: "supabase/migrations/27_ticket_auto_close.sql"
      provides: "pg_cron auto-close job"
      contains: "cron.schedule"
  key_links:
    - from: "src/lib/tickets/email.ts"
      to: "src/lib/email/resend.ts"
      via: "Resend client"
      pattern: "getResend"
    - from: "src/emails/ticket-closed.tsx"
      to: "generateReopenToken"
      via: "reopen link generation"
      pattern: "reopenLink"
---

<objective>
Add email notifications for ticket lifecycle and pg_cron auto-close functionality.

Purpose: Keep participants informed via email (when toggled) and auto-close stale tickets.
Output: Email templates, send functions, and database auto-close job.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-support-ticketing/04-CONTEXT.md
@.planning/phases/04-support-ticketing/04-RESEARCH.md
@.planning/phases/04-support-ticketing/04-03-SUMMARY.md
@.planning/phases/04-support-ticketing/04-04-SUMMARY.md
@src/emails/invitation.tsx
@src/emails/components/base-layout.tsx
@src/lib/email/resend.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email templates for tickets</name>
  <files>src/emails/ticket-created.tsx, src/emails/ticket-updated.tsx, src/emails/ticket-closed.tsx</files>
  <action>
Create three email templates following the pattern from src/emails/invitation.tsx:

**ticket-created.tsx:**
```typescript
interface TicketCreatedEmailProps {
  ticketTitle: string
  ticketId: string
  workspaceName: string
  requesterName: string
  category: string
  priority: string
  ticketLink: string
}

// Content (Bahasa Indonesia):
// - "Tiket Baru Dibuat"
// - Notify that [requesterName] created ticket in [workspaceName]
// - Show title, category, priority
// - Button: "Lihat Tiket" -> ticketLink
```

**ticket-updated.tsx:**
```typescript
interface TicketUpdatedEmailProps {
  ticketTitle: string
  ticketId: string
  workspaceName: string
  changedByName: string
  fromStage: string
  toStage: string
  comment?: string
  ticketLink: string
}

// Content (Bahasa Indonesia):
// - "Tiket Diperbarui"
// - "[changedByName] memindahkan tiket ke tahap [toStage]"
// - Show reason/comment if provided
// - Button: "Lihat Tiket" -> ticketLink
```

**ticket-closed.tsx:**
```typescript
interface TicketClosedEmailProps {
  ticketTitle: string
  ticketId: string
  workspaceName: string
  reopenLink: string  // Includes HMAC token
}

// Content (Bahasa Indonesia):
// - "Tiket Telah Selesai"
// - Auto-closed after 7 days in Implementation stage
// - If unsatisfied, can reopen within 7 days
// - Button: "Buka Kembali Tiket" -> reopenLink
// - Note: "Link ini berlaku selama 7 hari"
```

All templates use BaseLayout from @/src/emails/components/base-layout.tsx
Use existing brand colors and styling patterns.
  </action>
  <verify>Check files exist: `ls src/emails/ticket-*.tsx`. Verify they import BaseLayout and export default component.</verify>
  <done>Three email templates created with Bahasa Indonesia content</done>
</task>

<task type="auto">
  <name>Task 2: Create email sending utility and integrate with API</name>
  <files>src/lib/tickets/email.ts, src/app/api/tickets/[id]/transition/route.ts, src/app/api/tickets/[id]/comments/route.ts</files>
  <action>
**src/lib/tickets/email.ts:**
```typescript
import { getResend, FROM_EMAIL } from '@/lib/email/resend'
import { render } from '@react-email/render'
import TicketCreatedEmail from '@/emails/ticket-created'
import TicketUpdatedEmail from '@/emails/ticket-updated'
import TicketClosedEmail from '@/emails/ticket-closed'

interface Participant {
  email: string
  name: string
}

export async function sendTicketCreatedEmail(
  recipients: Participant[],
  props: Parameters<typeof TicketCreatedEmail>[0]
) {
  const resend = getResend()
  const html = await render(TicketCreatedEmail(props))

  for (const recipient of recipients) {
    await resend.emails.send({
      from: FROM_EMAIL,
      to: recipient.email,
      subject: `Tiket Baru: ${props.ticketTitle}`,
      html
    })
  }
}

export async function sendTicketUpdatedEmail(
  recipients: Participant[],
  props: Parameters<typeof TicketUpdatedEmail>[0]
) {
  const resend = getResend()
  const html = await render(TicketUpdatedEmail(props))

  for (const recipient of recipients) {
    await resend.emails.send({
      from: FROM_EMAIL,
      to: recipient.email,
      subject: `Tiket Diperbarui: ${props.ticketTitle}`,
      html
    })
  }
}

export async function sendTicketClosedEmail(
  recipient: Participant,
  props: Parameters<typeof TicketClosedEmail>[0]
) {
  const resend = getResend()
  const html = await render(TicketClosedEmail(props))

  await resend.emails.send({
    from: FROM_EMAIL,
    to: recipient.email,
    subject: `Tiket Selesai: ${props.ticketTitle}`,
    html
  })
}
```

**Update transition/route.ts:**
Add email sending when notifyParticipants is true:
```typescript
if (notifyParticipants) {
  // Get all participants (requester + commenters)
  const { data: comments } = await supabase
    .from('ticket_comments')
    .select('author_id')
    .eq('ticket_id', ticketId)

  const participantIds = new Set([
    ticket.requester_id,
    ...comments?.map(c => c.author_id) || []
  ])

  // Get email addresses
  const { data: profiles } = await supabase
    .from('profiles')
    .select('id, email, full_name')
    .in('id', Array.from(participantIds))

  const recipients = profiles?.map(p => ({
    email: p.email,
    name: p.full_name || p.email
  })) || []

  // Send notification
  await sendTicketUpdatedEmail(recipients, {
    ticketTitle: ticket.title,
    ticketId,
    workspaceName: workspace.name,
    changedByName: authResult.user.email,
    fromStage: STAGE_CONFIG[fromStage].labelId,
    toStage: STAGE_CONFIG[toStage].labelId,
    comment,
    ticketLink: `${process.env.NEXT_PUBLIC_APP_URL}/${workspace.slug}/support/${ticketId}`
  })
}
```
  </action>
  <verify>Test transition with notifyParticipants=true - check email sent via Resend dashboard or logs.</verify>
  <done>Email sending integrated into transition flow</done>
</task>

<task type="auto">
  <name>Task 3: Create pg_cron auto-close migration</name>
  <files>supabase/migrations/27_ticket_auto_close.sql</files>
  <action>
Create migration for automatic ticket closure:

```sql
-- Migration: 27_ticket_auto_close.sql
-- Auto-close tickets 7 days after reaching Implementation stage
-- Part of Phase 04: Support Ticketing Core

-- Enable pg_cron if not already enabled
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Create auto-close function
CREATE OR REPLACE FUNCTION public.auto_close_tickets()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  ticket_record RECORD;
BEGIN
  -- Find tickets in 'implementation' stage for 7+ days that aren't already closed
  FOR ticket_record IN
    SELECT t.id, t.requester_id, t.workspace_id, t.title
    FROM tickets t
    WHERE t.stage = 'implementation'
    AND t.updated_at < NOW() - INTERVAL '7 days'
    AND t.closed_at IS NULL
  LOOP
    -- Generate placeholder reopen token (app layer will regenerate with proper HMAC)
    -- Using random hex as placeholder - actual token generated when sending email
    UPDATE tickets
    SET
      stage = 'closed',
      closed_at = NOW(),
      reopen_token = encode(gen_random_bytes(32), 'hex'),
      updated_at = NOW()
    WHERE id = ticket_record.id;

    -- Add status history entry
    INSERT INTO ticket_status_history (ticket_id, changed_by, from_stage, to_stage, reason)
    VALUES (
      ticket_record.id,
      ticket_record.requester_id,  -- System action attributed to requester
      'implementation',
      'closed',
      'Ditutup otomatis setelah 7 hari di tahap Implementasi'
    );

    -- Note: Email notification will be handled by a separate process
    -- that polls for newly auto-closed tickets (where closed_at > NOW() - 1 day)
    -- and sends the proper HMAC-signed reopen link
  END LOOP;
END;
$$;

-- Schedule daily at 00:00 UTC (07:00 WIB)
-- Using SELECT to wrap cron.schedule for Supabase compatibility
SELECT cron.schedule(
  'auto-close-tickets',
  '0 0 * * *',
  $$SELECT public.auto_close_tickets()$$
);

-- Comment explaining the job
COMMENT ON FUNCTION public.auto_close_tickets() IS
  'Automatically closes tickets that have been in implementation stage for 7+ days.
   Runs daily at midnight UTC via pg_cron.';
```

**Note on email integration:**
The pg_cron job marks tickets as closed. For sending closure emails with proper HMAC tokens, we have two options:

Option A: Create a separate API endpoint that checks for recently auto-closed tickets and sends emails (can be triggered by Vercel Cron or called manually).

Option B: Accept that auto-closed tickets don't get email immediately (users can still see in-app and reopen authenticated).

For v1, use Option B - manual email if needed. The reopen functionality works via authenticated requester even without token.
  </action>
  <verify>Check migration syntax is valid SQL. Verify pg_cron schedule syntax is correct.</verify>
  <done>Auto-close cron job configured to run daily</done>
</task>

</tasks>

<verification>
1. Three email templates exist in src/emails/
2. Templates use BaseLayout and follow existing patterns
3. Email utility functions in src/lib/tickets/email.ts
4. Transition route sends email when notifyParticipants=true
5. Migration 27_ticket_auto_close.sql creates pg_cron job
6. Auto-close function runs at midnight UTC daily
7. Status history records auto-close reason
</verification>

<success_criteria>
- Email templates render correctly (test with react-email preview)
- Transition emails include ticket link
- Closed emails include reopen link
- pg_cron job scheduled for daily auto-close
- Auto-closed tickets have status history entry
- Manual reopen still works for requester (authenticated)
</success_criteria>

<output>
After completion, create `.planning/phases/04-support-ticketing/04-05-SUMMARY.md`
</output>
