---
phase: 05-implementation
plan: 04
type: execute
wave: 3
depends_on: [05-02]
files_modified: [convex/http/kapso.ts, convex/http/index.ts]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Kapso webhook receives Meta/WhatsApp payload"
    - "Webhook creates/updates contacts and conversations"
    - "Webhook creates messages with ARI processing"
  artifacts:
    - path: "convex/http/kapso.ts"
      provides: "Kapso webhook HTTP action"
      exports: ["http"]
    - path: "convex/http/index.ts"
      provides: "HTTP router entry point"
      exports: ["default"]
  key_links:
    - from: "convex/http/kapso.ts"
      to: "convex/mutations.ts"
      via: "ctx.runMutation"
      pattern: "runQuery.*upsertContact|runMutation.*createInboundMessage"
    - from: "convex/http/kapso.ts"
      to: "convex/lib/ari.ts"
      via: "ARI processing call"
      pattern: "processWithARI"
---

<objective>
Implement Kapso webhook HTTP action in Convex for real-time WhatsApp message processing.

Purpose: Replace Next.js /api/webhook/kapso with Convex HTTP action for improved performance and ARI integration.

Output: Complete Kapso webhook HTTP action in Convex.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/app/api/webhook/kapso/route.ts
@convex/http/contacts.ts
@convex/mutations.ts
@.planning/phases/05-implementation/05-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Create Kapso webhook types and HTTP router</name>
  <files>convex/http/kapso.ts</files>
  <action>
    Create convex/http/kapso.ts with webhook processing:

    1. Define types matching Meta/WhatsApp webhook payload:
       - MetaWebhookMessage: id, from, type, text/image/audio/video/document, timestamp, context
       - MetaWebhookContact: wa_id, profile.name
       - MetaWebhookValue: messaging_product, metadata (phone_number_id), contacts[], messages[]
       - MetaWebhookEntry: id, changes[]
       - MetaWebhookPayload: object, entry[]

    2. Create httpRouter with routes:
       - POST /webhook/kapso - Main webhook handler
       - GET /webhook/kapso - Verification (returns hub.challenge)

    3. POST handler:
       - Verify signature (x-kapso-signature header vs KAPSO_WEBHOOK_SECRET)
       - Parse JSON payload
       - Return 200 immediately (async processing with ctx.scheduler)
       - Schedule async processing with ctx.scheduler.runAfter(0, "processKapsoWebhook", { payload })

    4. GET handler:
       - Return challenge query param as plain text for Kapso verification

    Create the file with these structures, async processing scheduled.
  </action>
  <verify>cat convex/http/kapso.ts | grep -E "(MetaWebhookMessage|POST|GET)"</verify>
  <done>Kapso webhook types and HTTP router created</done>
</task>

<task type="auto">
  <name>Create scheduled function for webhook processing</name>
  <files>convex/kapso.ts</files>
  <action>
    Create convex/kapso.ts with scheduled webhook processor:

    1. Create mutation: processKapsoWebhook
       - Args: payload (MetaWebhookPayload)
       - Iterates over entry[].changes where field='messages'
       - Extracts phone_number_id from metadata
       - Finds workspace by kapso_phone_id (need index on workspaces by kapso_phone_id)
       - For each message:
         - Extracts contact info (wa_id, profile.name)
         - Normalizes phone number
         - Calls upsertContact mutation to get/create contact
         - Calls upsertConversation mutation to get/create conversation
         - Calls createInboundMessage mutation to store message
         - Updates conversation unread count and last message

    2. Add index to schema if missing:
       - In convex/schema.ts, add index to workspaces: .index("by_kapso_phone", ["kapso_phone_id"])

    3. Handle ARI processing:
       - Check if workspace has ari_config (need ari_config table in schema or in settings)
       - If enabled, schedule ARI processing (separate scheduled function)
       - Or call ARI mutation directly if no external API needed

    Process messages in batches for efficiency.
  </action>
  <verify>cat convex/kapso.ts | grep "processKapsoWebhook"</verify>
  <done>Scheduled webhook processor created with contact/conversation/message creation</done>
</task>

<task type="auto">
  <name>Add kapso_phone_id index to workspaces</name>
  <files>convex/schema.ts</files>
  <action>
    Update workspaces table in convex/schema.ts to add index:

    Add index: .index("by_kapso_phone", ["kapso_phone_id"])

    This enables efficient lookup by Kapso phone_number_id from webhook.
    Existing indexes: by_slug. Add new index after that.

    Read existing schema, update workspaces table definition, regenerate types.
  </action>
  <verify>grep "by_kapso_phone" convex/schema.ts</verify>
  <done>Workspaces table has kapso_phone_id index for webhook lookup</done>
</task>

<task type="auto">
  <name>Create ARI processing function for webhook</name>
  <files>convex/kapso.ts</files>
<action>
    Add to convex/kapso.ts ARI processing:

    1. Create scheduled function: processARIForMessage
       - Args: workspace_id, contact_id, contact_phone, user_message
       - Gets ari_config for workspace (from settings or ari_config table)
       - If not enabled, returns early
       - Gets Kapso credentials from workspace settings (encrypted)
       - Decrypts API key using safeDecrypt helper (import from lib/crypto)
       - Calls ARI processor to generate response
       - Sends AI response via Kapso API
       - Creates outbound message record

    2. Reference existing ARI processor:
       - Import processWithARI from @/lib/ari/processor if available as action
       - Or recreate logic inline for Convex (call external API)

    Since ARI needs external API calls (LLM, Kapso), use scheduled function to avoid timeout.

    Note: For fresh start, ARI config may be in workspace.settings JSON field.
  </action>
  <verify>cat convex/kapso.ts | grep "processARIForMessage"</verify>
  <done>ARI processing function created for webhook messages</done>
</task>

<task type="auto">
  <name>Update HTTP router to include Kapso webhook</name>
  <files>convex/http/index.ts</files>
  <action>
    Create or update convex/http/index.ts:

    Import http routers:
    - import kapsoRouter from "../kapso"

    Merge routers:
    - http.route(kapsoRouter)

    This ensures /webhook/kapso is registered in Convex HTTP actions.
    Existing contacts router in convex/http/contacts.ts should also be merged.

    If index.ts exists, add kapso import and merge. If not, create it.
  </action>
  <verify>cat convex/http/index.ts | grep -E "(kapso|contacts)"</verify>
  <done>HTTP router includes Kapso webhook and contacts endpoints</done>
</task>

</tasks>

<verification>
1. convex/http/kapso.ts exists with POST/GET webhook routes
2. convex/kapso.ts has processKapsoWebhook scheduled function
3. Workspaces table has by_kapso_phone index
4. ARI processing function exists for AI responses
5. convex/http/index.ts merges all HTTP routers
</verification>

<success_criteria>
1. Kapso webhook receives Meta payload and processes async
2. Contacts, conversations, messages created/updated correctly
3. Workspace lookup by kapso_phone_id is efficient
4. ARI processing triggers for enabled workspaces
5. HTTP action deployed and accessible (verified in Plan 05)
</success_criteria>

<output>
After completion, create `.planning/phases/05-implementation/05-04-SUMMARY.md`
</output>
