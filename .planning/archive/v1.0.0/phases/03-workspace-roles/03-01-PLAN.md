---
phase: 03-workspace-roles
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/permissions/types.ts
  - src/lib/permissions/constants.ts
  - src/lib/permissions/check.ts
  - src/lib/auth/workspace-auth.ts
  - supabase/migrations/25_member_lead_visibility.sql
autonomous: true

must_haves:
  truths:
    - "hasPermission('owner', 'leads:delete') returns true"
    - "hasPermission('member', 'leads:delete') returns false"
    - "requireWorkspaceMembership returns user role alongside membership"
    - "Members can only see leads assigned to them via RLS"
  artifacts:
    - path: "src/lib/permissions/types.ts"
      provides: "WorkspaceRole and Permission type definitions"
      exports: ["WorkspaceRole", "Permission"]
    - path: "src/lib/permissions/constants.ts"
      provides: "ROLE_PERMISSIONS mapping"
      exports: ["ROLE_PERMISSIONS"]
    - path: "src/lib/permissions/check.ts"
      provides: "Permission checking utilities"
      exports: ["hasPermission", "requirePermission"]
    - path: "src/lib/auth/workspace-auth.ts"
      provides: "Extended auth with role"
      exports: ["requireWorkspaceMembership", "AuthResult"]
    - path: "supabase/migrations/25_member_lead_visibility.sql"
      provides: "RLS policy for member-only lead visibility"
      contains: "CREATE POLICY"
  key_links:
    - from: "src/lib/permissions/check.ts"
      to: "src/lib/permissions/types.ts"
      via: "imports types"
      pattern: "import.*from.*types"
    - from: "src/lib/auth/workspace-auth.ts"
      to: "WorkspaceRole type"
      via: "returns role in AuthResult"
      pattern: "role.*WorkspaceRole"
---

<objective>
Create permission infrastructure â€” types, utilities, and RLS policies for workspace role enforcement.

Purpose: Foundation for all permission checks in the app. Without this, roles exist in DB but have no enforcement.
Output: `hasPermission()` utility, extended `requireWorkspaceMembership()` returning role, RLS policy for member lead filtering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-workspace-roles/03-CONTEXT.md
@.planning/phases/03-workspace-roles/03-RESEARCH.md

# Existing code to extend
@src/lib/auth/workspace-auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create permission types and constants</name>
  <files>
    src/lib/permissions/types.ts
    src/lib/permissions/constants.ts
  </files>
  <action>
Create permission infrastructure in `src/lib/permissions/`:

**types.ts:**
```typescript
export type WorkspaceRole = 'owner' | 'admin' | 'member'

export type Permission =
  | 'leads:delete'
  | 'leads:view_all'
  | 'leads:export'
  | 'team:invite'
  | 'team:remove'
  | 'team:change_role'
  | 'workspace:settings'
```

**constants.ts:**
Per CONTEXT.md decisions:
- Owner: all permissions (delete, view_all, export, invite, remove, change_role, settings)
- Admin: view_all, export only
- Member: no permissions (empty array)

```typescript
import { type Permission, type WorkspaceRole } from './types'

export const ROLE_PERMISSIONS: Record<WorkspaceRole, Permission[]> = {
  owner: [
    'leads:delete',
    'leads:view_all',
    'leads:export',
    'team:invite',
    'team:remove',
    'team:change_role',
    'workspace:settings'
  ],
  admin: [
    'leads:view_all',
    'leads:export'
  ],
  member: []
}
```

Add barrel export in `src/lib/permissions/index.ts`.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/lib/permissions/types.ts src/lib/permissions/constants.ts
```
  </verify>
  <done>
Types and constants exist with correct role-permission mapping per CONTEXT.md decisions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create hasPermission and requirePermission utilities</name>
  <files>src/lib/permissions/check.ts</files>
  <action>
Create permission checking utilities:

```typescript
import { NextResponse } from 'next/server'
import { ROLE_PERMISSIONS } from './constants'
import { type Permission, type WorkspaceRole } from './types'

/**
 * Check if a role has a specific permission
 */
export function hasPermission(role: WorkspaceRole, permission: Permission): boolean {
  return ROLE_PERMISSIONS[role].includes(permission)
}

/**
 * For API routes - returns 403 response if unauthorized, null if authorized
 */
export function requirePermission(
  role: WorkspaceRole,
  permission: Permission,
  errorMessage?: string
): NextResponse | null {
  if (!hasPermission(role, permission)) {
    return NextResponse.json(
      { error: errorMessage || `Insufficient permissions: requires ${permission}` },
      { status: 403 }
    )
  }
  return null
}
```

Update `src/lib/permissions/index.ts` to export these.
  </action>
  <verify>
```bash
npx tsc --noEmit src/lib/permissions/check.ts
```
  </verify>
  <done>
`hasPermission()` returns boolean, `requirePermission()` returns NextResponse|null for API route guards.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend requireWorkspaceMembership to return role</name>
  <files>src/lib/auth/workspace-auth.ts</files>
  <action>
Modify existing `requireWorkspaceMembership()` to:
1. Select `role` in the membership query (currently only selects `id`)
2. Add `role: WorkspaceRole` to `AuthResult` interface
3. Return role in the success case

Changes to make:

```typescript
import { type WorkspaceRole } from '@/lib/permissions/types'

export interface AuthResult {
  user: { id: string; email: string }
  workspaceId: string
  role: WorkspaceRole  // ADD THIS
}

// In the function:
const { data: membership } = await supabase
  .from('workspace_members')
  .select('id, role')  // ADD role to select
  .eq('workspace_id', workspaceId)
  .eq('user_id', user.id)
  .single()

// In the return:
return {
  user: { id: user.id, email: user.email || '' },
  workspaceId,
  role: membership.role as WorkspaceRole  // ADD THIS
}
```

This is a backward-compatible change - existing code that uses `requireWorkspaceMembership` will continue to work, now they also have access to `role`.
  </action>
  <verify>
```bash
npx tsc --noEmit src/lib/auth/workspace-auth.ts
```
Verify AuthResult includes role field.
  </verify>
  <done>
`requireWorkspaceMembership()` returns `{ user, workspaceId, role }` where role is typed as WorkspaceRole.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create RLS policy for member lead visibility</name>
  <files>supabase/migrations/25_member_lead_visibility.sql</files>
  <action>
Create migration to update contacts SELECT policy so members only see assigned leads.

Per RESEARCH.md recommendations:
1. Create a SECURITY DEFINER function in private schema for role lookup (avoids RLS recursion, improves performance)
2. Replace current contacts SELECT policy with role-aware version

```sql
-- Migration: 25_member_lead_visibility.sql
-- Members can only see contacts assigned to them; owners/admins see all

-- Create private schema if not exists
CREATE SCHEMA IF NOT EXISTS private;

-- Create role lookup function (SECURITY DEFINER for performance)
CREATE OR REPLACE FUNCTION private.get_user_role_in_workspace(workspace_uuid UUID)
RETURNS TEXT
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT role FROM workspace_members
  WHERE workspace_id = workspace_uuid
  AND user_id = auth.uid()
$$;

-- Drop existing SELECT policy
DROP POLICY IF EXISTS "Users can view contacts in their workspaces" ON contacts;

-- Create new role-aware SELECT policy
-- Owners and admins see all contacts in workspace
-- Members only see contacts assigned to them
CREATE POLICY "Users can view contacts based on role" ON contacts
  FOR SELECT USING (
    -- Owner/admin can see all
    (SELECT private.get_user_role_in_workspace(workspace_id)) IN ('owner', 'admin')
    OR (
      -- Members only see assigned contacts
      (SELECT private.get_user_role_in_workspace(workspace_id)) = 'member'
      AND assigned_to = (SELECT auth.uid())
    )
  );

-- Add index for assigned_to lookups if not exists
CREATE INDEX IF NOT EXISTS idx_contacts_assigned_to ON contacts(assigned_to);
```

Run migration via Supabase dashboard or CLI.
  </action>
  <verify>
Apply migration to Supabase:
```bash
# If using Supabase CLI
supabase db push

# Or manually via Supabase dashboard SQL editor
```

Test with different role users:
- Owner/admin should see all contacts
- Member should only see contacts where assigned_to = their user_id
  </verify>
  <done>
RLS policy enforces member-only visibility for contacts. Members see only assigned leads, owners/admins see all.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run build` succeeds
2. Permission checks work:
   - `hasPermission('owner', 'leads:delete')` === true
   - `hasPermission('admin', 'leads:delete')` === false
   - `hasPermission('member', 'leads:delete')` === false
3. Auth returns role: `requireWorkspaceMembership()` result includes `role` field
4. RLS active: Member user only sees assigned contacts in database queries
</verification>

<success_criteria>
- Permission types, constants, and utilities exist in `src/lib/permissions/`
- `requireWorkspaceMembership()` returns `{ user, workspaceId, role }`
- RLS policy migration applied to Supabase
- `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-workspace-roles/03-01-SUMMARY.md`
</output>
