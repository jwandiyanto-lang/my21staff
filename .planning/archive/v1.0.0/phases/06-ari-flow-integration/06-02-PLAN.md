---
phase: 06-ari-flow-integration
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - convex/schema.ts
  - convex/ai/brain.ts
  - convex/kapso.ts
autonomous: true

must_haves:
  truths:
    - "ariConversations table has next_action field (human-readable string)"
    - "Brain receives workspace scoring_rules from getAriContext"
    - "Brain applies scoring_rules to calculate lead_score and lead_temperature"
    - "Conversation.next_action shows AI's planned next step (visible in Inbox)"
    - "Changing Scoring tab in Your Intern affects next lead_score calculation"
  artifacts:
    - path: "convex/schema.ts"
      provides: "ariConversations with next_action field"
      contains: "next_action: v.optional(v.string())"
      min_lines: 20
    - path: "convex/ai/brain.ts"
      provides: "Brain action with scoring_rules parameter"
      exports: ["analyzeLead"]
      contains: "scoringRules"
    - path: "convex/kapso.ts"
      provides: "processARI passes scoring_rules to Brain"
      contains: "analyzeLead"
  key_links:
    - from: "convex/kapso.ts"
      to: "workspace.settings.scoring_rules"
      via: "getAriContext fetch"
      pattern: "scoringRules"
    - from: "convex/ai/brain.ts"
      to: "lead_score calculation"
      via: "scoring_rules application"
      pattern: "args\\.scoringRules"
    - from: "convex/kapso.ts"
      to: "conversation.next_action"
      via: "saveAriResponse update"
      pattern: "next_action:"
---

<objective>
Wire Brain to use workspace scoring_rules for lead analysis. Add next_action field for debugging AI's planned next step.

Purpose: Enable configurable scoring (admins set thresholds) and visible AI state (humans see what bot plans to do next).
Output: Brain applies workspace scoring rules; conversation.next_action shows planned step.
</objective>

<execution_context>
@/home/jfransisco/.claude/get-shit-done/workflows/execute-plan.md
@/home/jfransisco/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/jfransisco/Desktop/21/my21staff/.planning/PROJECT.md
@/home/jfransisco/Desktop/21/my21staff/.planning/ROADMAP.md
@/home/jfransisco/Desktop/21/my21staff/.planning/STATE.md
@/home/jfransisco/Desktop/21/my21staff/.planning/phases/06-ari-flow-integration/06-CONTEXT.md
@/home/jfransisco/Desktop/21/my21staff/.planning/phases/06-ari-flow-integration/06-RESEARCH.md

# Prior work
@/home/jfransisco/Desktop/21/my21staff/.planning/phases/06-ari-flow-integration/06-01-SUMMARY.md

# Key files
@/home/jfransisco/Desktop/21/my21staff/convex/schema.ts
@/home/jfransisco/Desktop/21/my21staff/convex/ai/brain.ts
@/home/jfransisco/Desktop/21/my21staff/convex/kapso.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add next_action field to ariConversations schema</name>
  <files>convex/schema.ts</files>
  <action>
    Update ariConversations table definition to include next_action field:

    1. Find ariConversations table (search for "ariConversations: defineTable")
    2. Add field after existing fields:
       ```typescript
       next_action: v.optional(v.string()), // Human-readable next step (e.g., "Ask about passport", "Offer routing options")
       ```
    3. This field stores what the AI plans to do next, visible in Inbox for debugging

    Pattern: Optional field for backward compatibility with existing conversations.
  </action>
  <verify>
    ```bash
    # Check next_action field exists in schema
    grep "next_action:" convex/schema.ts
    ```
  </verify>
  <done>ariConversations schema includes next_action field (optional string)</done>
</task>

<task type="auto">
  <name>Task 2: Update Brain to accept and apply workspace scoring_rules</name>
  <files>convex/ai/brain.ts</files>
  <action>
    Modify analyzeLead action to use workspace scoring rules:

    1. Add optional arg to analyzeLead:
       ```typescript
       scoringRules: v.optional(v.any()), // Workspace scoring configuration
       ```
    2. Find current lead_score calculation logic (likely hardcoded thresholds)
    3. Replace with dynamic scoring based on scoringRules:
       - If scoringRules provided, apply category weights (basic, qualification, documents, engagement)
       - Calculate lead_score as weighted sum (0-100 scale)
       - Determine lead_temperature based on scoringRules thresholds (hot/warm/cold):
         * hot: score >= scoringRules.hot_threshold (default 70)
         * warm: score >= scoringRules.warm_threshold (default 40)
         * cold: score < warm_threshold
       - Fallback to existing hardcoded logic if scoringRules not provided
    4. Return next_action recommendation: "Ask about {next_document}", "Offer routing options", "Schedule consultation", etc.

    Pattern: Brain uses workspace config when available, falls back to defaults for backward compatibility.
  </action>
  <verify>
    ```bash
    # Check Brain accepts scoring_rules
    grep "scoringRules" convex/ai/brain.ts

    # Check Brain returns next_action
    grep "next_action" convex/ai/brain.ts
    ```
  </verify>
  <done>Brain applies workspace scoring_rules to calculate lead_score and lead_temperature; returns next_action recommendation</done>
</task>

<task type="auto">
  <name>Task 3: Wire processARI to pass scoring_rules to Brain and save next_action</name>
  <files>convex/kapso.ts</files>
  <action>
    Update processARI mutation to pass workspace config to Brain and persist next_action:

    1. Find processARI mutation call to analyzeLead (Brain)
    2. Add scoring_rules from getAriContext result to analyzeLead invocation:
       ```typescript
       const brainResult = await ctx.runAction(internal.ai.brain.analyzeLead, {
         conversationHistory: context.messageHistory,
         currentState: context.ariState,
         qualificationContext: context.ariContext,
         scoringRules: context.scoringRules, // NEW
       });
       ```
    3. Find saveAriResponse call that updates ariConversation
    4. Add next_action to update:
       ```typescript
       await ctx.runMutation(internal.kapso.saveAriResponse, {
         ariConversationId: context.ariConversationId,
         next_action: brainResult.next_action, // NEW
         // ... existing fields
       });
       ```
    5. Update saveAriResponse mutation to accept and save next_action field

    Pattern: processARI orchestrates config flow: getAriContext -> Brain (with scoringRules) -> saveAriResponse (with next_action).
  </action>
  <verify>
    ```bash
    # Check processARI passes scoring_rules to Brain
    grep -A 5 "analyzeLead" convex/kapso.ts | grep scoringRules

    # Check saveAriResponse saves next_action
    grep "next_action" convex/kapso.ts
    ```
  </verify>
  <done>processARI passes fresh workspace scoring_rules to Brain; Brain result includes next_action; next_action saved to ariConversation</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify schema change:
   ```bash
   grep "next_action:" convex/schema.ts
   ```

2. Check Brain uses scoring_rules:
   ```bash
   grep -A 10 "scoringRules" convex/ai/brain.ts
   ```

3. Confirm processARI wires everything:
   ```bash
   grep -B 3 -A 8 "analyzeLead" convex/kapso.ts
   ```

Expected: Brain receives fresh workspace scoring_rules on every call. Lead scoring uses admin-configured thresholds. next_action visible for debugging.
</verification>

<success_criteria>
- [ ] ariConversations schema includes next_action field (optional string)
- [ ] Brain accepts scoringRules parameter and applies workspace-configured thresholds
- [ ] Brain calculates lead_score using category weights from scoringRules
- [ ] Brain determines lead_temperature (hot/warm/cold) using workspace thresholds
- [ ] Brain returns next_action recommendation (human-readable next step)
- [ ] processARI passes fresh scoringRules from getAriContext to Brain
- [ ] saveAriResponse saves next_action to ariConversation record
- [ ] Changing Scoring tab in Your Intern affects next lead analysis
</success_criteria>

<output>
After completion, create `.planning/phases/06-ari-flow-integration/06-02-SUMMARY.md`
</output>
