---
phase: 01-database-inbox-overhaul
plan: 04
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx
  - src/lib/queries/use-conversations.ts
  - src/app/api/conversations/route.ts
autonomous: true

must_haves:
  truths:
    - "User can toggle between Active (unread) and All conversations"
    - "Active filter shows only contacts with unread messages"
    - "User can filter conversations by tags (OR logic)"
    - "User can filter conversations by lead status"
    - "User can save filter presets for quick access"
    - "User can load and delete saved filter presets"
    - "Sidebar unread count updates when switching to Active view"
  artifacts:
    - path: "src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx"
      provides: "Updated inbox with Active/All toggle, enhanced filters, and filter preset management"
      min_lines: 600
    - path: "src/lib/queries/use-conversations.ts"
      provides: "Conversations query with filter support"
      min_lines: 70
    - path: "src/app/api/conversations/route.ts"
      provides: "Conversations API with filter parameters"
      min_lines: 80
  key_links:
    - from: "inbox-client.tsx"
      to: "use-conversations.ts"
      via: "useConversations hook with filters"
      pattern: "useConversations.*showUnreadOnly|activeFilter"
    - from: "use-conversations.ts"
      to: "/api/conversations"
      via: "fetch with query params"
      pattern: "fetch.*api/conversations.*active=|unread="
    - from: "inbox-client.tsx"
      to: "workspace_members.settings"
      via: "filter preset save/load"
      pattern: "filterPresets|savePreset|loadPreset"
---

<objective>
Implement Active/All conversation filter toggle and enhance existing tag/status filters.

Purpose: Allow users to quickly focus on conversations needing attention (unread messages) while maintaining access to all conversations. Support saved filter presets for power users.

Output: Updated inbox UI with Active/All toggle, enhanced filter API endpoint, and filter preset storage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-database-inbox-overhaul/01-CONTEXT.md
@.planning/phases/01-database-inbox-overhaul/01-RESEARCH.md
@src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx
@src/lib/queries/use-conversations.ts
@.planning/phases/01-database-inbox-overhaul/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update conversations API for Active/All filtering</name>
  <files>src/app/api/conversations/route.ts</files>
  <action>
Update the conversations API to support Active/All filtering and enhanced filters.

Read the current file first, then add:

1. New query parameters: `active` (boolean - show only unread), `status[]`, `tags[]`
2. Server-side filtering for better performance
3. Count queries for total vs filtered

Key changes:

```typescript
// Add to GET handler query params
const active = searchParams.get('active') === 'true'
const statusFilters = searchParams.getAll('status')
const tagFilters = searchParams.getAll('tags')

// Build query with filters
let query = supabase
  .from('conversations')
  .select('*, contact:contacts!inner(*)', { count: 'exact' })
  .eq('workspace_id', workspaceId)
  .order('last_message_at', { ascending: false })

// Active filter (unread only)
if (active) {
  query = query.gt('unread_count', 0)
}

// Status filter (if provided)
if (statusFilters.length > 0) {
  query = query.in('contact.lead_status', statusFilters)
}

// Tag filter (if provided) - uses array overlap
if (tagFilters.length > 0) {
  // Supabase doesn't support array overlap in JS client directly
  // Use raw SQL filter
  query = query.filter('contact.tags', 'ov', `{${tagFilters.join(',')}}`)
}

// Also return activeCount (unread conversations) for sidebar badge
const { count: activeCount } = await supabase
  .from('conversations')
  .select('*', { count: 'exact', head: true })
  .eq('workspace_id', workspaceId)
  .gt('unread_count', 0)

return NextResponse.json({
  conversations,
  totalCount,
  activeCount, // NEW: for sidebar badge
  teamMembers,
  quickReplies,
  contactTags,
})
```
  </action>
  <verify>
Test API with filters:
```bash
curl "http://localhost:3000/api/conversations?workspace=xxx&active=true"
curl "http://localhost:3000/api/conversations?workspace=xxx&status=hot&status=warm"
curl "http://localhost:3000/api/conversations?workspace=xxx&tags=Australia"
```
  </verify>
  <done>Conversations API supports active, status[], and tags[] query parameters</done>
</task>

<task type="auto">
  <name>Task 2: Update useConversations hook for filter support</name>
  <files>src/lib/queries/use-conversations.ts</files>
  <action>
Update the useConversations hook to accept filter parameters and pass them to API:

```typescript
'use client'

import { useQuery, useQueryClient } from '@tanstack/react-query'
import { createClient } from '@/lib/supabase/client'
import { useEffect } from 'react'
import type { ConversationWithContact, WorkspaceMember, Profile } from '@/types/database'
import { isDevMode, MOCK_CONVERSATIONS } from '@/lib/mock-data'

export type TeamMember = WorkspaceMember & { profile: Profile | null }

interface ConversationFilters {
  active?: boolean
  statusFilters?: string[]
  tagFilters?: string[]
  assignedTo?: string
}

interface ConversationsResponse {
  conversations: ConversationWithContact[]
  totalCount: number
  activeCount: number  // NEW: count of unread conversations
  teamMembers: TeamMember[]
  quickReplies: Array<{id: string, label: string, text: string}>
  contactTags: string[]
}

const PAGE_SIZE = 50

export function useConversations(
  workspaceId: string,
  page: number = 0,
  filters: ConversationFilters = {}
) {
  const queryClient = useQueryClient()

  const query = useQuery({
    // Include filters in query key for proper caching
    queryKey: ['conversations', workspaceId, page, filters],
    queryFn: async (): Promise<ConversationsResponse> => {
      if (isDevMode()) {
        let filtered = MOCK_CONVERSATIONS
        if (filters.active) {
          filtered = filtered.filter(c => (c.unread_count ?? 0) > 0)
        }
        return {
          conversations: filtered,
          totalCount: MOCK_CONVERSATIONS.length,
          activeCount: MOCK_CONVERSATIONS.filter(c => (c.unread_count ?? 0) > 0).length,
          teamMembers: [],
          quickReplies: [],
          contactTags: ['Community', '1on1'],
        }
      }

      // Build URL with filters
      const params = new URLSearchParams({
        workspace: workspaceId,
        page: page.toString(),
        limit: PAGE_SIZE.toString(),
      })

      if (filters.active) {
        params.set('active', 'true')
      }

      if (filters.statusFilters?.length) {
        filters.statusFilters.forEach(s => params.append('status', s))
      }

      if (filters.tagFilters?.length) {
        filters.tagFilters.forEach(t => params.append('tags', t))
      }

      if (filters.assignedTo && filters.assignedTo !== 'all') {
        params.set('assigned', filters.assignedTo)
      }

      const response = await fetch(`/api/conversations?${params.toString()}`)
      if (!response.ok) {
        throw new Error('Failed to load conversations')
      }
      return response.json()
    },
    staleTime: 60 * 1000,
    placeholderData: (previousData) => previousData,
  })

  // Real-time subscription - invalidate on changes
  useEffect(() => {
    if (isDevMode() || !workspaceId) return

    const supabase = createClient()
    const channel = supabase
      .channel(`conversations-list:${workspaceId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'conversations',
          filter: `workspace_id=eq.${workspaceId}`,
        },
        () => {
          // Invalidate all conversation queries for this workspace
          queryClient.invalidateQueries({
            queryKey: ['conversations', workspaceId],
            exact: false, // Invalidate all pages and filter combinations
          })
        }
      )
      .subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [workspaceId, queryClient])

  return query
}
```
  </action>
  <verify>
Check hook compiles without errors:
```bash
npx tsc --noEmit src/lib/queries/use-conversations.ts
```
  </verify>
  <done>useConversations hook accepts filters object and includes them in query key</done>
</task>

<task type="auto">
  <name>Task 3: Update inbox UI with Active/All toggle</name>
  <files>src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx</files>
  <action>
Update the inbox client to use the new filter system:

1. Replace `showUnreadOnly` state with `viewMode` ('active' | 'all')
2. Pass filters to useConversations hook
3. Add Active/All toggle UI (replaces current Unread button)
4. Show activeCount in sidebar badge
5. Remove client-side unread filtering (now server-side)

Key changes:

```typescript
// State changes
const [viewMode, setViewMode] = useState<'active' | 'all'>('active') // Start on Active per CONTEXT decision
const [statusFilter, setStatusFilter] = useState<LeadStatus[]>([])
const [tagFilter, setTagFilter] = useState<string[]>([])
const [assignedFilter, setAssignedFilter] = useState<string>('all')

// Build filters object
const filters = useMemo(() => ({
  active: viewMode === 'active',
  statusFilters: statusFilter,
  tagFilters: tagFilter,
  assignedTo: assignedFilter,
}), [viewMode, statusFilter, tagFilter, assignedFilter])

// Pass filters to hook
const { data, isLoading: isLoadingConversations } = useConversations(
  workspace.id,
  page,
  filters
)

// Extract activeCount for badge
const activeCount = data?.activeCount ?? 0

// Replace Unread button with Active/All toggle
<div className="flex items-center rounded-full bg-muted p-1">
  <button
    onClick={() => setViewMode('active')}
    className={cn(
      'flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium transition-all',
      viewMode === 'active'
        ? 'bg-background text-foreground shadow-sm'
        : 'text-muted-foreground hover:text-foreground'
    )}
  >
    <Mail className="h-3.5 w-3.5" />
    Active
    {activeCount > 0 && (
      <span className="bg-primary text-primary-foreground px-1.5 py-0.5 rounded-full text-[10px]">
        {activeCount}
      </span>
    )}
  </button>
  <button
    onClick={() => setViewMode('all')}
    className={cn(
      'flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium transition-all',
      viewMode === 'all'
        ? 'bg-background text-foreground shadow-sm'
        : 'text-muted-foreground hover:text-foreground'
    )}
  >
    <MailOpen className="h-3.5 w-3.5" />
    All
  </button>
</div>

// Remove the useMemo for filteredConversations that filters by showUnreadOnly
// (filtering is now done server-side)
// Keep only search query filtering (client-side for instant feedback)
const filteredConversations = useMemo(() => {
  if (!searchQuery) return conversations
  return conversations.filter((conv) =>
    conv.contact.name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
    conv.contact.phone.includes(searchQuery)
  )
}, [conversations, searchQuery])
```

Also remove the `hasStatusFilter` prop from ConversationList - update empty state to check filters:

```typescript
// In ConversationList component, update empty state logic
const hasFilters = viewMode === 'active' || statusFilter.length > 0 || tagFilter.length > 0

// Pass hasFilters to ConversationList
<ConversationList
  conversations={filteredConversations}
  selectedId={selectedConversation?.id || null}
  onSelect={handleSelectConversation}
  searchQuery={searchQuery}
  hasFilters={hasFilters}  // renamed from hasStatusFilter
  workspaceName={workspace.name}
/>
```
  </action>
  <verify>
1. Start dev server: `npm run dev`
2. Navigate to inbox
3. Verify Active/All toggle works - Active shows only unread conversations
4. Verify badge shows correct count
5. Verify status and tag filters still work
6. Verify switching between Active/All rerenders conversation list
  </verify>
  <done>Inbox has Active/All toggle, server-side filtering, and activeCount badge</done>
</task>

<task type="auto">
  <name>Task 4: Implement filter preset save/load functionality</name>
  <files>src/app/(dashboard)/[workspace]/inbox/inbox-client.tsx</files>
  <action>
Add filter preset management to the inbox. Per RESEARCH.md, store presets in workspace_members.settings JSONB (max 10 presets).

1. Define FilterPreset interface:
```typescript
interface FilterPreset {
  id: string
  name: string
  filters: {
    active: boolean
    statusFilters: string[]
    tagFilters: string[]
    assignedTo: string
  }
}
```

2. Add state and hooks for preset management:
```typescript
const [presets, setPresets] = useState<FilterPreset[]>([])
const [showSavePresetDialog, setShowSavePresetDialog] = useState(false)
const [presetName, setPresetName] = useState('')

// Load presets from workspace member settings on mount
useEffect(() => {
  const loadPresets = async () => {
    const supabase = createClient()
    const { data } = await supabase
      .from('workspace_members')
      .select('settings')
      .eq('workspace_id', workspace.id)
      .eq('user_id', currentUserId)
      .single()

    if (data?.settings?.filterPresets) {
      setPresets(data.settings.filterPresets)
    }
  }
  loadPresets()
}, [workspace.id, currentUserId])
```

3. Implement save preset function:
```typescript
const savePreset = async () => {
  if (!presetName.trim()) return

  const newPreset: FilterPreset = {
    id: crypto.randomUUID(),
    name: presetName.trim(),
    filters: {
      active: viewMode === 'active',
      statusFilters: statusFilter,
      tagFilters: tagFilter,
      assignedTo: assignedFilter,
    },
  }

  // Limit to 10 presets max (per RESEARCH.md pitfall #6)
  const updatedPresets = [...presets, newPreset].slice(-10)

  const supabase = createClient()
  const { error } = await supabase
    .from('workspace_members')
    .update({
      settings: {
        filterPresets: updatedPresets,
      },
    })
    .eq('workspace_id', workspace.id)
    .eq('user_id', currentUserId)

  if (!error) {
    setPresets(updatedPresets)
    setPresetName('')
    setShowSavePresetDialog(false)
    toast.success('Filter preset saved')
  }
}
```

4. Implement load preset function:
```typescript
const loadPreset = (preset: FilterPreset) => {
  setViewMode(preset.filters.active ? 'active' : 'all')
  setStatusFilter(preset.filters.statusFilters)
  setTagFilter(preset.filters.tagFilters)
  setAssignedFilter(preset.filters.assignedTo)
}
```

5. Implement delete preset function:
```typescript
const deletePreset = async (presetId: string) => {
  const updatedPresets = presets.filter(p => p.id !== presetId)

  const supabase = createClient()
  await supabase
    .from('workspace_members')
    .update({
      settings: {
        filterPresets: updatedPresets,
      },
    })
    .eq('workspace_id', workspace.id)
    .eq('user_id', currentUserId)

  setPresets(updatedPresets)
  toast.success('Preset deleted')
}
```

6. Add UI for preset management near the filters:
```typescript
// Preset dropdown/popover near filter controls
<DropdownMenu>
  <DropdownMenuTrigger asChild>
    <Button variant="outline" size="sm" className="gap-1.5">
      <Bookmark className="h-3.5 w-3.5" />
      Presets
      {presets.length > 0 && (
        <span className="text-muted-foreground">({presets.length})</span>
      )}
    </Button>
  </DropdownMenuTrigger>
  <DropdownMenuContent align="start" className="w-56">
    {presets.length === 0 ? (
      <DropdownMenuItem disabled>No saved presets</DropdownMenuItem>
    ) : (
      presets.map((preset) => (
        <DropdownMenuItem
          key={preset.id}
          className="flex items-center justify-between"
        >
          <span onClick={() => loadPreset(preset)} className="flex-1 cursor-pointer">
            {preset.name}
          </span>
          <Button
            variant="ghost"
            size="icon"
            className="h-6 w-6"
            onClick={(e) => {
              e.stopPropagation()
              deletePreset(preset.id)
            }}
          >
            <Trash2 className="h-3 w-3" />
          </Button>
        </DropdownMenuItem>
      ))
    )}
    <DropdownMenuSeparator />
    <DropdownMenuItem onClick={() => setShowSavePresetDialog(true)}>
      <Plus className="h-3.5 w-3.5 mr-2" />
      Save current filters
    </DropdownMenuItem>
  </DropdownMenuContent>
</DropdownMenu>

// Save preset dialog
<Dialog open={showSavePresetDialog} onOpenChange={setShowSavePresetDialog}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle>Save Filter Preset</DialogTitle>
    </DialogHeader>
    <Input
      placeholder="Preset name (e.g., 'Hot leads with unread')"
      value={presetName}
      onChange={(e) => setPresetName(e.target.value)}
    />
    <DialogFooter>
      <Button variant="outline" onClick={() => setShowSavePresetDialog(false)}>
        Cancel
      </Button>
      <Button onClick={savePreset} disabled={!presetName.trim()}>
        Save
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

7. Add necessary imports:
```typescript
import { Bookmark, Plus, Trash2 } from 'lucide-react'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
```
  </action>
  <verify>
1. Start dev server: `npm run dev`
2. Navigate to inbox
3. Set some filters (Active + Hot status + a tag)
4. Click "Presets" > "Save current filters"
5. Enter name "Hot leads with unread" and save
6. Clear filters, then load the preset
7. Verify all filters are restored
8. Delete the preset and verify it's removed
  </verify>
  <done>Users can save up to 10 filter presets, load them with one click, and delete unwanted presets</done>
</task>

</tasks>

<verification>
1. Active filter: Click "Active" - only conversations with unread_count > 0 appear
2. All filter: Click "All" - all conversations appear regardless of unread status
3. Status filter: Select "Hot" - only hot leads appear (works in both Active and All)
4. Tag filter: Select "Australia" - only contacts with Australia tag appear
5. Combined filters: Active + Hot + Australia - shows only unread hot leads tagged Australia
6. Badge updates: activeCount in toggle badge matches actual unread conversation count
7. Real-time: When new message arrives, activeCount updates
8. Save preset: Save "Hot leads with unread" preset with Active + Hot filters
9. Load preset: Click preset to restore all saved filters
10. Delete preset: Remove preset and verify it's gone
11. Max presets: Save 11 presets, verify only newest 10 are kept
</verification>

<success_criteria>
- [x] Active/All toggle replaces Unread button
- [x] Active view shows only unread conversations (server-side filter)
- [x] All view shows all conversations
- [x] Default view is Active (per CONTEXT.md decision)
- [x] Badge shows activeCount in Active button
- [x] Status filter works with Active/All
- [x] Tag filter works with Active/All
- [x] Assigned filter works with Active/All
- [x] Filters are passed to API as query params
- [x] Query key includes filters for proper caching
- [x] Users can save filter presets (max 10)
- [x] Users can load saved presets with one click
- [x] Users can delete presets
- [x] Presets stored in workspace_members.settings JSONB
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-inbox-overhaul/01-04-SUMMARY.md`
</output>
