---
phase: 03-convex-spike
plan: 05
type: execute
wave: 4
depends_on: ["03-03", "03-04"]
files_modified: [scripts/benchmark.ts, scripts/quick-convex-test.js]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Benchmark script runs 50 Supabase queries and 50 Convex queries"
    - "Script measures P50, P95, P99 response times"
    - "Comparison statistics are generated"
    - "Real-time subscription test is included"
  artifacts:
    - path: "scripts/benchmark.ts"
      provides: "Performance comparison script"
  key_links:
    - from: "scripts/benchmark.ts"
      to: "/api/contacts/by-phone"
      via: "HTTP fetch"
      pattern: "fetch.*api/contacts/by-phone"
    - from: "scripts/benchmark.ts"
      to: "/api/contacts/by-phone-convex"
      via: "HTTP fetch"
      pattern: "fetch.*api/contacts/by-phone-convex"
---

<objective>
Create and run performance benchmark comparing Supabase vs Convex contact lookup.

Purpose: Measure actual response times of both systems with identical queries on the same data to make data-driven decision about whether Convex migration is worth the effort.

Output: Benchmark results with P50/P95/P99 metrics for both Supabase and Convex implementations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-convex-spike/03-RESEARCH.md
@.planning/phases/10-convex-spike/README.md
@src/app/api/contacts/by-phone/route.ts
@src/app/api/contacts/by-phone-convex/route.ts

# Reference existing test script
@scripts/quick-convex-test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comprehensive benchmark script</name>
  <files>scripts/benchmark.ts</files>
  <action>
    Create scripts/benchmark.ts with comprehensive benchmark:

    1. Import dependencies:
       - performance for timing
       - @supabase/supabase-js for direct Supabase queries
       - fetch for HTTP benchmarking

    2. Define configuration:
       ```
       const CONFIG = {
         TEST_WORKSPACE_ID: process.env.TEST_WORKSPACE_ID || "25de3c4e-b9ca-4aff-9639-b35668f0a48e",
         TEST_PHONE: process.env.TEST_PHONE || "6281234567890",
         API_URL: "http://localhost:3000",
         ITERATIONS: 50,
         CRM_API_KEY: process.env.CRM_API_KEY || "",
       };
       ```

    3. Define utility function for statistics:
       ```
       function calculateStats(latencies: number[]) {
         const sorted = [...latencies].sort((a, b) => a - b);
         const p50 = sorted[Math.floor(sorted.length * 0.5)];
         const p95 = sorted[Math.floor(sorted.length * 0.95)];
         const p99 = sorted[Math.floor(sorted.length * 0.99)];
         const mean = sorted.reduce((a, b) => a + b, 0) / sorted.length;
         const min = sorted[0];
         const max = sorted[sorted.length - 1];

         return { p50, p95, p99, mean, min, max };
       }

       function formatResult(label: string, stats: any) {
         return `
         ${label}:
           P50: ${stats.p50.toFixed(0)}ms
           P95: ${stats.p95.toFixed(0)}ms
           P99: ${stats.p99.toFixed(0)}ms
           Mean: ${stats.mean.toFixed(0)}ms
           Min: ${stats.min.toFixed(0)}ms
           Max: ${stats.max.toFixed(0)}ms
         `.trim();
       }
       ```

    4. Benchmark 1: Direct Supabase database queries
       ```
       async function benchmarkSupabaseDirect(): Promise<number[]> {
         const supabase = createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL!,
           process.env.SUPABASE_SERVICE_ROLE_KEY!
         );
         const latencies: number[] = [];

         for (let i = 0; i < CONFIG.ITERATIONS; i++) {
           const start = performance.now();

           // Replicate /api/contacts/by-phone query pattern
           const { data: contact } = await supabase
             .from('contacts')
             .select('id, name, phone, email, lead_status, lead_score, tags, metadata, created_at')
             .eq('workspace_id', CONFIG.TEST_WORKSPACE_ID)
             .eq('phone', CONFIG.TEST_PHONE)
             .single();

           if (contact) {
             await Promise.all([
               supabase.from('contact_notes').select('content, created_at').eq('contact_id', contact.id).order('created_at', { ascending: false }).limit(5),
               supabase.from('conversations').select('id, last_message_preview, last_message_at').eq('contact_id', contact.id).single(),
             ]);
           }

           latencies.push(performance.now() - start);
           console.log(`[${i+1}/${CONFIG.ITERATIONS}] Supabase Direct: ${latencies[latencies.length - 1].toFixed(0)}ms`);
         }

         return latencies;
       }
       ```

    5. Benchmark 2: Supabase via API route (full stack)
       ```
       async function benchmarkSupabaseApi(): Promise<number[]> {
         const latencies: number[] = [];

         for (let i = 0; i < CONFIG.ITERATIONS; i++) {
           const start = performance.now();

           const response = await fetch(`${CONFIG.API_URL}/api/contacts/by-phone?phone=${CONFIG.TEST_PHONE}&workspace_id=${CONFIG.TEST_WORKSPACE_ID}`, {
             headers: { 'x-api-key': CONFIG.CRM_API_KEY },
           });

           await response.json();
           latencies.push(performance.now() - start);
           console.log(`[${i+1}/${CONFIG.ITERATIONS}] Supabase API: ${latencies[latencies.length - 1].toFixed(0)}ms`);
         }

         return latencies;
       }
       ```

    6. Benchmark 3: Convex direct queries (using Convex client)
       ```
       async function benchmarkConvexDirect(): Promise<number[]> {
         // Note: This requires Convex client setup
         // For spike, we'll use HTTP action benchmark instead
         return []; // Placeholder - will use HTTP action
       }
       ```

    7. Benchmark 4: Convex via API route (full stack)
       ```
       async function benchmarkConvexApi(): Promise<number[]> {
         const latencies: number[] = [];

         for (let i = 0; i < CONFIG.ITERATIONS; i++) {
           const start = performance.now();

           const response = await fetch(`${CONFIG.API_URL}/api/contacts/by-phone-convex?phone=${CONFIG.TEST_PHONE}&workspace_id=${CONFIG.TEST_WORKSPACE_ID}`, {
             headers: { 'x-api-key': CONFIG.CRM_API_KEY },
           });

           await response.json();
           latencies.push(performance.now() - start);
           console.log(`[${i+1}/${CONFIG.ITERATIONS}] Convex API: ${latencies[latencies.length - 1].toFixed(0)}ms`);
         }

         return latencies;
       }
       ```

    8. Benchmark 5: Real-time subscription latency (Convex)
       ```
       async function benchmarkConvexRealtime(): Promise<number[]> {
         // Measure time from data change to client notification
         // This requires Convex React client
         // For spike, use a simple subscription test:
         const latencies: number[] = [];

         console.log("Real-time subscription test:");
         console.log("This requires running Convex React client test");
         console.log("Skipping for now - can be tested manually in browser");

         return latencies;
       }
       ```

    9. Main execution:
       ```
       async function main() {
         console.log("=== Performance Benchmark ===");
         console.log(`Workspace ID: ${CONFIG.TEST_WORKSPACE_ID}`);
         console.log(`Test Phone: ${CONFIG.TEST_PHONE}`);
         console.log(`Iterations: ${CONFIG.ITERATIONS}\n`);

         // Run benchmarks
         const supabaseDirect = await benchmarkSupabaseDirect();
         const supabaseApi = await benchmarkSupabaseApi();
         const convexApi = await benchmarkConvexApi();
         const convexRealtime = await benchmarkConvexRealtime();

         // Calculate statistics
         const statsSupabaseDirect = calculateStats(supabaseDirect);
         const statsSupabaseApi = calculateStats(supabaseApi);
         const statsConvexApi = calculateStats(convexApi);

         // Print comparison
         console.log("\n=== RESULTS ===");
         console.log(formatResult("Supabase Direct", statsSupabaseDirect));
         console.log();
         console.log(formatResult("Supabase API (Full Stack)", statsSupabaseApi));
         console.log();
         console.log(formatResult("Convex API (Full Stack)", statsConvexApi));
         console.log();

         // Compare
         const speedup = statsSupabaseApi.p95 / statsConvexApi.p95;
         console.log(`=== SPEED IMPROVEMENT ===`);
         console.log(`Convex is ${(speedup > 1 ? speedup.toFixed(1) + "x" : "not")} faster than Supabase at P95`);
         console.log();

         // Decision criteria
         console.log(`=== DECISION CRITERIA ===`);
         console.log(`Supabase P95: ${statsSupabaseApi.p95.toFixed(0)}ms`);
         console.log(`Convex P95: ${statsConvexApi.p95.toFixed(0)}ms`);
         console.log(`Target: < 500ms P95`);
         console.log();
         console.log(`Go ahead with migration if:`);
         console.log(`- Convex P95 < 500ms AND`);
         console.log(`- At least 50% faster than Supabase`);
         console.log();
         console.log(`Optimize Supabase instead if:`);
         console.log(`- Results are comparable (< 20% difference)`);
       }

       main().catch(console.error);
       ```

    Reference: README.md section on "Running the Benchmark"
    Reference: scripts/quick-convex-test.js for existing pattern
  </action>
  <verify>
    grep -q "benchmarkSupabaseDirect" scripts/benchmark.ts
    grep -q "benchmarkSupabaseApi" scripts/benchmark.ts
    grep -q "benchmarkConvexApi" scripts/benchmark.ts
    grep -q "calculateStats" scripts/benchmark.ts
  </verify>
  <done>
    benchmark.ts exists with 50 iterations for each test, calculates P50/P95/P99, outputs comparison
  </done>
</task>

<task type="auto">
  <name>Task 2: Update quick-convex-test.js for real-time subscription test</name>
  <files>scripts/quick-convex-test.js</files>
  <action>
    Update scripts/quick-convex-test.js to include real-time subscription test:

    1. Keep existing HTTP endpoint test
    2. Add real-time subscription test section:
       - Test subscription latency by watching a query
       - Measure time from data write to client update
    3. Instructions for running in browser (use convex-test.html)

    Reference: convex-test.html for existing test pattern
    Reference: README.md for real-time subscription test requirements
  </action>
  <verify>
    grep -q "convex" scripts/quick-convex-test.js
  </verify>
  <done>
    quick-convex-test.js updated with real-time subscription test instructions
  </done>
</task>

</tasks>

<verification>
- scripts/benchmark.ts exists with comprehensive test suite
- Script benchmarks Supabase direct, Supabase API, and Convex API
- Script calculates P50, P95, P99 statistics
- Script outputs comparison and decision criteria
- quick-convex-test.js updated for real-time testing
</verification>

<success_criteria>
- Benchmark script runs 50 iterations of Supabase and Convex queries
- Script measures P50, P95, P99 response times
- Comparison statistics are generated
- Real-time subscription test is included
</success_criteria>

<output>
After completion, create `.planning/phases/10-convex-spike/03-05-SUMMARY.md`
</output>
