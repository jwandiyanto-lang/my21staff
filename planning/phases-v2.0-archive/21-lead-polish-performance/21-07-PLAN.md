---
wave: 3
depends_on: []
files_modified: [src/app/api/webhook/kapso/route.ts]
autonomous: true
---

# 21-07: Webhook Batching Optimization

## Objective

Optimize webhook processing to return immediately and batch database operations for better performance.

## Tasks

<task id="1">
Review current webhook processing in `src/app/api/webhook/kapso/route.ts`:

Current pattern (lines 118-256):
```typescript
for (const entry of payload.entry) {
  for (const change of entry.changes) {
    for (const message of messages) {
      // getOrCreateContact() - one query each
      // getOrCreateConversation() - one query each
      // Insert message
      // Update conversation metadata
    }
  }
}
```

This is O(n) database calls where n = number of messages.
</task>

<task id="2">
Refactor to batch operations:

```typescript
// At the top of the POST handler, after validation
// Return 200 immediately and process async
const processingPromise = processWebhookPayload(payload, supabase)

// Don't await - let it run in background
processingPromise.catch(error => {
  console.error('Webhook processing error:', error)
})

return NextResponse.json({ success: true })

// Helper function for async processing
async function processWebhookPayload(payload: any, supabase: any) {
  // Collect all unique phone numbers first
  const phoneNumbers = new Set<string>()
  const messagesData: MessageData[] = []

  for (const entry of payload.entry) {
    for (const change of entry.changes) {
      const messages = change.value?.messages || []
      for (const message of messages) {
        const phone = message.from
        phoneNumbers.add(phone)
        messagesData.push({
          phone,
          message,
          timestamp: new Date(parseInt(message.timestamp) * 1000),
        })
      }
    }
  }

  if (messagesData.length === 0) return

  // Batch 1: Get or create all contacts at once
  const phoneArray = Array.from(phoneNumbers)
  const contactMap = await getOrCreateContacts(supabase, phoneArray, workspaceId)

  // Batch 2: Get or create all conversations at once
  const conversationMap = await getOrCreateConversations(supabase, contactMap, workspaceId)

  // Batch 3: Insert all messages at once
  const messageInserts = messagesData.map(({ phone, message, timestamp }) => ({
    conversation_id: conversationMap.get(phone)?.id,
    direction: 'inbound',
    content: message.text?.body || '',
    message_type: message.type,
    external_id: message.id,
    timestamp,
    metadata: message,
  })).filter(m => m.conversation_id)

  if (messageInserts.length > 0) {
    await supabase.from('messages').insert(messageInserts)
  }

  // Batch 4: Update all conversation timestamps at once
  for (const [phone, conversation] of conversationMap) {
    await supabase
      .from('conversations')
      .update({
        last_message_at: new Date().toISOString(),
        message_count: conversation.message_count + 1,
      })
      .eq('id', conversation.id)
  }
}
```
</task>

<task id="3">
Create helper functions for batch operations:

```typescript
// Batch get or create contacts
async function getOrCreateContacts(
  supabase: any,
  phones: string[],
  workspaceId: string
): Promise<Map<string, Contact>> {
  const contactMap = new Map<string, Contact>()

  // Get existing contacts
  const { data: existing } = await supabase
    .from('contacts')
    .select('*')
    .eq('workspace_id', workspaceId)
    .in('phone', phones)

  for (const contact of existing || []) {
    contactMap.set(contact.phone, contact)
  }

  // Create missing contacts
  const missingPhones = phones.filter(p => !contactMap.has(p))
  if (missingPhones.length > 0) {
    const newContacts = missingPhones.map(phone => ({
      workspace_id: workspaceId,
      phone,
      name: null,
      lead_status: 'prospect',
      lead_score: 50,
    }))

    const { data: created } = await supabase
      .from('contacts')
      .insert(newContacts)
      .select()

    for (const contact of created || []) {
      contactMap.set(contact.phone, contact)
    }
  }

  return contactMap
}

// Batch get or create conversations
async function getOrCreateConversations(
  supabase: any,
  contactMap: Map<string, Contact>,
  workspaceId: string
): Promise<Map<string, Conversation>> {
  const conversationMap = new Map<string, Conversation>()
  const contactIds = Array.from(contactMap.values()).map(c => c.id)

  // Get existing conversations
  const { data: existing } = await supabase
    .from('conversations')
    .select('*')
    .eq('workspace_id', workspaceId)
    .in('contact_id', contactIds)

  for (const conv of existing || []) {
    const contact = Array.from(contactMap.values()).find(c => c.id === conv.contact_id)
    if (contact) {
      conversationMap.set(contact.phone, conv)
    }
  }

  // Create missing conversations
  const missingContacts = Array.from(contactMap.entries())
    .filter(([phone]) => !conversationMap.has(phone))

  if (missingContacts.length > 0) {
    const newConversations = missingContacts.map(([, contact]) => ({
      workspace_id: workspaceId,
      contact_id: contact.id,
      status: 'active',
      message_count: 0,
    }))

    const { data: created } = await supabase
      .from('conversations')
      .insert(newConversations)
      .select()

    for (const conv of created || []) {
      const contact = Array.from(contactMap.values()).find(c => c.id === conv.contact_id)
      if (contact) {
        conversationMap.set(contact.phone, conv)
      }
    }
  }

  return conversationMap
}
```
</task>

<task id="4">
Add error handling and logging:

```typescript
// Add at the top of processWebhookPayload
const startTime = Date.now()
console.log(`Processing webhook with ${messagesData.length} messages`)

// After processing
const duration = Date.now() - startTime
console.log(`Webhook processed in ${duration}ms`)
```

Ensure PII masking is applied to phone numbers in logs (per Phase 19 decisions).
</task>

## Verification

- [ ] Webhook returns 200 immediately (< 100ms response time)
- [ ] Messages are still processed correctly (appear in inbox)
- [ ] Contacts are created for new phone numbers
- [ ] Conversations are created/updated correctly
- [ ] Batch queries reduce database calls (from O(n) to O(1) per batch)
- [ ] Errors are logged but don't affect response

## must_haves

- Immediate 200 response (don't block on processing)
- Batch contact/conversation lookups
- Batch message inserts
- Error handling that doesn't break the webhook
