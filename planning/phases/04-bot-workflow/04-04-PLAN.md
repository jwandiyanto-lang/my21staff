---
phase: 04-bot-workflow
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03", "04-05"]
files_modified:
  - convex/kapso.ts
  - convex/ai/mouth.ts
autonomous: true

must_haves:
  truths:
    - "Mouth receives conversation state from ariConversation"
    - "Mouth generates state-appropriate responses"
    - "Brain's next_action is checked after analysis"
    - "Consultation requests trigger handleConsultationRequest"
  artifacts:
    - path: "convex/kapso.ts"
      provides: "Enhanced processARI with state passing and next_action handling"
    - path: "convex/ai/mouth.ts"
      provides: "Mouth accepts state/context/communityLink"
  key_links:
    - from: "kapso.ts processARI"
      to: "mouth.ts generateMouthResponse"
      via: "passes state and context"
      pattern: "state.*context"
    - from: "kapso.ts getAriContext"
      to: "ariConversations.state"
      via: "reads conversation state"
      pattern: "ariConversation\\.state"
    - from: "kapso.ts processARI"
      to: "handleConsultationRequest"
      via: "checks brainResponse.analysis.next_action"
      pattern: "next_action.*offer_consultation|handoff_human"
---

<objective>
Wire state and context through processARI to Mouth, and wire Brain's next_action to consultation handling.

Purpose: Enable the bot to use conversation state and collected data when generating responses, and trigger human handoff when Brain detects consultation requests
Output: processARI passes state/context to Mouth, checks Brain's next_action, and calls handleConsultationRequest when appropriate
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@planning/PROJECT.md
@planning/ROADMAP.md
@planning/phases/04-bot-workflow/04-RESEARCH.md
@planning/phases/04-bot-workflow/04-05-SUMMARY.md
@convex/kapso.ts
@convex/ai/mouth.ts
@convex/ai/context.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update getAriContext to return state and context</name>
  <files>convex/kapso.ts</files>
  <action>
Enhance getAriContext mutation to return additional fields:

1. Add state and context to the return object:
```typescript
return {
  workspace: {
    meta_access_token: workspace.meta_access_token,
    kapso_phone_id: workspace.kapso_phone_id,
  },
  ariConfig: {
    bot_name: ariConfig.bot_name,
    language: ariConfig.language,
    community_link: ariConfig.community_link,  // ADD THIS
  },
  contact: {
    name: contact.name,
    kapso_name: contact.kapso_name,
    lead_score: contact.lead_score,
  },
  ariConversationId: ariConversation._id,
  ariState: ariConversation.state,           // ADD THIS
  ariContext: ariConversation.context,       // ADD THIS
  messageHistory: recentMessages.reverse().map((m: any) => ({
    role: m.role,
    content: m.content,
  })),
};
```

This allows processARI to pass state and context to the Mouth.
  </action>
  <verify>`npx convex dev --once` compiles without errors</verify>
  <done>getAriContext returns ariState, ariContext, and community_link</done>
</task>

<task type="auto">
  <name>Task 2: Update Mouth to accept state/context parameters</name>
  <files>convex/ai/mouth.ts</files>
  <action>
1. Update generateMouthResponse args to accept new parameters:
```typescript
export const generateMouthResponse = internalAction({
  args: {
    conversationHistory: v.array(v.object({
      role: v.string(),
      content: v.string(),
    })),
    userMessage: v.string(),
    botName: v.optional(v.string()),
    contactName: v.optional(v.string()),
    language: v.optional(v.string()),
    state: v.optional(v.string()),           // ADD
    context: v.optional(v.any()),            // ADD (QualificationContext)
    communityLink: v.optional(v.string()),   // ADD
  },
  handler: async (ctx, args): Promise<MouthResponse> => {
```

2. Update the call to buildMouthSystemPrompt to pass new parameters:
```typescript
import { buildMouthSystemPrompt, QualificationContext } from "./context";

// In handler:
const systemPrompt = buildMouthSystemPrompt(
  args.botName ?? "Ari",
  args.contactName ?? "kakak",
  args.language ?? "id",
  args.state ?? "greeting",
  args.context as QualificationContext | undefined,
  args.communityLink
);
```
  </action>
  <verify>
1. `npx convex dev --once` compiles
2. `grep -n "state.*context" convex/ai/mouth.ts` shows new args
  </verify>
  <done>generateMouthResponse accepts state, context, and communityLink parameters</done>
</task>

<task type="auto">
  <name>Task 3: Update processARI to pass state/context to Mouth and wire Brain's next_action</name>
  <files>convex/kapso.ts</files>
  <action>
1. Update the Mouth call in processARI to pass the new parameters:

```typescript
// 2. Call The Mouth for AI response
console.log(`[ARI] Step 2: Calling The Mouth (state=${context.ariState})...`);
let mouthResponse;
try {
  mouthResponse = await ctx.runAction(internal.ai.mouth.generateMouthResponse, {
    conversationHistory: context.messageHistory,
    userMessage: user_message,
    botName: context.ariConfig.bot_name,
    contactName: context.contact.name || context.contact.kapso_name || undefined,
    language: context.ariConfig.language,
    state: context.ariState,                    // ADD
    context: context.ariContext,                // ADD
    communityLink: context.ariConfig.community_link,  // ADD
  });
} catch (mouthError) {
  // existing fallback logic
}
```

2. After the Brain call in processARI, add logic to check next_action and trigger consultation handling:

```typescript
// 3. Call The Brain for analysis
console.log("[ARI] Step 3: Calling The Brain for analysis...");
let brainResponse;
try {
  brainResponse = await ctx.runAction(internal.ai.brain.analyzeConversation, {
    conversationHistory: context.messageHistory,
    userMessage: user_message,
    currentState: context.ariState,
    currentContext: context.ariContext,
  });
  console.log(`[ARI] Brain analysis: ${JSON.stringify(brainResponse.analysis)}`);
} catch (brainError) {
  // existing error handling
}

// 4. Check Brain's next_action for consultation/handoff triggers
if (brainResponse?.analysis?.next_action) {
  const nextAction = brainResponse.analysis.next_action;

  if (nextAction === "offer_consultation" || nextAction === "handoff_human") {
    console.log(`[ARI] Brain triggered ${nextAction} - calling handleConsultationRequest`);

    await handleConsultationRequest(
      ctx,
      context.workspace._id,      // workspaceId
      context.contact._id,        // contactId
      context.ariConversationId,  // ariConversationId
      nextAction === "handoff_human"
        ? "User explicitly requested human assistance"
        : "User interested in consultation"
    );
  }
}
```

NOTE: handleConsultationRequest was created in Plan 04-05. It's a file-local async function
in convex/kapso.ts that's already available since Plan 05 executed first (this plan depends on 04-05).
  </action>
  <verify>
1. `npx convex dev --once` compiles
2. `grep -n "ariState\|ariContext" convex/kapso.ts` shows state/context usage
3. `grep -n "next_action.*offer_consultation\|handoff_human" convex/kapso.ts` shows next_action check
4. `grep -n "handleConsultationRequest" convex/kapso.ts` shows both definition and call
  </verify>
  <done>processARI passes state/context to Mouth AND checks Brain's next_action to call handleConsultationRequest</done>
</task>

</tasks>

<verification>
- [ ] getAriContext returns ariState, ariContext, community_link
- [ ] generateMouthResponse accepts state, context, communityLink
- [ ] processARI passes all new parameters to Mouth
- [ ] processARI checks brainResponse.analysis.next_action after Brain call
- [ ] processARI calls handleConsultationRequest for offer_consultation/handoff_human
- [ ] TypeScript compiles without errors
</verification>

<success_criteria>
Mouth generates responses based on conversation state (greeting/qualifying/routing) AND Brain's next_action triggers consultation handling when appropriate
</success_criteria>

<output>
After completion, create `planning/phases/04-bot-workflow/04-04-SUMMARY.md`
</output>
