---
phase: 04-bot-workflow
plan: 04
type: execute
wave: 2
depends_on: ["04-01", "04-02", "04-03"]
files_modified:
  - convex/kapso.ts
  - convex/ai/mouth.ts
autonomous: true

must_haves:
  truths:
    - "Mouth receives conversation state from ariConversation"
    - "Mouth generates state-appropriate responses"
    - "Brain's next_action is checked before response"
  artifacts:
    - path: "convex/kapso.ts"
      provides: "Enhanced processARI with state passing"
    - path: "convex/ai/mouth.ts"
      provides: "Mouth accepts state/context/communityLink"
  key_links:
    - from: "kapso.ts processARI"
      to: "mouth.ts generateMouthResponse"
      via: "passes state and context"
      pattern: "state.*context"
    - from: "kapso.ts getAriContext"
      to: "ariConversations.state"
      via: "reads conversation state"
      pattern: "ariConversation\\.state"
---

<objective>
Wire state and context through processARI to Mouth.

Purpose: Enable the bot to use conversation state and collected data when generating responses
Output: processARI passes state/context to Mouth, Mouth uses enhanced system prompt
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@planning/PROJECT.md
@planning/ROADMAP.md
@planning/phases/04-bot-workflow/04-RESEARCH.md
@convex/kapso.ts
@convex/ai/mouth.ts
@convex/ai/context.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update getAriContext to return state and context</name>
  <files>convex/kapso.ts</files>
  <action>
Enhance getAriContext mutation to return additional fields:

1. Add state and context to the return object:
```typescript
return {
  workspace: {
    meta_access_token: workspace.meta_access_token,
    kapso_phone_id: workspace.kapso_phone_id,
  },
  ariConfig: {
    bot_name: ariConfig.bot_name,
    language: ariConfig.language,
    community_link: ariConfig.community_link,  // ADD THIS
  },
  contact: {
    name: contact.name,
    kapso_name: contact.kapso_name,
    lead_score: contact.lead_score,
  },
  ariConversationId: ariConversation._id,
  ariState: ariConversation.state,           // ADD THIS
  ariContext: ariConversation.context,       // ADD THIS
  messageHistory: recentMessages.reverse().map((m: any) => ({
    role: m.role,
    content: m.content,
  })),
};
```

This allows processARI to pass state and context to the Mouth.
  </action>
  <verify>`npx convex dev --once` compiles without errors</verify>
  <done>getAriContext returns ariState, ariContext, and community_link</done>
</task>

<task type="auto">
  <name>Task 2: Update Mouth to accept state/context parameters</name>
  <files>convex/ai/mouth.ts</files>
  <action>
1. Update generateMouthResponse args to accept new parameters:
```typescript
export const generateMouthResponse = internalAction({
  args: {
    conversationHistory: v.array(v.object({
      role: v.string(),
      content: v.string(),
    })),
    userMessage: v.string(),
    botName: v.optional(v.string()),
    contactName: v.optional(v.string()),
    language: v.optional(v.string()),
    state: v.optional(v.string()),           // ADD
    context: v.optional(v.any()),            // ADD (QualificationContext)
    communityLink: v.optional(v.string()),   // ADD
  },
  handler: async (ctx, args): Promise<MouthResponse> => {
```

2. Update the call to buildMouthSystemPrompt to pass new parameters:
```typescript
import { buildMouthSystemPrompt, QualificationContext } from "./context";

// In handler:
const systemPrompt = buildMouthSystemPrompt(
  args.botName ?? "Ari",
  args.contactName ?? "kakak",
  args.language ?? "id",
  args.state ?? "greeting",
  args.context as QualificationContext | undefined,
  args.communityLink
);
```
  </action>
  <verify>
1. `npx convex dev --once` compiles
2. `grep -n "state.*context" convex/ai/mouth.ts` shows new args
  </verify>
  <done>generateMouthResponse accepts state, context, and communityLink parameters</done>
</task>

<task type="auto">
  <name>Task 3: Update processARI to pass state/context to Mouth</name>
  <files>convex/kapso.ts</files>
  <action>
Update the Mouth call in processARI to pass the new parameters:

```typescript
// 2. Call The Mouth for AI response
console.log(`[ARI] Step 2: Calling The Mouth (state=${context.ariState})...`);
let mouthResponse;
try {
  mouthResponse = await ctx.runAction(internal.ai.mouth.generateMouthResponse, {
    conversationHistory: context.messageHistory,
    userMessage: user_message,
    botName: context.ariConfig.bot_name,
    contactName: context.contact.name || context.contact.kapso_name || undefined,
    language: context.ariConfig.language,
    state: context.ariState,                    // ADD
    context: context.ariContext,                // ADD
    communityLink: context.ariConfig.community_link,  // ADD
  });
} catch (mouthError) {
  // existing fallback logic
}
```

Add state to the log message so it's visible in console.
  </action>
  <verify>
1. `npx convex dev --once` compiles
2. `grep -n "ariState\|ariContext" convex/kapso.ts` shows usage
  </verify>
  <done>processARI passes state, context, and communityLink to Mouth</done>
</task>

</tasks>

<verification>
- [ ] getAriContext returns ariState, ariContext, community_link
- [ ] generateMouthResponse accepts state, context, communityLink
- [ ] processARI passes all new parameters to Mouth
- [ ] TypeScript compiles without errors
</verification>

<success_criteria>
Mouth generates responses based on conversation state (greeting/qualifying/routing)
</success_criteria>

<output>
After completion, create `planning/phases/04-bot-workflow/04-04-SUMMARY.md`
</output>
