---
phase: 04-bot-workflow
plan: 05
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - convex/kapso.ts
autonomous: true

must_haves:
  truths:
    - "handleConsultationRequest helper exists and is callable"
    - "updateAriContext mutation merges context correctly"
    - "flagForHuman mutation marks conversation for human attention"
  artifacts:
    - path: "convex/kapso.ts"
      provides: "handleConsultationRequest helper + supporting mutations"
  key_links:
    - from: "handleConsultationRequest"
      to: "updateAriContext"
      via: "updates routing.consultation_requested_at"
      pattern: "consultation_requested_at"
    - from: "handleConsultationRequest"
      to: "flagForHuman"
      via: "marks conversation for human attention"
      pattern: "flagForHuman"
---

<objective>
Create consultation request handling helpers and supporting mutations.

Purpose: Provide the helpers that processARI will call when Brain detects consultation requests
Output: handleConsultationRequest helper function + updateAriContext, flagForHuman, findConversationByContact mutations
Note: These helpers are CALLED by Plan 04-04 Task 4 (which depends on this plan)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@planning/PROJECT.md
@planning/ROADMAP.md
@planning/phases/04-bot-workflow/04-RESEARCH.md
@convex/kapso.ts
@convex/ai/brain.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add updateAriContext mutation</name>
  <files>convex/kapso.ts</files>
  <action>
Add helper mutation to update ariConversation context field:

```typescript
/**
 * Update ariConversation context with new data.
 * Merges new data with existing context.
 */
export const updateAriContext = internalMutation({
  args: {
    ariConversationId: v.id("ariConversations"),
    updates: v.any(), // Partial QualificationContext
  },
  handler: async (ctx, args) => {
    const conversation = await ctx.db.get(args.ariConversationId);
    if (!conversation) return;

    const existingContext = conversation.context || {};
    const mergedContext = {
      ...existingContext,
      ...args.updates,
      // Deep merge for nested objects
      collected: {
        ...(existingContext.collected || {}),
        ...(args.updates.collected || {}),
      },
      documents: {
        ...(existingContext.documents || {}),
        ...(args.updates.documents || {}),
      },
      routing: {
        ...(existingContext.routing || {}),
        ...(args.updates.routing || {}),
      },
    };

    await ctx.db.patch(args.ariConversationId, {
      context: mergedContext,
      updated_at: Date.now(),
    });
  },
});
```
  </action>
  <verify>`npx convex dev --once` compiles without errors</verify>
  <done>updateAriContext mutation exists and merges context correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add handleConsultationRequest helper and supporting mutations</name>
  <files>convex/kapso.ts</files>
  <action>
Add the handleConsultationRequest helper function and supporting mutations:

1. Add supporting mutations first (near other mutations):
```typescript
export const flagForHuman = internalMutation({
  args: {
    conversationId: v.id("conversations"),
    reason: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.conversationId, {
      status: "open",  // Ensure it's visible
      unread_count: 1, // Flag as needing attention
      updated_at: Date.now(),
    });
  },
});

export const findConversationByContact = internalQuery({
  args: {
    contactId: v.id("contacts"),
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("conversations")
      .withIndex("by_contact", (q) => q.eq("contact_id", args.contactId))
      .first();
  },
});
```

NOTE: Add `internalQuery` import at top if not present:
```typescript
import { internalQuery } from "./_generated/server";
```

2. Add helper function (can be placed near processARI or at bottom of file):
```typescript
/**
 * Handle consultation request - update state and notify human.
 * Called when Brain's next_action is "offer_consultation" or "handoff_human".
 * This function is CALLED by Plan 04-04 Task 4 in processARI.
 */
async function handleConsultationRequest(
  ctx: any,
  workspaceId: string,
  contactId: string,
  ariConversationId: string,
  reason: string
): Promise<void> {
  const now = Date.now();

  // Update context to mark consultation requested
  await ctx.runMutation(internal.kapso.updateAriContext, {
    ariConversationId,
    updates: {
      routing: {
        consultation_requested_at: now,
        choice: "consultation",
      },
    },
  });

  // Update conversation state to handoff
  await ctx.runMutation(internal.ai.brain.updateConversationState, {
    ariConversationId,
    state: "handoff",
    leadScore: 70, // Minimum hot lead score
    leadTemperature: "hot",
  });

  // Update conversation status to flag for human attention
  // Find the regular conversation and mark unread
  const conversation = await ctx.runQuery(internal.kapso.findConversationByContact, {
    contactId,
  });

  if (conversation) {
    await ctx.runMutation(internal.kapso.flagForHuman, {
      conversationId: conversation._id,
      reason,
    });
  }

  console.log(`[ARI] Consultation requested - flagged for human (${reason})`);
}
```

NOTE: The call to this function is added in Plan 04-04 Task 4 (which depends on this plan).
  </action>
  <verify>
1. `npx convex dev --once` compiles
2. `grep -n "handleConsultationRequest\|flagForHuman\|findConversationByContact" convex/kapso.ts` shows all functions
  </verify>
  <done>handleConsultationRequest helper exists with all supporting mutations</done>
</task>

</tasks>

<verification>
- [ ] updateAriContext mutation exists
- [ ] handleConsultationRequest helper function exists
- [ ] flagForHuman mutation exists
- [ ] findConversationByContact query exists
- [ ] internalQuery is imported
- [ ] TypeScript compiles without errors
</verification>

<success_criteria>
handleConsultationRequest helper and all supporting mutations exist, ready to be called by Plan 04-04's next_action wiring
</success_criteria>

<output>
After completion, create `planning/phases/04-bot-workflow/04-05-SUMMARY.md`
</output>
