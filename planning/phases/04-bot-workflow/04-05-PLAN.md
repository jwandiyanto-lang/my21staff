---
phase: 04-bot-workflow
plan: 05
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - convex/kapso.ts
  - convex/ai/brain.ts
autonomous: true

must_haves:
  truths:
    - "Human receives notification when consultation is requested"
    - "Conversation state updates to 'handoff' on consultation request"
    - "Brain's next_action triggers appropriate responses"
  artifacts:
    - path: "convex/kapso.ts"
      provides: "Consultation request handling + human notification"
    - path: "convex/ai/brain.ts"
      provides: "Context update mutation"
  key_links:
    - from: "kapso.ts processARI"
      to: "brain.analyzeConversation next_action"
      via: "checks next_action for routing"
      pattern: "next_action.*offer_consultation"
---

<objective>
Implement human notification when consultation is requested.

Purpose: Ensure hot leads who want 1-on-1 consultation are flagged for human follow-up
Output: When Brain detects consultation request, update state and notify human
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@planning/PROJECT.md
@planning/ROADMAP.md
@planning/phases/04-bot-workflow/04-RESEARCH.md
@convex/kapso.ts
@convex/ai/brain.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add updateAriContext mutation</name>
  <files>convex/kapso.ts</files>
  <action>
Add helper mutation to update ariConversation context field:

```typescript
/**
 * Update ariConversation context with new data.
 * Merges new data with existing context.
 */
export const updateAriContext = internalMutation({
  args: {
    ariConversationId: v.id("ariConversations"),
    updates: v.any(), // Partial QualificationContext
  },
  handler: async (ctx, args) => {
    const conversation = await ctx.db.get(args.ariConversationId);
    if (!conversation) return;

    const existingContext = conversation.context || {};
    const mergedContext = {
      ...existingContext,
      ...args.updates,
      // Deep merge for nested objects
      collected: {
        ...(existingContext.collected || {}),
        ...(args.updates.collected || {}),
      },
      documents: {
        ...(existingContext.documents || {}),
        ...(args.updates.documents || {}),
      },
      routing: {
        ...(existingContext.routing || {}),
        ...(args.updates.routing || {}),
      },
    };

    await ctx.db.patch(args.ariConversationId, {
      context: mergedContext,
      updated_at: Date.now(),
    });
  },
});
```
  </action>
  <verify>`npx convex dev --once` compiles without errors</verify>
  <done>updateAriContext mutation exists and merges context correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add handleConsultationRequest helper in processARI</name>
  <files>convex/kapso.ts</files>
  <action>
Add logic after Brain analysis to handle consultation requests:

1. Create helper function at the bottom of the file:
```typescript
/**
 * Handle consultation request - update state and notify human.
 * Called when Brain's next_action is "offer_consultation" or "handoff_human".
 */
async function handleConsultationRequest(
  ctx: any,
  workspaceId: string,
  contactId: string,
  ariConversationId: string,
  reason: string
): Promise<void> {
  const now = Date.now();

  // Update context to mark consultation requested
  await ctx.runMutation(internal.kapso.updateAriContext, {
    ariConversationId,
    updates: {
      routing: {
        consultation_requested_at: now,
        choice: "consultation",
      },
    },
  });

  // Update conversation state to handoff
  await ctx.runMutation(internal.ai.brain.updateConversationState, {
    ariConversationId,
    state: "handoff",
    leadScore: 70, // Minimum hot lead score
    leadTemperature: "hot",
  });

  // Update conversation status to flag for human attention
  // Find the regular conversation and mark unread
  const conversation = await ctx.runQuery(internal.kapso.findConversationByContact, {
    contactId,
  });

  if (conversation) {
    await ctx.runMutation(internal.kapso.flagForHuman, {
      conversationId: conversation._id,
      reason,
    });
  }

  console.log(`[ARI] Consultation requested - flagged for human (${reason})`);
}
```

2. Add supporting mutation for flagForHuman:
```typescript
export const flagForHuman = internalMutation({
  args: {
    conversationId: v.id("conversations"),
    reason: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.conversationId, {
      status: "open",  // Ensure it's visible
      unread_count: 1, // Flag as needing attention
      updated_at: Date.now(),
    });
  },
});

export const findConversationByContact = internalQuery({
  args: {
    contactId: v.id("contacts"),
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("conversations")
      .withIndex("by_contact", (q) => q.eq("contact_id", args.contactId))
      .first();
  },
});
```

NOTE: Add `internalQuery` import at top if not present.
  </action>
  <verify>
1. `npx convex dev --once` compiles
2. `grep -n "handleConsultationRequest\|flagForHuman" convex/kapso.ts` shows functions
  </verify>
  <done>handleConsultationRequest helper exists and flags conversation for human</done>
</task>

</tasks>

<verification>
- [ ] updateAriContext mutation exists
- [ ] handleConsultationRequest helper function exists
- [ ] flagForHuman mutation exists
- [ ] findConversationByContact query exists
- [ ] TypeScript compiles without errors
</verification>

<success_criteria>
When Brain detects consultation request, conversation is flagged for human follow-up
</success_criteria>

<output>
After completion, create `planning/phases/04-bot-workflow/04-05-SUMMARY.md`
</output>
